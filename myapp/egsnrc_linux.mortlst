Mortran 3.2
 Sun Jan  6 15:58:30 2019
               0  %L                                                                     ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc macros                                                              "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2000                                       "
               0  "                   Dave Rogers, 2000                                         "
               0  "                                                                             "
               0  "  Contributors:    Blake Walters                                             "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                   Frederic Tessier                                          "
               0  "                   Reid Townson                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  A large number of people have been involved with the development of EGS    "
               0  "  over the years. Many details are in the manual. The authors want to point  "
               0  "  out the central role of Ralph Nelson of SLAC in the development of EGS     "
               0  "  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
               0  "  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
               0  "  code development. Hideo Hirayama was involved with the development of EGS4 "
               0  "  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
               0  "  developments on EGS4. As well many others and users from around the world  "
               0  "  have assisted in developing and making available the code, in particular   "
               0  "  Robert D. Stewart.                                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  "Compiler directives"
               0  "==================="
               0  %Q1         "Automatically close comments at end of line                       ;
               0              "but this DOES NOT apply withing macro definitions!!
               0  %C80        "Allow 80 columns of source/line (default is 72)                   ;
               0  %L          "Turn on listing                                                   ;
               0
               0
               0  "=================================================================="
               0  " Macros to implement implicit data types                          "
               0  "=================================================================="
               0
               0  REPLACE {$LOGICAL} WITH {;logical}
               0  REPLACE {$REAL}    WITH {;real*8}
               0  REPLACE {$INTEGER} WITH {;integer*4}
               0  REPLACE {$LONG_INT} WITH {;integer*8} "change this to integer*4 for compilers"
               0                                        "that do not support integer*8"
               0  REPLACE {$SHORT_INT} WITH {;integer*2} "change this to integer*4 for compilers"
               0                                        "that do not support integer*2"
               0  "the above is not used in EGSnrc but is used in the NRC user codes,
               0  "especially related to number of histories"
               0  "Note that the HP compiler does not support *8 integers so the above"
               0  " should be changed for HP"
               0
               0  REPLACE {$IMPLICIT-NONE;} WITH {;}
               0  REPLACE {$IMPLICIT-NONE;} WITH {implicit none;}
               0
               0  "=================================================================="
               0  "SELECT THE FORTRAN STANDARD TO BE USED (1966 OR 1977)             "
               0  REPLACE {$FORTVER} WITH {1977}
               0  "=================================================================="
               0
               0  "******************************************************************"
               0  REPLACE {$TYPE} WITH {
            {  0    {SETR F=$FORTVER}
            {  0     [IF] {COPY F}=1977 [CHARACTER*4] [ELSE] [INTEGER*4]
            {  0    }
               0  "******************************************************************"
               0
               0  "******************************************************************"
               0  SPECIFY ALPHA    AS (0...$);
               0  SPECIFY SYMBOL   AS (0...?);
               0  SPECIFY NAME     AS LETTER(0,5)[ALPHA];
               0  SPECIFY <COMMA>  AS [','|''];
               0  SPECIFY <NAME>   AS [NAME|''];
               0  SPECIFY LABEL    AS ':'NAME':';
               0  SPECIFY <LABEL>  AS [LABEL|''];
               0  SPECIFY <*>      AS ['*'|''];
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {NEWLABEL} WITH {@LG}
               0  REPLACE {%'{ARB}'={<*>}'{ARB}'}
               0     WITH {[IF] '{P2}'='*' [APPEND'{P3}'TO'{P1}']
            {  0              [ELSE] [ REPLACE {{P1}}WITH{{P3}}]}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0      "RULES TO GENERALIZE MORTRAN'S INPUT AND OUTPUT"
               0  REPLACE {;$UINPUT(#)#;}
               0     WITH {;{SETR A=NEWLABEL}
            {  0              READ({P1},{COPY A}){P2};{COPY A}FORMAT}
               0
               0  REPLACE {;$UOUTPUT(#)#;}
               0     WITH {;{SETR A=NEWLABEL}
            {  0              WRITE({P1},{COPY A}){P2};{COPY A}FORMAT}
               0
               0  REPLACE {;$ECHO#({NAME}{<COMMA>}#)#;}
               0   WITH {;{SETR X=NEWLABEL}
            {  0   WRITE(IUECHO,{COPY X});{COPY X}FORMAT(' ECHO {P1}:{P5}');
            {  0   [IF] {EXIST 3} [{P1}({P2},{P4}){P5};
            {  0   WRITE(IUECHO,{P4}){P5};]
            {  0   [ELSE] [{SETR Y=NEWLABEL}{P1}({P2},{COPY Y}){P4};
            {  0   WRITE(IUECHO,{COPY Y}){P5};{COPY Y}FORMAT]
            {  0   }
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  REPLACE {;IUECHO=#;} WITH { REPLACE {IUECHO} WITH {{P1}};}
               0  "INITALIZE" ;IUECHO=6;
               0
               0  "MACRO TO SPLIT STRING INTO A LIST SEPARATED BY COMMAS"
               0  REPLACE {$S'{SYMBOL}#'}
               0    WITH {'{P1}'[IF]{EXIST 2}[,$S'{P2}']}
               0
               0  "SOME DEBUGGING MACROS"
               0  REPLACE {$LIST#/#/#;} WITH
               0     {;OUTPUT {P3};('LIST/{P2}/{P3}:'/(1X,{P1}));}
               0  APPEND{;COMMON/QDEBUG/QDEBUG;LOGICAL QDEBUG;} TO {;COMIN/DEBUG/;}
               0
               0  REPLACE {$TRACE#;} WITH
               0    {REPLACE {;{P1}={WAIT {ARB}};}  WITH
            {  0    {{EMIT;{P1}}={WAIT {P1}};
            {  0    IF QDEBUG [OUTPUT{P1};
            {  0    (' {P1} ASSIGNED {WAIT {P1}} ',G25.18);] }; }
               0  REPLACE {$S1TRACE#;} WITH
               0    {{SETR A=NEWLABEL}
            {  0      REPLACE {;{P1}({WAIT {ARB}})={WAIT {ARB}};}
            {  0         WITH {{EMIT ;{P1}({WAIT {P1}})}={WAIT {P2}};
            {  0             IF QDEBUG [I{COPY A}={WAIT {P1}};
            {  0                  OUTPUT I{COPY A},{P1}(I{COPY A});
            {  0                      (' {P1}(',I6,') ASSIGNED {WAIT {P2}} ' ,
            {  0                         G25.18);] } ;}
               0
               0  REPLACE {$TRACE#,#;} WITH {$TRACE{P1};$TRACE{P2};}
               0  REPLACE {$S1TRACE#,#;} WITH {$S1TRACE{P1};$S1TRACE{P2};}
               0
               0  SPECIFY DELIM AS ['('|';'];
               0  REPLACE {$CALLTRACE;} WITH
               0    {REPLACE {;CALL{NAME}{DELIM}} WITH
            {  0    {;IF (QDEBUG)[OUTPUT;
            {  0      (' SUBROUTINE {WAIT {P1}} CALLED.');]
            {  0           {WAIT {EMIT CALL} {P1}{P2}} };}
               0
               0  REPLACE {$DUMP#,#;} WITH
               0      {;{SETR A=NEWLABEL}
            {  0           V{COPY A}={P1};OUTPUT V{COPY A};(' {P1}=',1PG15.7);
            {  0           [IF] {EXIST 2} [$DUMP{P2};] ;}
               0     "NOTICE: THE LIST OF VARIABLES MUST BE FOLLOWED BY A COMMA"
               0     "FOR EXAMPLE $DUMP S,T(U,V),W,; OR $DUMP A,;"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MORTRAN MACRO DEFINITIONS FOR EGS."
               0
               0  "FIRST SOME PARAMETERS"
               0  REPLACE {PARAMETER #=#;} WITH
               0     { REPLACE {{P1}} WITH {{P2}}}
               0
               0  PARAMETER $MXMED=10;      "MAX. NO. OF DIFFERENT MEDIA (EXCL. VAC.)"
               0  PARAMETER $MXREG=2000;    "MAXIMUM NO. OF REGIONS ALLOCATED"
               0  PARAMETER $MXSTACK=40;    "STACK SIZE"
               0  PARAMETER $MXVRT1=1000;   "NO. OF REPRESENTATIVE ANGLES IN VERT1"
               0  PARAMETER $FMXVRT1=1000.; "FLOATING $MXVRT1"
               0  PARAMETER $MXPWR2I=50;    "SIZE OF TABLE OF INVERSE POWERS OF TWO"
               0  PARAMETER $MXJREFF=200;   "SIZE OF MULTIPLE SCATTERING JREFF MAP"
               0  PARAMETER $MSSTEPS=16;    "NO. OF MULTIPLE SCATTERING STEP SIZES"
               0  PARAMETER $MXVRT2=100;    "DISTRBTN OF NONOVERLAPPING PARTS OF VERT"
               0
               0  ;
               0  "FOLLOWING DEFINE MAX. NO. OF INTERVALS FOR FIT TO FUNCTIONS"
               0  PARAMETER $MXSGE=400;     "GAMMA SMALL ENERGY INTERVALS"
               0  PARAMETER $MXGE=2000;     "GAMMA MAPPED ENERGY INTERVALS"
               0  PARAMETER $MXSEKE=300;    "ELECTRON SMALL ENERGY INTERVALS"
               0  PARAMETER $MXEKE=500;     "ELECTRON MAPPED ENERGY INTERVALS"
               0  PARAMETER $MXEL=50;       "MAXIMUM # OF ELEMENTS IN A MEDIUM"
               0  PARAMETER $MXLEKE=100;    "ELECTRON ENERGY INTERVALS BELOW EKELIM"
               0  PARAMETER $MXCMFP=100;    "CUMULATIVE ELECTRON MEAN-FREE-PATH"
               0  PARAMETER $MXRANGE=100;   "ELECTRON RANGE"
               0  PARAMETER $MXBLC=20;      "MOLIERE'S LOWER CASE B"
               0  PARAMETER $MXRNTH=20;     "RANDOM NUMBER FOR SUBMEDIAN ANGLES"
               0  PARAMETER $MXRNTHI=20;    "RANDOM NUMBER FOR SUPERMEDIAN ANGLES"
               0  PARAMETER $MXRAYFF=100;   "RAYLEIGH ATOMIC FORM FACTOR"
               0  PARAMETER $RAYCDFSIZE=100;"CDF from RAYLEIGH FORM FACTOR SQUARED"
               0  PARAMETER $MXSINC=1002;   "ANGLE INTERVALS IN (0,5*PI/2) FOR SINE"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "THE FOLLOWING ARE PARAMETERS FOR AUSGAB CALLS:"
               0  PARAMETER $MXAUS=35;       "CHANGE IF MORE AUSGAB CALLS ARE ADDED"
               0  PARAMETER $MXAUSM5=30;     "SET THIS TO $MXAUS VALUE LESS 5"
               0
               0  "FIRST FIVE AUSGAB CALLS BELOW TURNED ON IN BLOCK DATA (DEFAULT)"
               0  PARAMETER $TRANAUSB=0;    "BEFORE TRANSPORT"
               0  PARAMETER $EGSCUTAUS=1;   "ENERGY BELOW ECUT OR PCUT"
               0  PARAMETER $PEGSCUTAUS=2;  "ENERGY BELOW AE OR AP"
               0  PARAMETER $USERDAUS=3;    "USER REQUESTED DISCARD"
               0  PARAMETER $PHOTXAUS=4;    "FLUORESCENT PHOTON DISCARD"
               0
               0  "THE REMAINING 23 ARE TURNED OFF IN BLOCK DATA (DEFAULT)"
               0  PARAMETER $TRANAUSA=5;    "AFTER TRANSPORT"
               0  PARAMETER $BREMAUSB=6;    "BEFORE BREMS CALL"
               0  PARAMETER $BREMAUSA=7;    "AFTER BREMS CALL"
               0  PARAMETER $MOLLAUSB=8;    "BEFORE MOLLER CALL"
               0  PARAMETER $MOLLAUSA=9;    "AFTER MOLLER CALL"
               0  PARAMETER $BHABAUSB=10;   "BEFORE BHABHA CALL"
               0  PARAMETER $BHABAUSA=11;   "AFTER BHABHA CALL"
               0  PARAMETER $ANNIHFAUSB=12; "BEFORE ANNIH CALL"
               0  PARAMETER $ANNIHFAUSA=13; "AFTER ANNIH CALL"
               0  PARAMETER $ANNIHRAUSB=28; "BEFORE POSITRON ANNIH AT REST"
               0  PARAMETER $ANNIHRAUSA=14; "POSITRON ANNIHILATED AT REST"
               0  PARAMETER $PAIRAUSB=15;   "BEFORE PAIR CALL"
               0  PARAMETER $PAIRAUSA=16;   "AFTER PAIR CALL"
               0  PARAMETER $COMPAUSB=17;   "BEFORE COMPT CALL"
               0  PARAMETER $COMPAUSA=18;   "AFTER COMPT CALL"
               0  PARAMETER $PHOTOAUSB=19;  "BEFORE PHOTO CALL"
               0  PARAMETER $PHOTOAUSA=20;  "AFTER PHOTO CALL"
               0  PARAMETER $UPHIAUSB=21;   "ENTERED UPHI"
               0  PARAMETER $UPHIAUSA=22;   "LEFT UPHI"
               0  PARAMETER $RAYLAUSB=23;   "BEFORE RAYLEIGH EVENT"
               0  PARAMETER $RAYLAUSA=24;   "AFTER RAYLEIGH EVENT"
               0  PARAMETER $FLUORTRA=25;   "A fluorescent transition just occurred"
               0  PARAMETER $COSKROTRA=26;  "A Coster-Kronig transition just occurred"
               0  PARAMETER $AUGERTRA=27;   "An Auger transition just occurred"
               0  "Ali:photonuc, 2 lines"
               0  " note that 28 is already used for positron annih at rest - see above"
               0  PARAMETER $PHOTONUCAUSB=29; "BEFORE PHOTONUCLEAR EVENT"
               0  PARAMETER $PHOTONUCAUSA=30; "AFTER PHOTONUCLEAR EVENT"
               0  PARAMETER $EIIB=31;   "Before EII"
               0  PARAMETER $EIIA=32;   "After EII"
               0  PARAMETER $SPHOTONA=33;   "After sub-threshold photon energy deposition"
               0  PARAMETER $SELECTRONA=34;   "After sub-threshold electron energy deposition"
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$AUSCALL(#);} WITH
               0     {IARG={P1} ;  IF (IAUSFL(IARG+1).NE.0) [CALL AUSGAB(IARG);]} ;
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  "TEMPORARY OVER-RIDES FOR SOME OF THE ABOVE"
               0  PARAMETER $MXSGE=1;
               0  PARAMETER $MXSEKE=1;
               0  PARAMETER $MXLEKE=1;
               0  PARAMETER $MXCMFP=1;
               0  PARAMETER $MXRANGE=1;
               0  PARAMETER $MXBLC=1;
               0  PARAMETER $MXRNTH=1;
               0  PARAMETER $MXRNTHI=1;
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "THE FOLLOWING DEFINE PRECISION USED IN ENERGY COMPUTATIONS"
               0  "THE LATTER OF THE TWO WILL BE IN EFFECT"
               0  REPLACE {$ENERGYPRECISION} WITH {;REAL }"SINGLE PRECISION"
               0  REPLACE {$ENERGYPRECISION} WITH {;DOUBLE PRECISION }
               0  REPLACE {$MAX_INT} WITH {2147483647} "2^31-1"
               0  "^--- limits number of particles and hence phase space file size"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACROS TO MAKE CHANGES IN THE DEGREE OF FIT EASIER"
               0  "ALSO USEFUL FOR ABBREVIATING LISTS OF SUBSCRIPTED VARIABLES"
               0  "$LGN STANDS FOR 'LIST GENERATOR'"
               0  "$RSC MEANS THAT THE EXPANDED LIST SHOULD RESCANNED FOR FURTHER"
               0  "OPERATIONS.  MACROS EXPECTING TO DO RESCANS SHOULD BE"
               0  "DEFINED AFTER THE FOLLOWING MACRO"
               0  REPLACE {$RSC(#)} WITH {{P1}}
               0  "IF NOT MATCHED BY ANYTHING ELSE, REMOVE $RSC()"
               0  REPLACE {$RSC(#),#$LSCALEBY#;} WITH
               0     {{P1}={P1}*{P3};{P2}$LSCALEBY{P3};}
               0  REPLACE {$RSC(#)$LSCALEBY#;} WITH {{P1}={P1}*{P2};}
               0  REPLACE {$LGN(#/#/)} WITH {$RSC({P1}{P2})}
               0  REPLACE {$LGN(#(#)/#/)} WITH {$RSC({P1}{P3}({P2}))}
               0  REPLACE {$LGN(#(#))} WITH {$RSC({P1}({P2}))}
               0  REPLACE {$LGN(#/#,#/)} WITH
               0      {$LGN({P1}/{P2}/),$LGN({P1}/{P3}/)}
               0  REPLACE {$LGN(#,#/#/)} WITH
               0      {$LGN({P1}/{P3}/),$LGN({P2}/{P3}/)}
               0  REPLACE {$LGN(#(#)/#,#/)} WITH
               0      {$LGN({P1}({P2})/{P3}/),$LGN({P1}({P2})/{P4}/)}
               0  REPLACE {$LGN(#,#(#)#)} WITH
               0      {$LGN({P1}({P3}){P4}),$LGN({P2}({P3}){P4})}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACROS FOR SCALING REQUIRED BY CHANGE IN DISTANCE UNIT"
               0  REPLACE {$SCALE# BY #;} WITH {{P1}={P1}*{P2};}
               0  REPLACE {$SCALE#,# BY #;} WITH
               0      {{P1}={P1}*{P3};$SCALE{P2} BY {P3};}
               0  REPLACE {$SCALE$LGN(#) BY #;} WITH
               0      {$LGN({P1})$LSCALE BY {P2};}
               0  REPLACE {$SCALE$LGN(#),# BY #;} WITH
               0              {$LGN({P1})$LSCALE BY {P3};$SCALE{P2} BY {P3};}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------
               0  " Macros related to bit setting
               0  "------------------------------------------------------------------
               0  ""
               0  "Macro to set bit {P2} in {P1}  to 1
               0  REPLACE {$IBSET(#,#);} WITH {ibset({P1},{P2});}
               0
               0  "Macro to set test bit {P2} in {P1}
               0  "Note this may require a LOGICAL declaration wherever used
               0  REPLACE {$BTEST(#,#)} WITH {btest({P1}, {P2})}
               0
               0  "Macro to set bit {P2} in {P1}  to 0
               0  REPLACE {$IBCLR(#,#);} WITH {ibclr({P1},{P2});}
               0  "Above used by RW_PH_SP routine - (read_write_phase_space for BEAM)
               0
               0
               0  "COMMON BLOCK INSERTION MACROS"
               0  REPLACE {;COMIN/#,#/;} WITH {;COMIN/{P1}/;COMIN/{P2}/;}
               0
               0  "NOW FOR SOME SPECIFIC COMMON BLOCKS"
               0
               0  "------------------------------------------------------------------"
               0  "*** BOUNDS--CUTOFF ENERGIES & VACUUM TRANSPORT DISTANCE           "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/BOUNDS/;} WITH
               0  {
            {  0      ;COMMON/BOUNDS/ECUT($MXREG),PCUT($MXREG),VACDST;
            {  0       $REAL         ECUT,   "Minimum electron transport energy"
            {  0                     PCUT,   "Minimum photon transport energy"
            {  0                     VACDST; "Infinity (1E8)"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** BREMPR--BREMSSTRAHLUNG AND PAIR PRODUCTION DATA               "
               0  "------------------------------------------------------------------"
               0
               0  ;
               0  REPLACE {$MXBREN} WITH {57}
               0  REPLACE {$MXBRXX} WITH {54}
               0  REPLACE {$MXBREL} WITH {100}
               0  REPLACE {$MXGAUSS} WITH {64}
               0  REPLACE {$MXBRES} WITH {100}
               0  REPLACE {$MXBRXS} WITH {50}
               0  REPLACE {$NIST-ENERGY-SCALE} WITH {1.0}
               0
               0  REPLACE {$NIST-DATA-UNIT} WITH {i_nist_data}
               0  ;
               0
               0  REPLACE {$COMIN-INIT-NIST-BREMS;} WITH {;
            {  0      ;COMIN/MEDIA,BREMPR,ELECIN,THRESH,USEFUL,NIST-BREMS,Spin-Data,EGS-IO/;
            {  0  };
               0
               0  REPLACE {;COMIN/BREMPR/;} WITH
               0  {
            {  0    ;COMMON/BREMPR/
            {  0               $LGN(DL(8,$MXMED)/1,2,3,4,5,6/),
            {  0               $LGN(ALPHI,BPAR,DELPOS(2,$MXMED)),
            {  0               $LGN(WA,PZ,ZELEM,RHOZ($MXMED,$MXEL)),
            {  0               PWR2I($MXPWR2I),
            {  0               $LGN(DELCM,ZBRANG,LZBRANG,NNE($MXMED)),
            {  0               IBRDST,IPRDST,ibr_nist,pair_nrc,itriplet,
            {  0               ASYM($MXMED,$MXEL,2);
            {  0     $TYPE     ASYM;
            {  0     $REAL     $LGN(DL/1,2,3,4,5,6/), "Parameter for the fit of the screening"
            {  0                                      "rejection function, eq. (2.7.14 and 15)"
            {  0               ALPHI,  "Prob. for the (1-BR)/BR part in BREMS, eq. (2.7.64)"
            {  0               BPAR,   "Prob. for the 12*(BR-1/2)**2 part in PAIR, eq. (2.7.105)"
            {  0               DELPOS, "maximum delta, eq. (2.7.31)"
            {  0               WA,     "atomic weight"
            {  0               PZ,     "atomic fraction of an element in a compound"
            {  0               ZELEM,  "Z for a given component"
            {  0               RHOZ,   "density of an element in a compound"
            {  0               PWR2I,  "powers of 1/2 (used for sampling (1-BR)/BR"
            {  0               DELCM,  "136*m*exp(Zg), eq. (2.7.51)"
            {  0               ZBRANG, "composite factor for angular distributions"
            {  0               LZBRANG;"-Log(ZBRANG)"
            {  0     $INTEGER  NNE,    "number of elements/compound"
            {  0               IBRDST, "flag to switch on bremsstrahlung angular distributions"
            {  0               IPRDST, "flag to switch on pair angular distributions"
            {  0               ibr_nist,  "use the NIST bremsstrahlung cross sections"
            {  0               itriplet,  "if set to 1, explicitely simulate triplet events"
            {  0               pair_nrc;  "=0 => use Bethe-Heitler pair cross sections"
            {  0                          "=1 => use the NRC pair cross sections"
            {  0  };
               0
               0  REPLACE {;COMIN/NIST-BREMS/;} WITH {;
            {  0
            {  0    common/nist_brems/ nb_fdata(0:$MXBRXS,$MXBRES,$MXMED),
            {  0                       nb_xdata(0:$MXBRXS,$MXBRES,$MXMED),
            {  0                       nb_wdata($MXBRXS,$MXBRES,$MXMED),
            {  0                       nb_idata($MXBRXS,$MXBRES,$MXMED),
            {  0                       nb_emin($MXMED),nb_emax($MXMED),
            {  0                       nb_lemin($MXMED),nb_lemax($MXMED),
            {  0                       nb_dle($MXMED),nb_dlei($MXMED),
            {  0                       log_ap($MXMED);
            {  0    $REAL    nb_fdata,nb_xdata,nb_wdata,nb_emin,nb_emax,nb_lemin,nb_lemax,
            {  0             nb_dle,nb_dlei,log_ap;
            {  0    $INTEGER nb_idata;
            {  0  };
               0
               0  REPLACE {$NRC-PAIR-NXX} WITH {65};
               0  REPLACE {$NRC-PAIR-NEE} WITH {84};
               0  REPLACE {$NRC-PAIR-NX-1} WITH {64};
               0  REPLACE {$NRC-PAIR-NE-1} WITH {83};
               0
               0  REPLACE {;COMIN/NRC-PAIR-DATA/;} WITH {;
            {  0      common/nrc_pair/ nrcp_fdata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
            {  0                       nrcp_wdata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
            {  0                       nrcp_idata($NRC-PAIR-NXX,$NRC-PAIR-NEE,$MXMED),
            {  0                       nrcp_xdata($NRC-PAIR-NXX),
            {  0                       nrcp_emin, nrcp_emax, nrcp_dle, nrcp_dlei;
            {  0      $REAL            nrcp_fdata,nrcp_wdata,nrcp_xdata,
            {  0                       nrcp_emin, nrcp_emax, nrcp_dle, nrcp_dlei;
            {  0      $INTEGER         nrcp_idata;
            {  0  };
               0
               0  "------------------------------------------------------------------------"
               0  "*** TRIPLET DATA                                                        "
               0  "------------------------------------------------------------------------"
               0  REPLACE {$MAX_TRIPLET} WITH {250}
               0  REPLACE {;COMIN/TRIPLET-DATA/;} WITH {;
            {  0          common/triplet_data/ a_triplet($MAX_TRIPLET,$MXMED),
            {  0                               b_triplet($MAX_TRIPLET,$MXMED),
            {  0                               dl_triplet, dli_triplet, bli_triplet, log_4rm;
            {  0          $REAL                a_triplet,b_triplet,dl_triplet, dli_triplet,
            {  0                               bli_triplet, log_4rm;
            {  0  };
               0
               0  "------------------------------------------------------------------------"
               0  "*** COMPTON-DATA -- Incoherent scattering data                          "
               0  "------------------------------------------------------------------------"
               0  REPLACE {$MXTOTSH}   WITH {1538} "Total number of shells for Z=1..100    "
               0  REPLACE {$MXMDSH}    WITH {200}   "Max. number of shells per medium       "
               0  REPLACE {$INCOHUNIT} WITH {i_incoh}   "Unit number for compton data           "
               0
               0  REPLACE {;COMIN/COMPTON-DATA/;} WITH
               0  {
            {  0    ;common/compton_data/ iz_array($MXTOTSH), "Atomic number for each shell"
            {  0                          be_array($MXTOTSH), "Shell binding energies      "
            {  0                          Jo_array($MXTOTSH), "Compton profile parameter   "
            {  0                          erfJo_array($MXTOTSH),"needed for the calculation"
            {  0                                              "of the incoherent scattering"
            {  0                                              "function                    "
            {  0                          ne_array($MXTOTSH), "Occupation number           "
            {  0                          shn_array($MXTOTSH),"shell type                  "
            {  0                                              "(=1     for K,              "
            {  0                                              " =2,3,4 for L1,L2,L3        "
            {  0                                              " =5     for M               "
            {  0                                              " =6     for N               "
            {  0                                              " =7     for all others      "
            {  0                          shell_array($MXMDSH,$MXMED),
            {  0                          eno_array($MXMDSH,$MXMED),
            {  0                          eno_atbin_array($MXMDSH,$MXMED),
            {  0                          n_shell($MXMED),
            {  0                          radc_flag,          "flag for radiative corrections"
            {  0                          ibcmp($MXREG);      "flag to turn on binding effects"
            {  0     $INTEGER             iz_array,ne_array,shn_array,eno_atbin_array,
            {  0                          shell_array,n_shell,radc_flag;
            {  0     $REAL                be_array,Jo_array,erfJo_array,eno_array;
            {  0     $SHORT_INT           ibcmp;
            {  0  }
               0
               0
               0  "------------------------------------------------------------------ "
               0  "*** EDGE -- Containes binding energies for K,L1,L2,L3,             "
               0  "             'average' M and 'average' N shells; photo-absorption  "
               0  "             interaction probabilities with these shells;          "
               0  "             + fluorescence, Auger, Coster-Kronig transition       "
               0  "             probabilities                                         "
               0  "             IEDGFL is a flag for turning on/off atomic relaxations"
               0  "             IPHTER is a flag for turning on/off photo-lectron     "
               0  "                    angular distribution                           "
               0  "             both are left-overs from the previous coding          "
               0  "             Have put now also data to calculate elemental PE      "
               0  "             cross sections needed to sample the element the photon"
               0  "             is interacting with.
               0  "------------------------------------------------------------------ "
               0  REPLACE {$MXELEMENT} WITH {100}  " Number of elements               "
               0  REPLACE {$MXSHXSEC}  WITH {30}   " Number of shells available       "
               0  REPLACE {$MXSHELL}   WITH {6}    " Number of shells treated         "
               0  REPLACE {$MXINTER}   WITH {5}    " $MXSHELL-1                       "
               0  REPLACE {$MXTRANS}   WITH {39}   " Number of possible transitions   "
               0  REPLACE {$MXEDGE}    WITH {16}   " max. number of edges above 1 keV "
               0  REPLACE {$PHOTOUNIT} WITH {i_photo_relax} " unit number for photo_relax.data "
               0  REPLACE {$PHOCSUNIT} WITH {i_photo_cs}   " unit number for photo_cs.data    "
               0
               0  REPLACE {;COMIN/EDGE/;} WITH
               0  {;
            {  0     COMMON/EDGE/binding_energies($MXSHXSEC,$MXELEMENT),
            {  0                 interaction_prob($MXSHELL,$MXELEMENT),
            {  0                 relaxation_prob($MXTRANS,$MXELEMENT),
            {  0                 edge_energies($MXEDGE,$MXELEMENT),
            {  0                 edge_number($MXELEMENT),
            {  0                 edge_a($MXEDGE,$MXELEMENT),
            {  0                 edge_b($MXEDGE,$MXELEMENT),
            {  0                 edge_c($MXEDGE,$MXELEMENT),
            {  0                 edge_d($MXEDGE,$MXELEMENT),
            {  0                 IEDGFL($MXREG),IPHTER($MXREG);
            {  0     $REAL       binding_energies, " K,L1,L2,L3,M,N binding energies  "
            {  0                 interaction_prob, " prob. for interaction with one of"
            {  0                                   " the above shells (provided photon"
            {  0                                   " energy is above be)              "
            {  0                 relaxation_prob,  " relaxation probabilities         "
            {  0                 edge_energies,    " photo-absorption edge energies   "
            {  0                 edge_a,edge_b,edge_c,edge_d;
            {  0                                   " photo cross section fit parameters "
            {  0     $SHORT_INT  IEDGFL,  "flag for switching on fluorscent emission"
            {  0                 IPHTER;  "flag for switching on photo-electron angular distr."
            {  0     $INTEGER    edge_number; " number of `edges' for each element"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** ELECIN--ELECTRON TRANSPORT INPUT                              "
               0  "        MODIFIED 1989/12/19 TO INCLUDE IUNRST,EPSTFL AND IAPRIM   "
               0  "        NRC DWOR                                                  "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/ELECIN/;} WITH
               0  {;
            {  0     COMMON/ELECIN/
            {  0     esig_e($MXMED),psig_e($MXMED),
            {  0     esige_max, psige_max,
            {  0     range_ep(0:1,$MXEKE,$MXMED),
            {  0     E_array($MXEKE,$MXMED),
            {  0     $LGN(etae_ms,etap_ms,q1ce_ms,q1cp_ms,q2ce_ms,q2cp_ms,
            {  0          blcce($MXEKE,$MXMED)/0,1/),
            {  0     $LGN(EKE($MXMED)/0,1/),
            {  0     $LGN(XR0,TEFF0,BLCC,XCC($MXMED)),
            {  0     $LGN(ESIG,PSIG,EDEDX,PDEDX,EBR1,PBR1,PBR2,TMXS($MXEKE,$MXMED)/0,1/),
            {  0     expeke1($MXMED),
            {  0     IUNRST($MXMED),EPSTFL($MXMED),IAPRIM($MXMED),
            {  0     sig_ismonotone(0:1,$MXMED);
            {  0     $REAL    esig_e,        "maximum electron cross section per energy loss"
            {  0                             "for each medium"
            {  0              psig_e,        "maximum positron cross section per energy loss"
            {  0                             "for each medium"
            {  0              esige_max,     "maximum electron cross section per energy loss"
            {  0              psige_max,     "maximum electron cross section per energy loss"
            {  0              range_ep,      "electron (0) or positron (1) range"
            {  0              E_array,       "table energies"
            {  0              etae_ms0,etae_ms1,
            {  0                             "for interpolation of screening parameter (e-)"
            {  0              etap_ms0,etap_ms1,
            {  0                             "for interpolation of screening parameter (e+)"
            {  0              q1ce_ms0,q1ce_ms1,
            {  0                            "for interpolation of q1 correction due to spin (e-)"
            {  0              q1cp_ms0,q1cp_ms1,
            {  0                            "for interpolation of q1 correction due to spin (e+)"
            {  0              q2ce_ms0,q2ce_ms1,
            {  0                            "for interpolation of q2 correction due to spin (e-)"
            {  0              q2cp_ms0,q2cp_ms1,
            {  0                            "for interpolation of q2 correction due to spin (e+)"
            {  0              blcce0,blcce1,"for interpolation of scattering power correction   "
            {  0                            "necessary to account for scattering already taken  "
            {  0                            "into account in discrete Moller/Bhabha             "
            {  0              expeke1,       "Exp(1/eke1)-1"
            {  0              $LGN(EKE/0,1/),"table for kinetic energy indexing"
            {  0              XR0,           "unused, but read in HATCH"
            {  0              TEFF0,         "unused, but read in HATCH"
            {  0              BLCC,          "b lower case sub c"
            {  0              XCC,           "chi sub-c-c"
            {  0              ESIG0,ESIG1,   "used for electron cross section interpolation"
            {  0              PSIG0,PSIG1,   "used for positron cross section interpolation"
            {  0              EDEDX0,EDEDX1, "used for electron dE/dx interpolation"
            {  0              PDEDX0,PDEDX1, "used for positron dE/dx interpolation"
            {  0              EBR10,EBR11,   "used for e- branching into brems interpolation"
            {  0              PBR10,PBR11,   "used for e+ branching into brems interpolation"
            {  0              PBR20,PBR21,   "used for e+ branching into Bhabha interpolation"
            {  0              TMXS0,TMXS1;   "used for maximum step-size interpolation"
            {  0     $INTEGER IUNRST,        "flag for type of stopping power (see PEGS4)"
            {  0              EPSTFL,        "flag for ICRU37 collision stopping powers"
            {  0              IAPRIM;        "flag for ICRU37 radiative stopping powers"
            {  0     $LOGICAL sig_ismonotone;"true, if cross section is an increasing function"
            {  0                             "of energy, false otherwise"
            {  0  }
               0
               0  "***************************************************************************"
               0  "                                                                           "
               0  " ------------ common block for EII data -----------------                  "
               0  "
               0  " Added by Iwan Kawrakow, March 20 2004.
               0  "                                                                           "
               0  "****************************************************************************
               0
               0  REPLACE {$MAX_EII_SHELLS} WITH {40};  "Maximum number of shells participating"
               0                                        "in EII in a simulation                "
               0  REPLACE {$N_EII_BINS} WITH {250};     "Number of bins for EII x-section      "
               0                                        "interpolations                        "
               0  REPLACE {$MAX_EII_BINS} WITH {{COMPUTE $N_EII_BINS*$MAX_EII_SHELLS}};
               0  "We store the EII x-section interpolation coefficients in 1D arrays  "
               0  "The above is the dimension of these arrays required to hold the data"
               0  REPLACE {;COMIN/EII-DATA/;} WITH {;
            {  0      common/eii_data/
            {  0          eii_xsection_a($MAX_EII_BINS), "EII x-section interpolation coeff."
            {  0          eii_xsection_b($MAX_EII_BINS), "EII x-section interpolation coeff."
            {  0          eii_cons($MXMED),
            {  0          eii_a($MAX_EII_SHELLS),        "energy grid coeff. for each shell "
            {  0          eii_b($MAX_EII_SHELLS),        "energy grid coeff. for each shell "
            {  0          eii_L_factor,                  "L-shell EII xsection scaling factor"
            {  0          eii_z($MAX_EII_SHELLS),        "Z of each shell                   "
            {  0          eii_sh($MAX_EII_SHELLS),       "shell type (1=K, 2=LI, eyc.)      "
            {  0          eii_nshells($MXELEMENT),       "No. of EII shells for each element"
            {  0          eii_nsh($MXMED),               "No. of EII shells for each medium "
            {  0          eii_first($MXMED,$MXEL),       "First EII shell in the list of shells"
            {  0          eii_no($MXMED,$MXEL),          "N. of EII shells                  "
            {  0          eii_flag;                      "EII flag                          "
            {  0                                         "         = 0 => no EII            "
            {  0                                         "         = 1 => simple EII        "
            {  0                                         "         > 1 => future use        "
            {  0      $REAL     eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_factor;
            {  0      $INTEGER  eii_z,eii_sh,eii_nshells;
            {  0      $INTEGER  eii_first,eii_no;
            {  0      $INTEGER  eii_elements,eii_flag,eii_nsh;
            {  0  };
               0
               0  REPLACE {$COMIN-EII-SAMPLE;} WITH {
            {  0      ;COMIN/EPCONT,EII-DATA,EGS-VARIANCE-REDUCTION,RANDOM,STACK,THRESH,
            {  0             UPHIOT,USEFUL,EGS-IO,RELAX-DATA/;
            {  0  };
               0  REPLACE {$COMIN-EII-INIT;} WITH {
            {  0      ;COMIN/BREMPR,EDGE,EGS-IO,EII-DATA,ELECIN,MEDIA,THRESH,USEFUL/;
            {  0  };
               0
               0  REPLACE {;COMIN/EMF-INPUTS/;} WITH {;
            {  0      common/emf_inputs/ExIN,EyIN,EzIN, "E field"
            {  0                       EMLMTIN,         "Ekin, u, E fractional maximum change"
            {  0                       BxIN, ByIN, BzIN,       "B field: initial region"
            {  0                       Bx, By, Bz,             "B field: current region"
            {  0                       Bx_new, By_new, Bz_new; "B field: in new region"
            {  0
            {  0     $REAL    ExIN,EyIN,EzIN,
            {  0              EMLMTIN,
            {  0              BxIN,ByIN,BzIN,
            {  0              Bx,By,Bz,
            {  0              Bx_new,By_new,Bz_new;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  " The following common block is made available to the user so that  "
               0  " he/she knows which shell was being relaxed when the call to ausgab"
               0  " occured                                                           "
               0  " Added by Iwan Kawrakow, March 22 2004.                            "
               0
               0  REPLACE {;COMIN/RELAX-USER/;} WITH {;
            {  0     common/user_relax/ u_relax,ish_relax,iZ_relax;
            {  0     $REAL              u_relax;
            {  0     $INTEGER           ish_relax, iZ_relax;
            {  0  };
               0
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  "***************************************************************************"
               0  "                                                                           "
               0  " ------------ common blocks for EADL relaxation data -----------------     "
               0  "
               0  " Added by Ernesto Mainegra, June 1st 2011.                                 "
               0  "                                                                           "
               0  "***************************************************************************"
               0  "shell in one long list, avoiding repetition (i.e. if an element is present"
               0  "in different materials, its shell structure and information will be stored"
               0  "only once in the list). The array shell_eadl(Z,i) tells us the position of"
               0  "the i'th shell of element Z in the long shell list.                       "
               0  "***************************************************************************"
               0
               0  REPLACE {$MXESHLL} WITH {30}  "max. number of shells for an element"
               0  REPLACE {$MAXSHELL} WITH {3000}"max. number of shells"
               0  REPLACE {$MAXRELAX} WITH {10000}"max. number of relaxations channels"
               0  REPLACE {$MAXVAC} WITH {100}   "max. number of vacancies"
               0  "============================================================"
               0  " Set input key 'Atomic relaxations' to 'simple' to recover original
               0  " implementation which allows photoelectric interactions with <M> and
               0  " <N> shells. See below for details on the shells considered by different
               0  " interactions depending on the value of eadl_relax:
               0  "
               0  "      Interaction        .false.             .true.
               0  "      -----------------------------------------
               0  "      Compton                all available shells
               0  "      EII                K,L1..L3            K,L1..L3
               0  "      Photoeffect        K,L1..L3,<M>,<N>    K,L1..L3
               0  "      Shellwise
               0  "      Photoeffect             N/A      All shells > $RELAX-CUTOFF
               0  "      Relaxation
               0  "        initial vacancy  K,L1..L3,<M>        K,L1..L3
               0  "        (for new photoeffect)                K, L1..L3, M1..M5, N1..N4
               0  "        final vacancy    L1..L3,<M>,<N>      L1..L3,M1..M5,N1..N7...
               0  "
               0  "============================================================"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {;COMIN/SHELL-DATA/;} WITH {;
            {  0
            {  0    common/shell_data/
            {  0      shell_be($MAXSHELL),      "binding energies"
            {  0      shell_type($MAXSHELL),    "shell type according to EADL notation"
            {  0      shell_num($MAXSHELL),     "the shell position in the element"
            {  0      shell_Z($MAXSHELL),       "Z of the element the shell belongs to"
            {  0      shell_eadl($MXELEMENT,$MXESHLL), "global index for a shell of element Z"
            {  0      shell_ntot;               "total number of shells in the list"
            {  0    $REAL    shell_be;
            {  0    $INTEGER shell_type,shell_Z,shell_ntot,shell_num,shell_eadl;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {;COMIN/RELAX-DATA/;} WITH {;
            {  0
            {  0    common/relax_data/
            {  0      relax_first($MAXSHELL),    "first transition"
            {  0      relax_ntran($MAXSHELL),    "number of transitions"
            {  0      relax_state($MAXRELAX),    "final state of the transition"
            {  0      relax_prob($MAXRELAX),     "probability"
            {  0      relax_atbin($MAXRELAX),    "used for alias sampling"
            {  0      relax_ntot;                "total number of transitions in the list"
            {  0    $REAL     relax_prob;
            {  0    $INTEGER  relax_first, relax_ntran, relax_state, relax_atbin, relax_ntot;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {;COMIN/RELAX-FOR-USER/;} WITH {;
            {  0      common/relax_for_user/
            {  0       rfu_E0, "binding energy of vacancy that initiated cascade"
            {  0       rfu_E,  "binding energy of current vacancy"
            {  0       rfu_Z,  "Atomic number of the element the relaxing shell belongs to"
            {  0       rfu_j0, "shell numb. of vacancy that initiated cascade in the list"
            {  0       rfu_n0, "same but number is shell number in the element"
            {  0       rfu_t0, "same but number is shell type according to EADL notation"
            {  0       rfu_j,  "shell number of current vacancy"
            {  0       rfu_n,  "same but number is shell number in the element"
            {  0       rfu_t;  "same but number is shell type according to EADL notation"
            {  0      $INTEGER rfu_Z,rfu_j0,rfu_n0,rfu_t0,rfu_j,rfu_n,rfu_t;
            {  0      $REAL    rfu_E0,rfu_E;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$COMIN-RELAX-INIT;} WITH {
            {  0  ;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,X-OPTIONS,USEFUL,
            {  0  RELAX-DATA,SHELL-DATA/;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$COMIN-RELAX-EADL;} WITH {
            {  0  ;COMIN/RELAX-DATA,RELAX-FOR-USER,SHELL-DATA,
            {  0  STACK,THRESH,EPCONT,USEFUL,UPHIOT,RANDOM,BOUNDS,EGS-IO,MISC,MEDIA,
            {  0  X-OPTIONS/;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "***************************************************************************"
               0  "                                                                           "
               0  " -------------- shell-wise photoelectric cross section data ------------   "
               0  "
               0  " Cross sections taken from Sabbatucci and Salvat,                          "
               0  " Theory and calculation of the atomic photoeffect                          "
               0  " Radiat. Phys. and Chem., Volume 121, April 2016, Pages 122-140            "
               0  "                                                                           "
               0  "***************************************************************************"
               0  " Shell-wise photoelectric cross sections from 50 eV up to 1 GeV for elements
               0  " from Z=1 up to Z=99. All K, L, M, and N shells are included. One can define
               0  " a threshold energy separating inner from outer shells. By default this
               0  " energy is set to 1 keV, but for accurate calculation of quantities that  "
               0  " require knowledge of which particle deposited the energy, one might need to
               0  " use the a lower threshold.
               0  "***************************************************************************"
               0  "============================================================"
               0  REPLACE {$RELAX-CUTOFF} WITH {0.001"threshold energy for outer shells"}
               0  REPLACE {$MXPESHELL} WITH {16} "K,L1..L3,M1..M5,N1..N7 + outer shell"
               0  REPLACE {$MXNE} WITH {500}     "number of energy points per shell "
               0  "============================================================"
               0  REPLACE {;COMIN/PE-SHELL-DATA/;} WITH {;
            {  0
            {  0    common/pe_shell_data/
            {  0      pe_xsection($MXNE,$MXELEMENT,0:$MXPESHELL),  "shellwise cross sections"
            {  0      pe_elem_prob($MXNE,$MXELEMENT,$MXMED), "prob. of interaction with an"
            {  0                                             "element of a medium"
            {  0      pe_energy($MXNE,$MXELEMENT),    "energy grid"
            {  0      pe_zsorted($MXELEMENT,$MXMED),"sorted array of Z for each medium"
            {  0      pe_be($MXELEMENT,$MXPESHELL),      "binding energies"
            {  0      pe_nshell($MXELEMENT),       "number of shells for each element"
            {  0      pe_zpos($MXELEMENT),       "position of each Z element"
            {  0      pe_nge($MXELEMENT),       "number of energy points for each element"
            {  0      pe_ne;                    "number of elements in the simulation"
            {  0    $REAL    pe_be, pe_energy, pe_xsection, pe_elem_prob;
            {  0    $INTEGER pe_zsorted, pe_nshell, pe_zpos, pe_nge, pe_ne;
            {  0  };
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$COMIN-SHELLWISE-PE-INIT;} WITH {
            {  0  ;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,X-OPTIONS,USEFUL,
            {  0      PE-SHELL-DATA/;
            {  0  };
               0
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  " Some macros for C-style syntax in mortran "
               0  " Unfortunately, /= doesn't work because of /v1,v2,...,vn/=value;"
               0
               0  REPLACE {;#+=#;} WITH { ;{P1} = {P1} + {P2}; }
               0  REPLACE {[#+=#;} WITH { {P1} = {P1} + {P2}; }
               0
               0  REPLACE {;#-=#;} WITH { ;{P1} = {P1} - {P2}; }
               0  REPLACE {[#-=#;} WITH { {P1} = {P1} - {P2}; }
               0
               0  REPLACE {;#*=#;} WITH { ;{P1} = {P1}*{P2}; }
               0  REPLACE {[#*=#;} WITH { {P1} = {P1}*{P2}; }
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0  "***************************************************************************"
               0
               0  REPLACE {;COMIN/ET-Control/;} WITH  "ET stands for Electron Transport"
               0  {
            {  0    ;common/ET_control/
            {  0                smaxir($MXREG),estepe,ximax,
            {  0                "ximin_for_bca,"
            {  0                skindepth_for_bca,transport_algorithm,
            {  0                bca_algorithm,exact_bca,spin_effects;
            {  0      $REAL     smaxir,             "geom. step-size constrain for each region"
            {  0                estepe,             "global energy loss constrain"
            {  0                ximax,              "max. first GS moment per step"
            {  0                                    "(roughly half the average MS angle squared"
            {  0                "ximin_for_bca,"
            {  0                                    "min. first GS moment per step for boundary"
            {  0                                    "crossing in VMC mode"
            {  0                skindepth_for_bca;  "distance from a boundary (in elastic MFP)"
            {  0                                    "to switch to one of the BCAs "
            {  0      $INTEGER  transport_algorithm,"=$PRESTA-II or $PRESTA--I"
            {  0                bca_algorithm;      "will be used if other inexact BCAs"
            {  0                                    "implemented in the future"
            {  0      $LOGICAL  exact_bca,          "if .true. => BCA in single scattering mode"
            {  0                spin_effects;       "if .true. electron/positron spin effects"
            {  0                                    "are taken into account in the single and"
            {  0                                    "multiple elasting scattering routines"
            {  0  }
               0  ;
               0
               0  " ======================== multiple scattering commons ================= "
               0
               0  " Screened Rutherford MS data "
               0
               0  REPLACE {$MAXL_MS}    WITH {63}
               0  REPLACE {$MAXQ_MS}    WITH {7}
               0  REPLACE {$MAXU_MS}    WITH {31}
               0  REPLACE {$0-MAXL_MS}  WITH {0:63}
               0  REPLACE {$0-MAXQ_MS}  WITH {0:7}
               0  REPLACE {$0-MAXU_MS}  WITH {0:31}
               0  REPLACE {$LAMBMIN_MS} WITH {1.}
               0  REPLACE {$LAMBMAX_MS} WITH {1e5}
               0  REPLACE {$QMIN_MS}    WITH {1e-3}
               0  REPLACE {$QMAX_MS}    WITH {0.5}
               0
               0  REPLACE {COMIN/MS-Data/;} WITH {
            {  0    common/ms_data/
            {  0                ums_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
            {  0                fms_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
            {  0                wms_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
            {  0                ims_array($0-MAXL_MS,$0-MAXQ_MS,$0-MAXU_MS),
            {  0                llammin,llammax,dllamb,dllambi,dqms,dqmsi;
            {  0    real*4      ums_array,fms_array,wms_array,
            {  0                llammin,llammax,dllamb,dllambi,dqms,dqmsi;
            {  0    $SHORT_INT  ims_array;
            {  0  }
               0  ;
               0
               0  " spin effect data used in an additional rejection loop "
               0
               0  REPLACE {$MAXE_SPIN}   WITH {15}
               0  REPLACE {$MAXE_SPI1}   WITH {{COMPUTE 2*$MAXE_SPIN+1}}
               0  REPLACE {$MAXQ_SPIN}   WITH {15}
               0  REPLACE {$MAXU_SPIN}   WITH {31}
               0  REPLACE {$0-MAXE_SPI1} WITH {0:$MAXE_SPI1}
               0  REPLACE {$0-MAXQ_SPIN} WITH {0:$MAXQ_SPIN}
               0  REPLACE {$0-MAXU_SPIN} WITH {0:$MAXU_SPIN}
               0
               0  REPLACE {COMIN/Spin-Data/;} WITH {
            {  0    common/spin_data/
            {  0                spin_rej($MXMED,0:1,$0-MAXE_SPI1,$0-MAXQ_SPIN,$0-MAXU_SPIN),
            {  0                espin_min,espin_max,espml,b2spin_min,b2spin_max,
            {  0                dbeta2,dbeta2i,dlener,dleneri,dqq1,dqq1i,
            {  0                fool_intel_optimizer;
            {  0    real*4      spin_rej,espin_min,espin_max,espml,b2spin_min,b2spin_max,
            {  0                dbeta2,dbeta2i,dlener,dleneri,dqq1,dqq1i;
            {  0    $LOGICAL    fool_intel_optimizer;
            {  0  }
               0  ;
               0
               0  REPLACE {COMIN/CH-Steps/;} WITH
               0  {
            {  0    common/CH_steps/ count_pII_steps,count_all_steps,is_ch_step;
            {  0    real*8           count_pII_steps,count_all_steps;
            {  0    $LOGICAL         is_ch_step;
            {  0  }
               0  ;
               0  "------------------------------------------------------------------"
               0  "*** EPCONT--ELECTRON-PHOTON CONTROL VARIABLES                     "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/EPCONT/;} WITH
               0  {;
            {  0    COMMON/EPCONT/EDEP,EDEP_LOCAL,TSTEP,TUSTEP,USTEP,TVSTEP,VSTEP,
            {  0                  RHOF,EOLD,ENEW,EKE,ELKE,GLE,E_RANGE,
            {  0                  x_final,y_final,z_final,
            {  0                  u_final,v_final,w_final,
            {  0                  IDISC,IROLD,IRNEW,IAUSFL($MXAUS);
            {  0      $ENERGY PRECISION EDEP,   "energy deposition in MeV"
            {  0                        EDEP_LOCAL; "local energy deposition in MeV"
            {  0      $REAL             TSTEP,  "distance to a discrete interaction"
            {  0                        TUSTEP, "intended step length, befor check with geometry"
            {  0                        USTEP,  "transport distance calculated from TUSTEP"
            {  0                        VSTEP,  "transport distance after truncation by HOWFAR"
            {  0                        TVSTEP, "curved path-length calculated from TVSTEP"
            {  0                        RHOF,   "mass density ratio"
            {  0                        EOLD,   "energy before deduction of energy loss"
            {  0                        ENEW,   "energy after  deduction of energy loss"
            {  0                        EKE,    "kinetic energy"
            {  0                        ELKE,   "Log(EKE)"
            {  0                        GLE,    "Log(energy) in PHOTON"
            {  0                        E_RANGE,"range of electron before an iarg=0 ausgab call"
            {  0                        x_final,y_final,z_final, "position at end of step"
            {  0                        u_final,v_final,w_final; "direction at end of step"
            {  0                                                 "only set (and relevant) "
            {  0                                                 "for electrons"
            {  0      $INTEGER          IDISC,  "flag indicating user discard"
            {  0                        IROLD,  "region before transport"
            {  0                        IRNEW,  "region after transport"
            {  0                        IAUSFL; "flags for AUSGAB calls"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** MEDIA--NAMES OF MEDIA CURRENTLY BEING USED                    "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/MEDIA/;} WITH
               0  {;
            {  0     COMMON/MEDIA/
            {  0  "Ali:photonuc, 4 lines (order matters because of padding issues)"
            {  0         $LGN(RLC,RLDU,RHO,MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,
            {  0              IRAYLM,IPHOTONUCM($MXMED)),
            {  0              MEDIA(24,$MXMED), photon_xsections, comp_xsections,
            {  0              photonuc_xsections,eii_xfile,IPHOTONUC,NMED;
            {  0     $TYPE    MEDIA;"media names"
            {  0     $REAL    RLC,  "radiation length in centimeters for a given medium"
            {  0              RLDU, "radiation length after user scaling over-ride"
            {  0              RHO,  "mass density of a given medium"
            {  0              apx, upx;"new photon xsection data thresholds"
            {  0     $INTEGER MSGE, "??? "
            {  0              MGE,  "number of photon mapped energy intervals for a given medium"
            {  0              MSEKE,"??? "
            {  0              MEKE, "number of e mapped energy intervals for a given medium"
            {  0              MLEKE,"??? "
            {  0              MCMFP,"??? "
            {  0              MRANGE,"??? "
            {  0              IRAYLM,"Rayleigh switch for a given medium"
            {  0  "Ali:photonuc, 2 lines"
            {  0              IPHOTONUCM,"photonuclear switch for a given medium"
            {  0              IPHOTONUC,"set to 1 if any IPHOTONUCM is set to 1"
            {  0              NMED;  "number of media"
            {  0     character*16 eii_xfile;
            {  0              "Defaults to eii_ik.data if On or Off options selected"
            {  0              "which is the EII implemented by Iwan for EGSnrc"
            {  0              "else, following options available: "
            {  0              "  eii_'casnati'.data    "
            {  0              "  eii_'kolbenstvedt'.data "
            {  0              "  eii_'gryzinski'.data"
            {  0              "these must be in $HEN_HOUSE/data"
            {  0     character*16 photon_xsections;
            {  0              "If photon_xsections is not empty, photon cross sections will be"
            {  0              "re-initialized using data files  "
            {  0              "  'photon_xsection'_photo.data   "
            {  0              "  'photon_xsection'_pair.data    "
            {  0              "  'photon_xsection'_triplet.data "
            {  0              "  'photon_xsection'_rayleigh.data"
            {  0              "that must be placed in $HEN_HOUSE/data"
            {  0     character*16 comp_xsections;
            {  0              "If comp_xsections is not empty or not set to 'default' and"
            {  0              "bound Compton scattering is On, then total Compton cross sections"
            {  0              "will be taken from 'comp_xsections'_compton.data"
            {  0              "instead of being computed from the theoretical expressions"
            {  0  "Ali:photonuc, 5 lines"
            {  0     character*16 photonuc_xsections;
            {  0              "If photonuc_xsections is not empty or not set to 'default',"
            {  0              "the photonuclear cross sections will be taken from"
            {  0              "'photonuc_xsections'_photonuc.data instead of using the data"
            {  0              "in the default file iaea_photonuc.data."
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** MISC--MISCELLANEOUS COMMON                                    "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/MISC/;} WITH
               0  {;
            {  0    COMMON/MISC/
            {  0  "Ali:photonuc, 1 line"
            {  0             DUNIT,KMPI,KMPO,$LGN(RHOR,MED,IRAYLR,IPHOTONUCR($MXREG));
            {  0    $REAL    DUNIT,   "unit scaling factor"
            {  0             RHOR;    "density of a given region"
            {  0    $INTEGER KMPI,    "fortran unit number of the pegs4 datafile"
            {  0             KMPO;    "fortran unit number of pegs4 echo file"
            {  0    $SHORT_INT MED,   "medium number for a given region"
            {  0               IRAYLR,"Rayleigh switch for a given region"
            {  0  "Ali:photonuc, 1 line"
            {  0               IPHOTONUCR;"photonuclear switch for a given region"
            {  0  }
               0  ;
               0
               0  "------------------------------------------------------------------"
               0  "*** PHOTIN--PHOTON TRANSPORT DATA                                 "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/PHOTIN/;} WITH
               0  {;
            {  0      COMMON/PHOTIN/
            {  0         EBINDA($MXMED),
            {  0         $LGN(GE($MXMED)/0,1/),
            {  0         $LGN(GMFP,GBR1,GBR2($MXGE,$MXMED)/0,1/),
            {  0         $LGN(RCO($MXMED)/0,1/),
            {  0         $LGN(RSCT($MXRAYFF,$MXMED)/0,1/),
            {  0         $LGN(COHE($MXGE,$MXMED)/0,1/),
            {  0  "Ali:photonuc, 1 line"
            {  0         $LGN(PHOTONUC($MXGE,$MXMED)/0,1/),
            {  0         DPMFP,
            {  0         MPGEM($MXSGE,$MXMED),
            {  0         NGR($MXMED);
            {  0      $REAL
            {  0         EBINDA,      "energy of the K-edge for a given medium"
            {  0         GE0,GE1,     "used for indexing in logarithmic interpolations"
            {  0         GMFP0,GMFP1, "used for gamma MFP interpolation"
            {  0         GBR10,GBR11, "used for branching into pair interpolation"
            {  0         GBR20,GBR21, "used for branching into Compton interpolation"
            {  0         RCO0,RCO1,   "used for indexing in momentum trans. sampling in Rayleigh"
            {  0         RSCT0,RSCT1, "used for interpolation of momentum trans. func. in R"
            {  0         COHE0,COHE1, "used for Rayleigh modification interpolation"
            {  0  "Ali:photonuc, 1 line"
            {  0         PHOTONUC0,PHOTONUC1, "used for photonuclear modification interpolation"
            {  0         DPMFP;       "number of MFP's to go to the next interaction"
            {  0      $INTEGER
            {  0         MPGEM,       "??? "
            {  0         NGR;         "array size for Rayleigh scattering data"
            {  0  }
               0  ;
               0
               0  "------------------------------------------------------------------"
               0  "*** RANDOM - DECLARATIONS FOR RANDOM NUMBER GENERATOR             "
               0  "------------------------------------------------------------------"
               0
               0  " Note that the definition of the COMIN/RANDOM/ was taken out of   "
               0  " the egsnrc.macros file. The current philosophy is that the user  "
               0  " has to provide a random number generator in a separate file.     "
               0  " Two commonly used RNGs are provided in separate files:           "
               0  "  RANLUX: ranlux.macros and ranlux.mortran                        "
               0  "  RANMAR: ranmar.macros and ranmar.mortran                        "
               0
               0
               0  "------------------------------------------------------------------"
               0  "*** STACK--INFORMATION KEPT ABOUT CURRENT PARTICLES               "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/STACK/;} WITH
               0  {;
            {  0     COMMON/STACK/
            {  0         $LGN(E,X,Y,Z,U,V,W,DNEAR,WT,IQ,IR,LATCH($MXSTACK)),
            {  0         LATCHI,NP,NPold;
            {  0     $ENERGY PRECISION
            {  0         E;     "total particle energy"
            {  0     $REAL
            {  0         X,Y,Z, "particle co-ordinates"
            {  0         U,V,W, "particle direction cosines"
            {  0         DNEAR, "perpendicular distance to nearest boundary"
            {  0         WT;    "particle weight"
            {  0     $INTEGER
            {  0         IQ,    "charge, -1 for electrons, 0 for photons, 1 for positrons"
            {  0         IR,    "current region"
            {  0         LATCH, "extra phase space variable"
            {  0         LATCHI,"needed because shower does not pass latch-BLOCK DATA sets 0"
            {  0         NP,    "stack pointer"
            {  0         NPold; "stack pointer before an interaction"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** THRESH--THRESHOLD (AND OTHER) ENERGIES                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/THRESH/;} WITH
               0  {;
            {  0     COMMON/THRESH/RMT2,RMSQ,
            {  0                   $LGN(AP,AE,UP,UE,TE,THMOLL($MXMED));
            {  0     $REAL         RMT2,  "2*electron mass in MeV"
            {  0                   RMSQ,  "electron mass squared in MeV**2"
            {  0                   AP,    "photon creation threshold energy"
            {  0                   AE,    "electron creation threshold energy (total)"
            {  0                   UP,    "upper photon energy in PEGS4 data set"
            {  0                   UE,    "upper electron energy in PEGS4 data set"
            {  0                   TE,    "electron creation threshold energy (kinetic)"
            {  0                   THMOLL;"Moller threshold = AE + TE"
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** UPHIIN--SINE TABLES FOR UPHI                                  "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/UPHIIN/;} WITH
               0  {;
            {  0     COMMON/UPHIIN/SINC0,SINC1,$LGN(SIN($MXSINC)/0,1/);
            {  0     $REAL         SINC0,SINC1,SIN0,SIN1;
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** UPHIOT--UPHI'S INPUT/OUTPUT WITH ITS USERS                    "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/UPHIOT/;} WITH
               0  {;
            {  0     COMMON/UPHIOT/THETA,SINTHE,COSTHE,SINPHI,
            {  0                   COSPHI,PI,TWOPI,PI5D2;
            {  0     $REAL         THETA,  "polar scattering angle"
            {  0                   SINTHE, "sin(THETA)"
            {  0                   COSTHE, "cos(THETA)"
            {  0                   SINPHI, "sine of the azimuthal scattering angle"
            {  0                   COSPHI, "cosine of the azimuthal scattering angle"
            {  0                   PI,TWOPI,PI5D2;
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** USEFUL--HEAVILY USED VARIABLES                                "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/USEFUL/;} WITH
               0  {;
            {  0     COMMON/USEFUL/PZERO,PRM,PRMT2,RM,MEDIUM,MEDOLD;
            {  0     $ENERGY PRECISION PZERO,   "precise zero"
            {  0                       PRM,     "precise electron mass in MeV"
            {  0                       PRMT2;   "2*PRM"
            {  0     $REAL             RM;      "electron mass in MeV"
            {  0     $INTEGER          MEDIUM,  "medium index of current region"
            {  0                       MEDOLD;  "medium index of previous region"
            {  0     " The rest mass value is as recommended by CODATA 2014"
            {  0     " http://physics.nist.gov/cgi-bin/cuu/Value?mec2mev"
            {  0     DATA RM,PRM,PRMT2,PZERO/0.5109989461,0.5109989461,1.0219978922,0.D0/;
            {  0  }
               0
               0  "------------------------------------------------------------------"
               0  "*** USER--A COMMON FOR THE 'USER' TO 'USE'                        "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/USER/;} WITH {
            {  0           ;}  "DEFAULT IS NULL"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {;COMIN/X-OPTIONS/;} WITH {
            {  0      ;
            {  0    common/x_options/eadl_relax,       "Use EADL relaxation"
            {  0                     mcdf_pe_xsections;"Use Sabbatucci and Salvat PE xsections"
            {  0    $LOGICAL  eadl_relax, mcdf_pe_xsections;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** MACROS TO DEFINE THE COMMONS USED IN EACH SUBPROGRAM.         "
               0  "------------------------------------------------------------------"
               0  REPLACE {$COMIN-ANNIH;} WITH {
            {  0       ;COMIN/DEBUG,STACK, UPHIOT,USEFUL,RANDOM,EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-ANNIH-ATREST;} WITH {
            {  0      ;COMIN/DEBUG,STACK,RANDOM,USEFUL,EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-BHABHA;} WITH {
            {  0      ;COMIN/DEBUG,STACK, THRESH,UPHIOT,USEFUL,RANDOM,EGS-VARIANCE-REDUCTION,
            {  0             EGS-IO/;}
               0  REPLACE {$COMIN-BREMS;} WITH {
            {  0      ;COMIN/DEBUG,BREMPR,EPCONT,NIST-BREMS,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
            {  0             EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-COMPT;} WITH {
            {  0     ;COMIN/COMPTON-DATA,DEBUG,EPCONT,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
            {  0            EGS-VARIANCE-REDUCTION,EGS-IO,RELAX-DATA/;}
               0  REPLACE {$COMIN-ELECTR;} WITH {
            {  0  ;COMIN/DEBUG,BOUNDS,ELECIN,EPCONT,MEDIA,MISC,STACK,THRESH,
            {  0  UPHIIN,UPHIOT,USEFUL,USER,RANDOM,ET-Control,CH-Steps,EGS-IO,
            {  0            EGS-VARIANCE-REDUCTION,EMF-INPUTS/;}
               0  REPLACE {$COMIN-HATCH;} WITH {
            {  0  ;COMIN/DEBUG,BOUNDS,BREMPR,ELECIN,MEDIA,MISC,PHOTIN,STACK,THRESH,
            {  0  UPHIIN,UPHIOT,USEFUL,USER,RANDOM,ET-Control,EGS-IO,X-OPTIONS,
            {  0            EGS-VARIANCE-REDUCTION/;}
               0  REPLACE {$COMIN-MOLLER;} WITH {
            {  0     ;COMIN/DEBUG,STACK,THRESH,UPHIOT,USEFUL,RANDOM,EGS-IO,
            {  0            EGS-VARIANCE-REDUCTION/;}
               0  REPLACE {$COMIN-PAIR;} WITH {
            {  0     ;COMIN/DEBUG,BREMPR,NRC-PAIR-DATA,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
            {  0            EPCONT,TRIPLET-DATA,EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-PHOTO;} WITH {
            {  0     ;COMIN/BOUNDS,BREMPR,DEBUG,EDGE,EPCONT,MEDIA,PHOTIN,RANDOM,
            {  0            STACK,UPHIOT,USEFUL,EGS-IO,X-OPTIONS,
            {  0            EGS-VARIANCE-REDUCTION,RELAX-DATA/;}
               0  REPLACE {$COMIN-PHOTON;} WITH {
            {  0  ;COMIN/DEBUG,BOUNDS,MEDIA,MISC,EPCONT,PHOTIN,STACK,THRESH,UPHIOT,
            {  0  USEFUL,USER,RANDOM,EGS-VARIANCE-REDUCTION,EGS-IO/;}
               0  REPLACE {$COMIN-SHOWER;} WITH {
            {  0    ;COMIN/DEBUG,STACK,UPHIOT,RANDOM,EGS-IO/;}
               0  REPLACE {$COMIN-UPHI;} WITH {
            {  0    ;COMIN/DEBUG,EPCONT,STACK,UPHIIN,UPHIOT,RANDOM,EGS-IO/;}
               0  REPLACE {$COMIN-BLOCK;} WITH {
            {  0    ;COMIN/BOUNDS,BREMPR,COMPTON-DATA,EDGE,ELECIN,
            {  0    EPCONT,CH-Steps,ET-Control,MEDIA,MISC,PHOTIN,RANDOM,STACK,
            {  0    THRESH, UPHIIN,UPHIOT,USEFUL,EGS-VARIANCE-REDUCTION/;}
               0  REPLACE {$COMIN-RELAX;} WITH {
            {  0    ;COMIN/EPCONT,STACK,BOUNDS,USEFUL,RANDOM,EDGE,EGS-IO,RELAX-DATA,X-OPTIONS/;}
               0  REPLACE {$COMIN-SET-DEFAULTS;} WITH {
            {  0    ;COMIN/BOUNDS,BREMPR,COMPTON-DATA,EDGE,ELECIN,EPCONT,CH-Steps,ET-Control,
            {  0         MEDIA,MISC,PHOTIN,RANDOM,STACK,THRESH, UPHIIN,UPHIOT,USEFUL,
            {  0         EGS-VARIANCE-REDUCTION,EGS-IO,Spin-Data,EII-DATA,rayleigh_inputs,
            {  0         EMF-INPUTS,X-OPTIONS/;};
               0  REPLACE {$COMIN-INIT-COMPT;} WITH {
            {  0    ;COMIN/COMPTON-DATA,BREMPR,EDGE,MEDIA,MISC,USEFUL,EGS-IO,X-OPTIONS/;};
               0  REPLACE {$COMIN-MSCATI;} WITH {
            {  0    ;COMIN/BOUNDS,ELECIN,MEDIA,MISC,RANDOM,ET-Control,USEFUL,EGS-IO/;};
               0  REPLACE {$COMIN-INIT-TRIPLET;} WITH {
            {  0    ;COMIN/BREMPR,EGS-IO,MEDIA,TRIPLET-DATA,USEFUL/;};
               0  REPLACE {$COMIN-GET-TRANSPORTP;} WITH {
            {  0    ;COMIN/GetInput,BOUNDS,ET-Control,EDGE,COMPTON-DATA,MEDIA,MISC,
            {  0           BREMPR,EII-DATA,EGS-IO,rayleigh_inputs,EMF-INPUTS,X-OPTIONS/;};
               0  "Ali:photonuc, 1 block"
               0  REPLACE {$COMIN-PHOTONUC;} WITH {;COMIN/STACK,EPCONT,USEFUL/;};
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {ILOG2(#)} WITH {
            {  0      IFIX(1.44269*LOG({P1}))} "1.44269=1/LN(2)"
               0
               0  REPLACE {$SETINTERVAL#,#;} WITH {
            {  0      [IF] '{P2}'=SNAME  [L{P1}={P2}1*{P1}+{P2}0;]
            {  0      [ELSE]  [L{P1}={P2}1(MEDIUM)*{P1}+{P2}0(MEDIUM);]}
               0  "TWO ARGUMENT SET INTERVAL CALL (ABOVE) CURRENTLY MEANS"
               0  "INTERVAL INDEX IS LINEAR FUNCTION OF THE LINEAR VARIABLE,"
               0  "WITH NO MAPPING.  {P1} IS THE LINEAR VARIABLE AND {P2} IS"
               0  "THE NAME OF THE INTERVAL(WHICH IS USED TO CONSTRUCT THE"
               0  "COEFFICIENTS USED IN COMPUTING THE INTERVAL INDEX)."
               0  "BUT, IF {P2} IS SINC OR BLC OR RTHR OR RTHRI, IT DOES"
               0  "NOT DEPEND ON MEDIUM"
               0
               0  REPLACE {$EVALUATE#USING#(#);} WITH {
            {  0    [IF] '{P2}'=SNAME1
            {  0    [{P1}={P2}1(L{P3})*{P3}+{P2}0(L{P3});] [ELSE]
            {  0    [{P1}={P2}1(L{P3},MEDIUM)*{P3}+{P2}0(L{P3},MEDIUM);]}
               0  "{P1} IS VARIABLE TO BE ASSIGNED VALUE."
               0  "{P2} IS THE FUNCTION BEING APPROXIMATED."
               0  "{P3} IS THE ARGUMENT OF THE FUNCTION. IN THE CURRENT"
               0  "PWLF METHOD, THE ARGUMENT DETERMINES AN INTERVAL USING THE"
               0  "$SET INTERVAL MACROS.   WITH IN THIS INTERVAL THE"
               0  "FUNCTION IS APPROXIMATED AS A LINEAR FUNCTION OF"
               0  "THE ARGUMENT. BUT"
               0  "IF {P2}=SIN IT DOES NOT DEPEND ON MEDIUM"
               0
               0  REPLACE {$EVALUATE#USING#(#,#);} WITH {
            {  0    {P1}={P2}0(L{P3},L{P4})+{P2}1(L{P3},L{P4})*{P3}+
            {  0    {P2}2(L{P3},L{P4})*
            {  0    {P4};}"2-D APPROXIMATION INDEPENDENT OF MEDIUM"
               0  SPECIFY SNAME AS ['sinc'|'blc'|'rthr'|'rthri'|'SINC'|'BLC'|'RTHR'|'RTHRI'];
               0  SPECIFY SNAME1 AS ['sin'|'SIN'];
               0
               0  "The following circumvent the above table look up method for sin"
               0  "functions.  Modern machines do sines very quickly so the large saving"
               0  "in time from the above no longer exists for sines (was 40% on some"
               0  "machines for the overall computing time! (for example it makes a
               0  "20% effect on an SGI R4400)"
               0  "To recover the use of tables, just comment out the following two"
               0  "macros"
               0
               0  REPLACE {$EVALUATE#USING SIN(#);} WITH {{P1}=sin({P2});}
               0  REPLACE {$SET INTERVAL#,SINC;} WITH {;}
               0
               0
               0  "MACRO TO ALLOW USER TO ADD TO PROPERTIES THAT ARE"
               0  "PASSED TO NEW PARTICLES"
               0  REPLACE {$TRANSFERPROPERTIESTO#FROM#;} WITH {
            {  0      X{P1}=X{P2};Y{P1}=Y{P2};Z{P1}=Z{P2};IR{P1}=IR{P2};
            {  0      WT{P1}=WT{P2};DNEAR{P1}=DNEAR{P2};LATCH{P1}=LATCH{P2};}
               0     "IN THE USAGE OF THE ABOVE MACRO, '(IP)' WILL REFER TO THE"
               0     "PARTICLE WHOSE STACK INDEX IS 'IP'. 'NP' IS THE TOP OF THE STACK."
               0     "JUST PLAIN 'I' WILL REFER TO THE INITIAL VALUES SUPPLIED"
               0     "AS ARGUMENTS TO SHOWER, OR SUPPLIED IN COMMON BLOCKS OR"
               0     "DATA STATEMENTS IN SHOWER."
               0
               0  "Macro to check that the stack size is not exceeded"
               0  REPLACE {$CHECK-STACK(#,#);} WITH {;
            {  0    IF( {P1} > $MXSTACK ) [
            {  0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
            {  0        $egs_fatal('(//,3a,/,2(a,i9),/,a)',' In subroutine ',{P2},
            {  0            ' stack size exceeded! ',' $MXSTACK = ',$MXSTACK,' np = ',{P1},
            {  0            ' Increase $MXSTACK and try again ');
            {  0    ]
            {  0  };
               0
               0
               0
               0
               0
               0  REPLACE {$CHECK-STACK(#,#);} WITH {;
            {  0    IF( {P1} > $MXSTACK ) [
            {  0        $egs_fatal('(//,3a,/,2(a,i9))',' In subroutine ',{P2},
            {  0            ' stack size exceeded! ',' $MAXSTACK = ',$MXSTACK,' np = ',{P1});
            {  0    ]
            {  0  };
               0
               0  "MACRO FOR RE-EVALUATING DEDX IN SUBROUTINE ELECTR"
               0  REPLACE {$DEDX-RE-EVALUATION;} WITH {
            {  0  ;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "THE FOLLOWING MACROS ARE USED IN SUBROUTINE ELECTR IN ORDER TO MAKE"
               0  "PATH LENGTH CORRECTIONS AND RESTRICTIONS:"
               0  REPLACE {$SET-USTEP;} WITH
               0  {
            {  0    ekems = eke - 0.5*tustep*dedx; "Use mid-point energy to calculate"
            {  0                                    "energy dependent quantities"
            {  0    $CALCULATE-XI(tustep);
            {  0    IF ( xi < 0.1 )
            {  0      [
            {  0        ustep = tustep*(1 - xi*(0.5 - xi*0.166667));
            {  0      ]
            {  0      ELSE
            {  0      [
            {  0        ustep = tustep*(1 - Exp(-xi))/xi;
            {  0      ]
            {  0  }
               0  ;
               0
               0  REPLACE {$CALCULATE-XI(#);} WITH
               0  {
            {  0    p2 = ekems*(ekems+rmt2); beta2 = p2/(p2 + rmsq);
            {  0    chia2 = xccl/(4*blccl*p2);
            {  0                                  "Note that our chia2 is Moliere chia2/4"
            {  0                                  "Note also that xcc is now old egs xcc**2"
            {  0    xi = 0.5*xccl/p2/beta2*{P1};
            {  0    IF( spin_effects ) [
            {  0        elkems = Log(ekems);
            {  0        $SET INTERVAL elkems,eke;
            {  0        IF(lelec < 0) [
            {  0            $EVALUATE etap USING etae_ms(elkems);
            {  0            $EVALUATE xi_corr USING q1ce_ms(elkems);
            {  0        ]
            {  0        ELSE          [
            {  0            $EVALUATE etap USING etap_ms(elkems);
            {  0            $EVALUATE xi_corr USING q1cp_ms(elkems);
            {  0        ]
            {  0        chia2 = chia2*etap; xi = xi*xi_corr;
            {  0        $EVALUATE ms_corr USING blcce(elkems);
            {  0        blccl = blccl*ms_corr;
            {  0    ]
            {  0    ELSE [ xi_corr = 1; etap = 1; ]
            {  0    xi = xi*(Log(1+1./chia2)-1/(1+chia2));
            {  0  }
               0
               0  REPLACE {$SET-TVSTEP;} WITH
               0  "        ===========                 "
               0  {
            {  0      ;IF ( vstep < ustep0 )
            {  0      [
            {  0        ekems = eke - 0.5*tustep*vstep/ustep0*dedx;
            {  0           "This estimates the energy loss to the boundary."
            {  0           "tustep was the intended curved path-length,"
            {  0           "ustep0 is the average transport distance in the initial direction"
            {  0           "       resulting from tustep"
            {  0           "vstep = ustep is the reduced average transport distance in the "
            {  0           "              initial direction due to boundary crossing"
            {  0        $CALCULATE-XI(vstep);
            {  0        IF ( xi < 0.1 )
            {  0        [
            {  0          tvstep = vstep*(1 + xi*(0.5 + xi*0.333333));
            {  0        ]
            {  0        ELSE
            {  0        [
            {  0
            {  0          IF ( xi < 0.999999 )
            {  0          [
            {  0             tvstep = -vstep*Log(1 - xi)/xi;
            {  0          ]
            {  0          ELSE
            {  0          [
            {  0             "This is an error condition because the average transition "
            {  0             "in the initial direction of motion is always smaller than 1/Q1"
            {  0             $egs_info(*,' Stoped in SET-TVSTEP because xi > 1! ');
            {  0             $egs_info(*,' Medium: ',medium);
            {  0             $egs_info(*,' Initial energy: ',eke);
            {  0             $egs_info(*,' Average step energy: ',ekems);
            {  0             $egs_info(*,' tustep: ',tustep);
            {  0             $egs_info(*,' ustep0: ',ustep0);
            {  0             $egs_info(*,' vstep:  ',vstep);
            {  0             $egs_info(*,' ==> xi = ',xi);
            {  0             $egs_fatal(*,'This is a fatal error condition');
            {  0          ]
            {  0        ]
            {  0      ]
            {  0      ELSE
            {  0      [
            {  0        tvstep = tustep;
            {  0      ]
            {  0  }
               0  ;
               0
               0  REPLACE {$ENEPS} WITH {0.0001}
               0              "DIFFERENCE BETWEEN ECUT AND END POINT ENERGY FOR"
               0              "RANGE CALCULATION"
               0
               0  REPLACE {$EPSEMFP} WITH {1.E-5}  "SMALLEST ELECTRON MFP VALUE"
               0  REPLACE {$EPSGMFP} WITH {1.E-5}  "SMALLEST GAMMA MFP VALUE"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "THE FOLLOWING ARE UTILITY AND OTHER MACROS FOR THE USER"
               0
               0  "ETALY1---COMMON BLOCK FOR ENERGY CONSERVATION PURPOSES"
               0  REPLACE {;COMIN/ETALY1/;} WITH {
            {  0      ;COMMON/ETALY1/ESUM(4,$MXREG,5);
            {  0      $ENERGY PRECISION ESUM;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "NTALY1---COMMON BLOCK FOR KEEPING COUNT OF ETALY1-EVENTS"
               0  REPLACE {;COMIN/NTALY1/;} WITH {
            {  0     ;COMMON/NTALY1/NSUM(4,$MXREG,5);
            {  0     $INTEGER NSUM;
            {  0  }
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACRO TO ALLOW USER TO INITIALIZE IN SUBROUTINE HATCH"
               0  REPLACE {$HATCH-USER-INPUT-INIT;} WITH {;
            {  0  " $RNG-INITIALIZATION; "
            {  0  " Have taken this out, (IK, Jan 2000). If the user does not initilize the"
            {  0  " rng before the first call to shower, the rng will initialize itself    "
            {  0  " using the default seed and the default luxury level (which is defined  "
            {  0  " via $DEFAULT-LL).                                                      "
            {  0
            {  0  DO J=1,$MXREG [
            {  0    IF(SMAXIR(J)<=0.0) [SMAXIR(J)=1E10;]
            {  0  ]
            {  0  ;}
               0
               0  REPLACE {$KERMA-INSERT;} WITH {;}
               0              "USED IN KERMA CALCULATIONS---DEFAULT IS NULL"
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACRO FOR CONTROLLING NEGATIVE USTEP"
               0  REPLACE {$USER-CONTROLS-NEGATIVE-USTEP;} WITH {
            {  0  "         ============================"
            {  0     ;IF(USTEP<-1.E-4)[ IERUST=IERUST+1;OUTPUT IERUST,USTEP,IR(NP),IRNEW,
            {  0     IROLD,X(NP),Y(NP),Z(NP),SQRT(X(NP)**2+Y(NP)**2);
            {  0     (I6,' NEGATIVE USTEP=',E14.6,' IR,IRNEW,IROLD=',3I4,' X,Y,Z,R=',
            {  0     4E14.6);
            {  0     IF(IERUST>10)[OUTPUT;(///'0STOP, TOO MANY USTEP ERRORS'///); STOP;]]
            {  0     USTEP=0.0;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  REPLACE {$CHECK-NEGATIVE-USTEP;} WITH {;
            {  0      IF(ustep <= 0) [
            {  0          "Negative ustep---probable truncation problem at a"
            {  0          "boundary, which means we are not in the region we think"
            {  0          "we are in.  The default macro assumes that user has set"
            {  0          "irnew to the region we are really most likely to be"
            {  0          "in.  A message is written out whenever ustep is less than -1.e-4"
            {  0          IF(ustep < -1e-4) [
            {  0              ierust = ierust + 1;
            {  0              OUTPUT ierust,ustep,dedx,e(np)-prm,
            {  0                     ir(np),irnew,irold,x(np),y(np),z(np);
            {  0              (i4,' Negative ustep = ',e12.5,' dedx=',F8.4,' ke=',F8.4,
            {  0               ' ir,irnew,irold =',3i4,' x,y,z =',4e10.3);
            {  0              IF(ierust > 1000) [
            {  0                  OUTPUT;(////' Called exit---too many ustep errors'///);
            {  0                  $CALL_EXIT(1);
            {  0              ]
            {  0          ]
            {  0          ustep = 0;
            {  0      ]
            {  0  };
               0
               0  "MACRO FOR INTRODUCING FLUCTUATIONS IN THE ENERGY LOSS BY"
               0  "CHARGED PARTICLES (E.G., 'LANDAU FLUCTUATIONS')---DEFAULT IS NULL"
               0  REPLACE {$DE-FLUCTUATION;} WITH {;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "Macro for production of annihilation quanta whenever"
               0  "the energy is greater than AE but less than or equal to ECUT."
               0  "photons are always produced in EGSnrc."
               0
               0  REPLACE {$POSITRON-ECUT-DISCARD;} WITH {EDEP=PEIE-PRM;}
               0  "NOTE: TO GET THE EGS3 VERSION SIMPLY USE EDEP=PEIE+PRM"
               0  "      AS THE REPLACEMENT PART OF THE MACRO."
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "MACROS FOR PARTICLE SELECTION (E.G., LEADING PARTICLE,"
               0  "SPLITTING, ETC.).  DEFAULT IS ULTIMATELY 'NULL'"
               0  "     -----IN SUBROUTINE ELECTR-----                 "
               0  REPLACE {$PARTICLE-SELECTION-ELECTR;} WITH {;}
               0  REPLACE {$PARTICLE-SELECTION-ANNIH;} WITH {
            {  0           $PARTICLE-SELECTION-ELECTR;}
               0  REPLACE {$PARTICLE-SELECTION-ANNIHREST;} WITH {
            {  0          $PARTICLE-SELECTION-ELECTR;}
               0  REPLACE {$PARTICLE-SELECTION-BHABHA;} WITH {
            {  0          $PARTICLE-SELECTION-ELECTR;}
               0  REPLACE {$PARTICLE-SELECTION-BREMS;} WITH {
            {  0          $PARTICLE-SELECTION-ELECTR;}
               0  REPLACE {$PARTICLE-SELECTION-MOLLER;}
               0     WITH {$PARTICLE-SELECTION-ELECTR;}
               0  "     -----IN SUBROUTINE PHOTON-----                 "
               0  REPLACE {$PARTICLE-SELECTION-PHOTON;} WITH {;}
               0  REPLACE {$PARTICLE-SELECTION-COMPT;} WITH {
            {  0          $PARTICLE-SELECTION-PHOTON;}
               0  REPLACE {$PARTICLE-SELECTION-PAIR;} WITH {
            {  0          $PARTICLE-SELECTION-PHOTON;}
               0  REPLACE {$PARTICLE-SELECTION-PHOTO;} WITH {
            {  0          $PARTICLE-SELECTION-PHOTON;}
               0
               0  "MACRO FOR SELECTION OF THE ELECTRON MEAN-FREE-PATH"
               0  REPLACE {$SELECT-ELECTRON-MFP;} WITH {
            {  0          $RANDOMSET RNNE1; IF(RNNE1.EQ.0.0) [RNNE1=1.E-30;]
            {  0           DEMFP=MAX(-LOG(RNNE1),$EPSEMFP);}
               0
               0  "MACRO FOR SELECTION OF THE PHOTON MEAN-FREE-PATH"
               0  REPLACE {$SELECT-PHOTON-MFP;} WITH {
            {  0         $RANDOMSET RNNO35; IF(RNNO35.EQ.0.0) [RNNO35=1.E-30;]
            {  0           DPMFP=-LOG(RNNO35);}
               0
               0  "MACRO to do range rejection on a region by region basis"
               0  "      if the user requests it.  The variables e_max_rr and i_do_rr"
               0  "      are in COMIN ET-CONTROL.  This macro is called immediately"
               0  "      after $USER-RANGE-DISCARD in ELECTR and everytime called"
               0  "      the electrons current range has been computed and stored in"
               0  "      range and the distance to the nearest boundary has just been"
               0  "      computed and is in tperp.  e_max_rr and i_do_rr are initialized"
               0  "      to zero in BLOCK DATA so range rejection is not done unless"
               0  "      Since option must be turned on by the user, it is considered a"
               0  "      USER-ELECTRON-DISCARD."
               0  "      Note this technique implies an approximation because the particle"
               0  "      is not allowed to create a brem particle which might escape"
               0  "      the region.  This is why  e_max_rr is used, to allow high"
               0  "      energy electrons to be tracked in case they give off brem."
               0
               0  REPLACE {$RANGE-DISCARD;} WITH {
            {  0    ;IF( i_do_rr(irl) = 1 & e(np) < e_max_rr(irl) ) [
            {  0        IF(tperp >= range) ["particle cannot escape local region"
            {  0            idisc = 50 + 49*iq(np); "1 for electrons, 99 for positrons"
            {  0            go to :USER-ELECTRON-DISCARD: ;
            {  0        ]
            {  0    ]
            {  0  };
               0
               0
               0  "MACRO TO ALLOW USER TO DISCARD IF AT OR NEAR END OF RANGE"
               0  REPLACE {$USER-RANGE-DISCARD;} WITH {;}
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "RAYLEIGH (COHERENT) SCATTERING MACROS"
               0
               0  "custom form factor file names"
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  REPLACE {COMIN/rayleigh_inputs/;} WITH
               0  "        ================"
               0  {
            {  0  ;COMMON/rayleigh_inputs/iray_ff_media($MXMED),iray_ff_file($MXMED);
            {  0  ;character*24 iray_ff_media;
            {  0  ;character*128 iray_ff_file;
            {  0  }
               0
               0  REPLACE {COMIN/rayleigh_sampling/;} WITH
               0  "        ================"
               0  {;COMMON/rayleigh_sampling/xgrid($MXRAYFF,$MXMED),
            {  0                              fcum($MXRAYFF,$MXMED),
            {  0                             b_array($MXRAYFF,$MXMED),
            {  0                             c_array($MXRAYFF,$MXMED),
            {  0                             i_array($RAYCDFSIZE,$MXMED),
            {  0                             $LGN(pmax($MXGE,$MXMED)/0,1/);
            {  0  $REAL xgrid, fcum, b_array, c_array,pmax0, pmax1;
            {  0  $INTEGER i_array;
            {  0  }
               0
               0  REPLACE {$RAYLEIGH-CORRECTION;} WITH {
            {  0       ;IF(IRAYLR(IRL).EQ.1) [$EVALUATE COHFAC USING COHE(GLE);
            {  0      GMFP=GMFP*COHFAC];}
               0
               0  REPLACE {$OLD_RAYLEIGH-SCATTERING;} WITH {
            {  0        ;IF(IRAYLR(IRL).EQ.1) [
            {  0     $RANDOMSET RNNO37;
            {  0     IF (RNNO37.LE.(1.0-COHFAC)) [
            {  0     $AUSCALL($RAYLAUSB);
            {  0     NPold = NP;
            {  0     :SAMPLING-LOOP: LOOP [$RANDOMSET XXX;
            {  0     $SET INTERVAL XXX,RCO; $EVALUATE X2 USING RSCT(XXX);
            {  0     Q2=X2*RMSQ/(20.60744*20.60744);
            {  0     COSTHE=1.-Q2/(2.*E(NP)*E(NP));
            {  0     IF (ABS(COSTHE).GT.1.0) GO TO :SAMPLING-LOOP:;
            {  0     CSQTHE=COSTHE*COSTHE;
            {  0     REJF=(1.0+CSQTHE)/2.0;
            {  0     $RANDOMSET RNNORJ;
            {  0     ] UNTIL (RNNORJ <= REJF);
            {  0     SINTHE=SQRT(1.0-CSQTHE); CALL UPHI(2,1);
            {  0     $AUSCALL($RAYLAUSA);
            {  0     GOTO :PNEWENERGY:;]]
            {  0    }
               0  REPLACE {$RAYLEIGH-SCATTERING;} WITH {
            {  0     ;IF(IRAYLR(IRL).EQ.1) [
            {  0     $RANDOMSET RNNO37;
            {  0     IF (RNNO37.LE.(1.0-COHFAC)) [
            {  0     $AUSCALL($RAYLAUSB);
            {  0     NPold = NP;
            {  0     call egs_rayleigh_sampling(MEDIUM,E(NP),GLE,LGLE,COSTHE,SINTHE);
            {  0     CALL UPHI(2,1);
            {  0     $AUSCALL($RAYLAUSA);
            {  0     GOTO :PNEWENERGY:;]]
            {  0  }
               0
               0  "Ali:photonuc, 2 blocks"
               0  REPLACE {$PHOTONUC-CORRECTION;} WITH {
            {  0       ;IF(IPHOTONUCR(IRL).EQ.1) [$EVALUATE PHOTONUCFAC USING PHOTONUC(GLE);
            {  0      GMFP=GMFP*PHOTONUCFAC];}
               0
               0  REPLACE {$PHOTONUCLEAR;} WITH {
            {  0     ;IF(IPHOTONUCR(IRL).EQ.1) [
            {  0        $RANDOMSET RNNO39;
            {  0        IF (RNNO39.LE.(1.0-PHOTONUCFAC)) [
            {  0          $AUSCALL($PHOTONUCAUSB);
            {  0          call PHOTONUC;
            {  0          $AUSCALL($PHOTONUCAUSA);
            {  0          GOTO :PNEWENERGY:;
            {  0        ]
            {  0      ]
            {  0  }
               0
               0  "DENSITY RATIO SCALING MACRO (TO OVER-RIDE DENSITY IN A PARTICULAR"
               0  "REGION)  NOTE: THIS MACRO REPLACES SUBROUTINE RHOSET OF EGS3"
               0
               0  REPLACE {$SET-RHOF;} WITH {RHOF=RHOR(IRL)/RHO(MEDIUM);}  "DEFAULT"
               0
               0  "TEMPLATES FOR PERFORMING CHARGED PARTICLE TRANSPORT IN EM FIELD"
               0  REPLACE {$SET-TUSTEP-EM-FIELD;} WITH {;}
               0  REPLACE {$SET-USTEP-EM-FIELD;} WITH {;}
               0  REPLACE {$VACUUM-TRANSPORT-EM-FIELD;} WITH {;}
               0  REPLACE {$SET-ANGLES-EM-FIELD;} WITH {;}
               0  REPLACE {$SET-TVSTEP-EM-FIELD;} WITH {;}
               0  REPLACE {$ADD-WORK-EM-FIELD;} WITH {;}
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------"
               0  "        EGS4/EGSnrc GEOMETRY MACROS: AN EXTENSION TO EGS MACROS   "
               0  "------------------------------------------------------------------"
               0
               0  "   NOTE1: CYLNDR IS A NEW MACRO BY G.R.STEVENSON OF CERN"
               0  "          (SEE HS-RP/TM/80-78, 25 NOV. 1980)"
               0
               0  "   NOTE2: CONE IS A NEW MACRO BY H.HIRAYAMA OF KEK. "
               0  "          MACRO REPLACEMENT OF CERN VERSION SUBROUTINE CONE"
               0  "          (SEE HS-RP/TM/81-30, 5 MAY 1981)"
               0
               0  "   NOTE3: SPHERE IS A NEW MACRO BY G.R.STEVENSON OF CERN"
               0  "          (SEE HS-RP/TM/81-30, 5 MAY 1981)"
               0
               0  "   NOTE4: $PLAN2X AND $PLAN2P ARE TWO NEW MACROS BY W.R.NELSON."
               0  "          $PLAN2P WAS FORMERLY CALLED $PLANE2 AND IS STILL THE"
               0  "          SAME (CALLS TO $PLANE2 WILL AUTOMATICALLY DEFAULT TO"
               0  "          TO $PLAN2P).  $PLAN2X, HOWEVER, WILL CORRECTLY HANDLE"
               0  "          THE CASE OF TWO, NON-PARALLEL PLANES."
               0
               0  "------------------------------------------------------------------"
               0  "        MACRO-ROUTINES FOR PLANE GEOMETRY  (SLAC VERSION)         "
               0  "------------------------------------------------------------------"
               0  ;
               0  PARAMETER $MXPLNS=100;     "MAX. NO. OF PLANES"
               0
               0  "PLADTA---COMMON BLOCK FOR $PLANE1 AND $PLANE2 MACROS"
               0  REPLACE {;COMIN/PLADTA/;} WITH {
            {  0        ;COMMON/PLADTA/PCOORD(3,$MXPLNS),PNORM(3,$MXPLNS);
            {  0        $REAL PCOORD, PNORM;
            {  0  }
               0
               0  "$PLANE1---MACRO REPLACEMENT FOR SUBROUTINE PLANE1"
               0  REPLACE {$PLANE1(#,#,#,#);} WITH {
            {  0   UDOTA=PNORM(1,{P1})*U(NP)+PNORM(2,{P1})*
            {  0   V(NP)+PNORM(3,{P1})*W(NP); UDOTAP={P2}*UDOTA;
            {  0   IF(UDOTA.EQ.0.0)[{P3}=2;]ELSEIF(UDOTAP.LT.0.0)
            {  0   [{P3}=0;] ELSE [{P3}=1;{P4}=(PNORM(1,{P1})*
            {  0   (PCOORD(1,{P1})-X(NP))+ PNORM(2,{P1})*
            {  0   (PCOORD(2,{P1})-Y(NP))+PNORM(3,{P1})*
            {  0   (PCOORD(3,{P1})-Z(NP)))/UDOTA;]}
               0  "NOTE:   EVERYWHERE $PLANE1 IS USED ONE MUST"
               0  "        INCLUDE COMIN/PLADTA,STACK/"
               0
               0  "------------------------------------------------------------------"
               0
               0  "$PLANE2---MACRO REPLACEMENT FOR SUBROUTINE PLANE2"
               0  "          NOTE: $PLANE2 HAS BEEN SUPERCEDED BY $PLAN2P (BELOW),"
               0  "                WHICH IS AUTOMATICALLY TAKEN CARE OF BY THE"
               0  "                FOLLOWING MACRO STATEMENT."
               0  REPLACE {$PLANE2} WITH {$PLAN2P}
               0
               0  "------------------------------------------------------------------"
               0
               0  "$PLAN2P---MACRO REPLACEMENT FOR SUBROUTINE PLAN2P (OR $PLANE2)"
               0  "          (I.E., TWO PARALLEL PLANES)"
               0  REPLACE {$PLAN2P(#,#,#,#,#,#);} WITH {
            {  0    $PLANE1({P1},{P3},IHIT,TVAL); IF(IHIT.EQ.1)
            {  0   [ $CHGTR(TVAL,{P2});] ELSEIF(IHIT.EQ.0)
            {  0   [$PLANE1({P4},{P6},IHIT,TVAL);$CHGTR(TVAL,{P5});]}
               0  "NOTE:   EVERYWHERE $PLAN2P ($PLANE2) IS USED ONE MUST"
               0  "        INCLUDE COMIN/EPCONT,PLADTA,STACK/"
               0
               0  "------------------------------------------------------------------"
               0
               0  "$PLAN2X---MACRO REPLACEMENT FOR SUBROUTINE PLAN2X"
               0  "          (I.E., TWO, NON-PARALLEL (CROSSING) PLANES)"
               0  REPLACE {$PLAN2X(#,#,#,#,#,#);} WITH {
            {  0      $PLANE1({P1},{P3},IHIT,TVAL); IF(IHIT.EQ.1) [
            {  0     $CHGTR(TVAL,{P2});]   $PLANE1({P4},{P6},IHIT,TVAL);
            {  0     IF(IHIT.EQ.1) [$CHGTR(TVAL,{P5});]}
               0  "NOTE:   EVERYWHERE $PLAN2X IS USED ONE MUST"
               0  "        INCLUDE COMIN/EPCONT,PLADTA,STACK/"
               0
               0  "------------------------------------------------------------------"
               0  "      MACRO-ROUTINE FOR CYLINRICAL GEOMETRY  (CERN VERSION)       "
               0  "------------------------------------------------------------------"
               0
               0  PARAMETER $MXCYLS=75;      "MAX. NO. OF CYLINDERS"
               0  PARAMETER $DELCYL=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"
               0
               0  "CYLDTA---COMMON BLOCK FOR $CYLNDR MACRO"
               0  REPLACE {;COMIN/CYLDTA/;} WITH {
            {  0     ;COMMON/CYLDTA/CYRAD2($MXCYLS);
            {  0     $REAL CYRAD2;
            {  0  }
               0
               0  "$CYLNDR---MACRO REPLACEMENT FOR SUB CYLNDR GRS VERSION 14 11 80"
               0  REPLACE {$CYLNDR(#,#,#,#);} WITH {
            {  0     {P3}=1;{P4}=0.0;ACYL=SQRT(U(NP)*U(NP)+V(NP)*V(NP));
            {  0     IF(ACYL.EQ.0.0)[{P3}=0;]  ELSE [
            {  0     BCYL=(X(NP)*U(NP)+Y(NP)*V(NP))/ACYL;CCYL=X(NP)*X(NP)+Y(NP)*Y(NP)
            {  0     -CYRAD2({P1});  ARGCY=BCYL*BCYL-CCYL;
            {  0     IF(ARGCY.LT.0.0) [{P3}=0;]   ELSE [
            {  0     IF(ABS(CCYL).LT.$DELCYL.AND.{P2}.EQ.0.AND.BCYL.GE.0.0)[{P3}=0;]
            {  0     ELSEIF(ABS(CCYL).LT.$DELCYL.AND.{P2}.EQ.1.AND.BCYL.LT.0.0)[
            {  0     {P4}=-2.0*BCYL/ACYL;]
            {  0     ELSE [ IF({P2}.EQ.1.AND.CCYL.GE.0.0)[{P3}=1;{P4}=$DELCYL;]
            {  0     ELSEIF({P2}.EQ.0.AND.CCYL.LE.0.0)[{P3}=1;{P4}=$DELCYL;]
            {  0     ELSE  [  ROOTCY=SQRT(ARGCY); IF(CCYL.LT.0.0)
            {  0     [{P4}=(-BCYL+ROOTCY)/ACYL;]
            {  0     ELSEIF(BCYL.LT.0.0) [{P4}=(-BCYL-ROOTCY)/ACYL;]
            {  0     ELSE [{P3}=0;]]]]]}
               0  "NOTE:   EVERYWHERE $CYLNDR IS USED ONE MUST"
               0  "         INCLUDE COMIN/CYLDTA,STACK/"
               0
               0  "$CYL2--MACRO EQUIVALENT FOR CYLNDR OF $PLANE2  GRS 17.11.80"
               0  REPLACE {$CYL2(#,#,#,#);} WITH {
            {  0   $CYLNDR({P1},0,IHIT,TCYL);IF(IHIT.EQ.1)[
            {  0   $CHGTR(TCYL,{P2});]ELSE[$CYLNDR({P3},1,IHIT,TCYL);
            {  0   IF(IHIT.EQ.1)[ $CHGTR(TCYL,{P4});]]}
               0  "NOTE:   EVERYWHERE $CYL2 IS USED ONE MUST
               0  "         INCLUDE COMIN/CYLDTA,STACK/"
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------"
               0  "     MACRO-ROUTINE FOR CERN CONICAL GEOMETRY  (SLAC VERSION)      "
               0  "------------------------------------------------------------------"
               0
               0  PARAMETER $MXCONES=75;     "MAXIMUM NUMBER OF CONES"
               0  PARAMETER $DELCON=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"
               0
               0  "CONDTA---COMMON BLOCK FOR $CONE MACRO"
               0  REPLACE {;COMIN/CONDTA/;} WITH {
            {  0     ;COMMON/CONDTA/COTAL2($MXCONES),SMALLL($MXCONES);
            {  0     $REAL COTAL2, SMALLL;
            {  0  }
               0
               0  "$CONE---MACRO REPLACEMENT FOR CERN VERSION SUBROUTINE CONE"
               0  REPLACE {$CONE(#,#,#,#);} WITH {
            {  0     {P3}=0;ITWOPR=0;CPCON=COTAL2({P1});SGNCON=SIGN(1.0,CPCON);
            {  0     CPCON=ABS(CPCON);ZNP=SGNCON*(Z(NP)-SMALLL({P1}));
            {  0     WNP=SGNCON*W(NP);CPCON1=1.0+CPCON;
            {  0     CPCON2=SQRT(CPCON1);DCON1=X(NP)*X(NP)+Y(NP)*Y(NP);
            {  0     DCON2=SQRT(DCON1); IF((ZNP.GE.0.0).OR.(WNP.GE.0.0)) [
            {  0     ACON=(U(NP)*U(NP)+V(NP)*V(NP))*CPCON-WNP*WNP;
            {  0     BCON1=(X(NP)*U(NP)+Y(NP)*V(NP))*CPCON;BCON=BCON1-ZNP*WNP;
            {  0     CCON=DCON1*CPCON-ZNP*ZNP;
            {  0     IF(ACON.EQ.0.0)[IF(BCON.NE.0.0)
            {  0     [IF(ABS(CCON).LT.$DELCON.AND.ZNP.GE.0.0)[
            {  0     IF(({P2}.EQ.1.AND.BCON.GE.0.0).OR.({P2}.EQ.0.AND.BCON.LE.0.0))[
            {  0     TCON1=-CCON/(2*BCON);IF(TCON1.GE.0.0)[IF((ZNP+TCON1*WNP).GE.0.0)
            {  0     [{P4}=TCON1;{P3}=1;]]]]]
            {  0     ELSE[TCON1=CPCON2*ZNP*SIGN(1.0,-WNP);
            {  0     IF(TCON1.GE.0.0)[{P4}=TCON1;{P3}=1;]]]
            {  0     ELSEIF((ABS(CCON).LT.$DELCON).AND.(ZNP.GE.0.0))
            {  0     [BPRIM=BCON1-WNP*DCON2;
            {  0     IF({P2}.EQ.1.AND.BPRIM.LT.0.0)[TCON1=-2*BCON/ACON;
            {  0     IF(TCON1.GE.0.0) [{P4}=TCON1;{P3}=1;]]]
            {  0     ELSEIF({P2}.EQ.1.AND.CCON.GT.0.0) [{P4}=$DELCON;{P3}=1;]
            {  0     ELSEIF({P2}.EQ.0.AND.CCON.LT.0.0.AND.ZNP.GE.0.0)
            {  0     [{P4}=$DELCON;{P3}=1;] ELSE[CCON1=BCON*BCON-ACON*CCON;
            {  0     IF(CCON1.GE.0.0)[ROOT=SQRT(CCON1);
            {  0     IF(BCON.GT.0.0)[TCON11=-(BCON+ROOT)/ACON;]
            {  0     ELSE[TCON11=-CCON/(BCON-ROOT);]
            {  0     IF(BCON.LT.0.0)[TCON22=-(BCON-ROOT)/ACON;]
            {  0     ELSE[TCON22=-CCON/(BCON+ROOT);]
            {  0     IF((TCON11.GE.0.0).OR.(TCON22.GE.0.0))[
            {  0     IF(TCON11.LT.0.0)[TCON1=TCON22;]
            {  0     ELSE[IF(TCON22.LT.0.0)[TCON1=TCON11;] ELSE[ITWOPR=1;
            {  0     TCON1=min(TCON11,TCON22);TCON2=max(TCON11,TCON22);]]
            {  0     IF((ZNP+TCON1*WNP).GE.0.0)[{P4}=TCON1;{P3}=1;]
            {  0     ELSEIF((ITWOPR.EQ.1).AND.((ZNP+TCON2*WNP).GE.0.0))
            {  0     [{P4}=TCON2;{P3}=1;]]]]]}
               0  "NOTE:   EVERYWHERE $CONE IS USED ONE MUST
               0  "         INCLUDE COMIN/CONDTA,STACK/"
               0
               0  "$CON2--MACRO EQUIVALENT FOR CONE OF $PLANE2            "
               0  REPLACE {$CON2(#,#,#,#);} WITH {
            {  0     $CONE({P1},0,IHIT,TCON);IF(IHIT.EQ.1)[
            {  0     $CHGTR(TCON,{P2});]ELSE[$CONE({P3},1,IHIT,TCON);IF(IHIT.EQ.1)[
            {  0     $CHGTR(TCON,{P4});]]}
               0
               0  "$CON21--MACRO EQUIVALENT FOR CONE OF $PLANE2 (IN THE CASE  "
               0  "OF OUTSIDE TWO CONE SURFACE)                               "
               0  REPLACE {$CON21(#,#,#,#);} WITH {
            {  0     $CONE({P1},0,IHIT,TCON);IF(IHIT.EQ.1)[
            {  0     $CHGTR(TCON,{P2});]ELSE[$CONE({P3},0,IHIT,TCON);IF(IHIT.EQ.1)[
            {  0     $CHGTR(TCON,{P4});]]}
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------"
               0  "        MACRO-ROUTINE FOR SPHERICAL GEOMETRY  (CERN VERSION)      "
               0  "------------------------------------------------------------------"
               0
               0  PARAMETER $MXSPHE=75;      "MAX. NO. OF SPHERES"
               0  PARAMETER $DELSPH=1.0E-04; "CLOSEST ALLOWABLE DISTANCE TO SURFACE"
               0
               0  "SPHDTA------COMMON BLOCK FOR $SPHERE MACRO"
               0  REPLACE {;COMIN/SPHDTA/;} WITH {
            {  0     ;COMMON/SPHDTA/SPRAD2($MXSPHE);
            {  0     $REAL SPRAD2;
            {  0  }
               0
               0  "$SPHERE---MACRO REPLACEMENT FOR SUB SPHERE GRS VERSION 08 12 80"
               0  REPLACE {$SPHERE(#,#,#,#);} WITH {
            {  0     {P3}=1;{P4}=0.0;ASPH=1.0;
            {  0     BSPH=(X(NP)*U(NP)+Y(NP)*V(NP)+Z(NP)*W(NP))/ASPH;CSPH=X(NP)*X(NP)
            {  0     +Y(NP)*Y(NP)+Z(NP)*Z(NP)  -SPRAD2({P1});  ARGSP=BSPH*BSPH-CSPH;
            {  0     IF(ARGSP.LT.0.0) [{P3}=0;]   ELSE [
            {  0     IF(ABS(CSPH).LT.$DELSPH.AND.{P2}.EQ.0.AND.BSPH.GE.0.0)[{P3}=0;]
            {  0     ELSEIF(ABS(CSPH).LT.$DELSPH.AND.{P2}.EQ.1.AND.BSPH.LT.0.0)[
            {  0     {P4}=-2.0*BSPH/ASPH;]
            {  0     ELSE [ IF({P2}.EQ.1.AND.CSPH.GE.0.0)[{P3}=1;{P4}=$DELSPH;]
            {  0     ELSEIF({P2}.EQ.0.AND.CSPH.LE.0.0)[{P3}=1;{P4}=$DELSPH;]
            {  0     ELSE [ROOTSP=SQRT(ARGSP); IF(CSPH.LT.0.0)
            {  0     [{P4}=(-BSPH+ROOTSP)/ASPH;] ELSEIF(BSPH.LT.0.0)
            {  0     [{P4}=(-BSPH-ROOTSP)/ASPH;] ELSE [{P3}=0;]]]]}
               0  "NOTE:   EVERYWHERE $SPHERE IS USED ONE MUST
               0  "         INCLUDE COMIN/SPHDTA,STACK/"
               0
               0  "$SPH2--MACRO EQUIVALENT FOR SPHERE OF $PLANE2  GRS 08.12.80"
               0  REPLACE {$SPH2(#,#,#,#);} WITH {
            {  0   $SPHERE({P1},0,IHIT,TSPH);IF(IHIT.EQ.1)[
            {  0   $CHGTR(TSPH,{P2});]ELSE[$SPHERE({P3},1,IHIT,TSPH);
            {  0   IF(IHIT.EQ.1)[ $CHGTR(TSPH,{P4});]]}
               0  "NOTE:   EVERYWHERE $SPH2 IS USED ONE MUST
               0  "         INCLUDE COMIN/SPHDTA,STACK/"
               0
               0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
               0
               0  "------------------------------------------------------------------"
               0  "        MACRO-ROUTINE FOR CHANGING REGIONS  (SLAC VERSION)        "
               0  "------------------------------------------------------------------"
               0
               0  "$CHGTR---MACRO REPLACEMENT FOR SUBROUTINE CHGTR"
               0  REPLACE {$CHGTR(#,#);} WITH {
            {  0      ;IF({P1}.LE.USTEP) [USTEP={P1}; IRNEW={P2};]}
               0  "NOTE:   EVERYWHERE $CHGTR IS USED ONE MUST
               0  "         INCLUDE COMIN/EPCONT/"
               0
               0  "------------------------------------------------------------------"
               0  "     MACRO-ROUTINE TO OBTAIN FINAL COORDINATES (SLAC VERSION)     "
               0  "------------------------------------------------------------------"
               0
               0  "$FINVAL---MACRO REPLACEMENT FOR SUBROUTINE FINVAL"
               0  REPLACE {$FINVAL(#,#,#,#);} WITH {
            {  0     {P2}=X(NP)+{P1}*U(NP); {P3}=Y(NP)+{P1}*V(NP);
            {  0     {P4}=Z(NP)+{P1}*W(NP);}
               0  "NOTE:   EVERYWHERE $FINVAL IS USED ONE MUST
               0  "         INCLUDE COMIN/STACK/"
               0
               0  "------------------------------------------------------------------"
               0  "                 END OF GEMOETRY MACRO EXTENSION                  "
               0  "------------------------------------------------------------------"
               0
               0  "******************************************************************"
               0  "                                                                  "
               0  "                    NRC EXTENSIONS                                "
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  ; "BUFFER FLUSH"
               0  "--------------------------------------------------------------"
               0  "                                                              "
               0  "           PHOTOELECTRON ANGLE SELECTION                      "
               0  "           =============================                      "
               0  "                                                              "
               0  "--------------------------------------------------------------"
               0  "This macro can be used to select the photoelectron direction  "
               0
               0  REPLACE {$SELECT-PHOTOELECTRON-DIRECTION;} WITH {
            {  0  "        ================================"
            {  0  ;IF(IPHTER(IR(NP)).EQ.1)[
            {  0    EELEC=E(NP);
            {  0    IF(EELEC.GT.ECUT(IR(NP)))[
            {  0      BETA=SQRT((EELEC-RM)*(EELEC+RM))/EELEC;
            {  0      GAMMA=EELEC/RM;
            {  0      ALPHA=0.5*GAMMA-0.5+1./GAMMA;
            {  0      RATIO=BETA/ALPHA;
            {  0      LOOP[
            {  0        $RANDOMSET RNPHT;RNPHT=2.*RNPHT-1.;
            {  0        IF(RATIO.LE.0.2)[
            {  0          FKAPPA=RNPHT+0.5*RATIO*(1.-RNPHT)*(1.+RNPHT);
            {  0          IF( gamma < 100 ) [
            {  0              COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA);
            {  0          ]
            {  0          ELSE [
            {  0              IF( fkappa > 0 ) [
            {  0                  costhe = 1 - (1-fkappa)*(gamma-3)/(2*(1+fkappa)*(gamma-1)**3);
            {  0              ]
            {  0              ELSE [ COSTHE=(BETA+FKAPPA)/(1.+BETA*FKAPPA); ]
            {  0          ]
            {  0          "XI=1./(1.-BETA*COSTHE); <-- this numerically problematic "
            {  0          "                            at high energies, IK"
            {  0          xi = (1+beta*fkappa)*gamma*gamma;
            {  0        ]
            {  0        ELSE[
            {  0          XI=GAMMA*GAMMA*(1.+ALPHA*(SQRT(1.+RATIO*(2.*RNPHT+RATIO))-1.));
            {  0          COSTHE=(1.-1./XI)/BETA;
            {  0        ]
            {  0        SINTH2=MAX(0.,(1.-COSTHE)*(1.+COSTHE));
            {  0        $RANDOMSET RNPHT2;
            {  0        ]WHILE(RNPHT2.GT.0.5*(1.+GAMMA)*SINTH2*XI/GAMMA);
            {  0      SINTHE=SQRT(SINTH2);
            {  0      CALL UPHI(2,1);]]
            {  0  }
               0
               0  ; "BUFFER FLUSH"
               0
               0  "--------------------------------------------------------------"
               0  "                                                              "
               0  "           TSTEP RECURSION IN ELECTR                          "
               0  "           =========================                          "
               0  "                                                              "
               0  "--------------------------------------------------------------"
               0  "This macro can be used to control TSTEP recursion in ELECTR   "
               0
               0  REPLACE {$USER_CONTROLS_TSTEP_RECURSION;} WITH {;}
               0
               0  ; "BUFFER FLUSH"
               0
               0  %C80                                                                           ;
               0  "------------------------------------------------------------------"
               0  "  BREMSSTRAHLUNG ANGLE SELECTION MACROS                           "
               0  "------------------------------------------------------------------"
               0
               0
               0  "These macros are explained in NRCC REPORT #PIRS0203"
               0  "by Bielajew, Mohan and Chui                        "
               0
               0  "Macro to initialize data for bremsstrahlung production               "
               0  "The quantity ZBRANG is ( (1/111)*Zeff**(1/3) )**2                    "
               0  "where Zeff is defined in equation (7) OF PIRS0203                    "
               0  "This macro goes in SUBROUTINE HATCH                                  "
               0  "                                                                     "
               0  REPLACE {$INITIALIZE-BREMS-ANGLE;} WITH {
            {  0  ; IF(IBRDST.EQ.1)[
            {  0          DO IM=1,NMED[
            {  0              ZBRANG(IM)=0.0;PZNORM=0.0;
            {  0              DO IE=1,NNE(IM)[
            {  0                  ZBRANG(IM)=
            {  0                    ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+1.0);
            {  0                  PZNORM=PZNORM+PZ(IM,IE);
            {  0                  ]
            {  0                  ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.);
            {  0                  LZBRANG(IM)=-log(ZBRANG(IM));
            {  0              ]
            {  0          ]
            {  0  }
               0  ;
               0
               0  ;
               0
               0  " Following is associated with the selection of bremsstrahlung photon"
               0  " angle.  This has been implemented directly into the BREMS subroutine"
               0  " and changed slightly. Nonetheless, this macro is still used."
               0
               0  "This is the function G(X) of PIRS0203               "
               0  "The result is returned in {P1} as a function of {P2}"
               0  "i.e. {P1}=G({P2}) where {P2}=X                      "
               0  "                                                    "
               0  REPLACE {$SET-BREM-REJECTION-FUNCTION(#,#);} WITH {
            {  0  ; Y2TST1=(1.+{P2})**2;
            {  0  {P1}= (4.+LOG(RJARG3+ZTARG/Y2TST1))*(4.*ESEDEI*{P2}/Y2TST1-RJARG1)+RJARG2;
            {  0  }
               0  ;
               0
               0  "------------------------------------------------------------------"
               0  "  PAIR ANGLE SELECTION MACROS                                     "
               0  "------------------------------------------------------------------"
               0
               0  "These macros are explained in NRCC REPORT # PIRS0287 by Bielajew     "
               0
               0  ;
               0  "Macro to initialize data for PAIR PRODUCTION                         "
               0  "THE QUANTITY ZBRANG IS ( (1/111)*Zeff**(1/3) )**2                    "
               0  "WHERE Zeff IS DEFINED IN EQUATION (7) OF PIRS0287                    "
               0  "THIS MACRO GOES IN SUBROUTINE HATCH                                  "
               0  "THIS MACRO IS IDENTICAL TO THE $INITIALIZE-BREMS-ANGLE DEFINED ABOVE "
               0  "                                                                     "
               0  REPLACE {$INITIALIZE-PAIR-ANGLE;} WITH {
            {  0  ;    IF(IPRDST.GT.0)[
            {  0          DO IM=1,NMED[
            {  0              ZBRANG(IM)=0.0;PZNORM=0.0;
            {  0              DO IE=1,NNE(IM)[
            {  0                  ZBRANG(IM)=
            {  0                    ZBRANG(IM)+PZ(IM,IE)*ZELEM(IM,IE)*(ZELEM(IM,IE)+1.0);
            {  0                  PZNORM=PZNORM+PZ(IM,IE);
            {  0                  ]
            {  0                  ZBRANG(IM)=(8.116224E-05)*(ZBRANG(IM)/PZNORM)**(1./3.);
            {  0              ]
            {  0          ]
            {  0  }
               0  ;
               0  "THRESHOLD BELOW WHICH ONLY LOWEST ORDER ANGULAR DISTRIBUTION OF THE  "
               0  "PAIR ANGLE IS EMPLOYED. SCALE IS ENERGY (MeV).                       "
               0  "USERS MAY OVERRIDE THIS WITH A HIGHER VALUE BUT A LOWER VALUE WILL   "
               0  "CAUSE NON-PHYSICAL SAMPLING                                          "
               0  "                                                                     "
               0  REPLACE {$BHPAIR} WITH {4.14}
               0  ;
               0  "THIS MACRO ENABLES VERY SMALL ANGLE SAMPLING TO BE     "
               0  "ACCUMULATED. THE LIMIT OF 1.0E-10 BREAKS DOWN AROUND   "
               0  "50 GEV OR SO (THETA=RM/E, FOR BOTH PAIR AND BREM).     "
               0  "THIS MACRO REPLACES CODE IN UPHI AND IN THE PRESTA     "
               0  "MACROS FOR THE LATERAL CORRELATION PART $PRESTA-LCDV.  "
               0  ;
               0  REPLACE {(SINPS2.LT.1.0E-10)} WITH {(SINPS2.LT.1.0E-20)}
               0  ;
               0  "THE FOLLOWING REPLACES THE EGS4 DEFAULT $SET-PAIR-ANGLE MACRO    "
               0  "IT'S USE REQUIRES AN ASSOCIATE MACRO $SET-PAIR-REJECTION-FUNCTION"
               0  "DEFINED BELOW                                                    "
               0  "                                                                 "
               0  "USAGE: IPRDST=0 => EGS4 DEFAULT ANGLE SELECTION                  "
               0  "       IPRDST=1 => LOWEST ORDER ANGULAR DISTRIBUTION             "
               0  "                                                                 "
               0  "              d(Probability)            sin(theta)               "
               0  "              -------------- = -------------------------------   "
               0  "                 d(theta)      2*P*[E_total - P*cos(theta)]**2   "
               0  "                                                                 "
               0  "       IPRDST=2 => MOTZ, OLSEN AND KOCH (1969) EQ. 3D-2003       "
               0  "                   IF IPRDST IS NON-ZERO AND E_PHOTON < $BHPAIR  "
               0  "                   THE IPRDST=1 DISTRIBUTION IS USED             "
               0  "                                                                 "
               0  REPLACE {$SET-PAIR-ANGLE;} WITH {;
            {  0      IF( iprdst > 0 ) [
            {  0          IF( iprdst = 4 ) [
            {  0              $RANDOMSET rtest;
            {  0              "gbeta = (1-rmt2/eig)**8;"
            {  0              gbeta = PESE1/(PESE1+10);
            {  0              IF( rtest < gbeta ) [ iprdst_use = 1; ]
            {  0              ELSE [ iprdst_use = 4; ]
            {  0          ]
            {  0          ELSEIF ( iprdst = 2 & eig < $BHPAIR ) [ iprdst_use = 1; ]
            {  0          ELSE [ iprdst_use = iprdst; ]
            {  0          DO ichrg = 1,2 [
            {  0              IF(ICHRG.EQ.1)[ESE=PESE1;]ELSE[
            {  0                  ESE=ESE2;
            {  0                  IF( iprdst = 4 ) [
            {  0                      gbeta = ESE/(ESE+10);
            {  0                      $RANDOMSET rtest;
            {  0                      IF( rtest < gbeta ) [ iprdst_use = 1; ]
            {  0                      ELSE [ iprdst_use = 4; ]
            {  0                  ]
            {  0              ]
            {  0              IF( iprdst_use = 1 ) [
            {  0                  PSE=SQRT(MAX(0.0,(ESE-RM)*(ESE+RM)));
            {  0                  $RANDOMSET COSTHE;COSTHE=1.0-2.0*COSTHE;
            {  0                  SINTHE=RM*SQRT((1.0-COSTHE)*(1.0+COSTHE))/(PSE*COSTHE+ESE);
            {  0                  COSTHE=(ESE*COSTHE+PSE)/(PSE*COSTHE+ESE);
            {  0              ]
            {  0              ELSE IF( iprdst_use = 2 ) [
            {  0                  "ZBRANG=( (1/111)*Zeff**(1/3) )**2"
            {  0                  ZTARG=ZBRANG(MEDIUM);
            {  0                  "TTEIG=TOTAL INITIAL PHOTON ENERGY IN ELECTRON REST MASS UNITS"
            {  0                  TTEIG=EIG/RM;
            {  0                  "TTESE=TOTAL FINAL ELECTRON ENERGY IN ELECTRON REST MASS UNITS"
            {  0                  TTESE=ESE/RM;
            {  0                  "TTPSE=TOTAL FINAL ELECTRON MOMENTUM IN rm UNITS"
            {  0                  TTPSE=SQRT((TTESE-1.0)*(TTESE+1.0));
            {  0                  "THIS IS THE RATIO (r IN PIRS0287)"
            {  0                  ESEDEI=TTESE/(TTEIG-TTESE);
            {  0                  ESEDER=1.0/ESEDEI;
            {  0                  "DETERMINE THE NORMALIZATION "
            {  0                  XIMIN=1.0/(1.0+(3.141593*TTESE)**2);
            {  0                  $SET-PAIR-REJECTION-FUNCTION(REJMIN,XIMIN);
            {  0                  YA=(2.0/TTEIG)**2;
            {  0                  XITRY=MAX(0.01,MAX(XIMIN,MIN(0.5,SQRT(YA/ZTARG))));
            {  0                  GALPHA=1.0+0.25*LOG(YA+ZTARG*XITRY**2);
            {  0                  GBETA=0.5*ZTARG*XITRY/(YA+ZTARG*XITRY**2);
            {  0                  GALPHA=GALPHA-GBETA*(XITRY-0.5);
            {  0                  XIMID=GALPHA/(3.0*GBETA);
            {  0                  IF(GALPHA.GE.0.0)[
            {  0                      XIMID=0.5-XIMID+SQRT(XIMID**2+0.25);
            {  0                  ]
            {  0                  ELSE[
            {  0                      XIMID=0.5-XIMID-SQRT(XIMID**2+0.25);
            {  0                  ]
            {  0                  XIMID=MAX(0.01,MAX(XIMIN,MIN(0.5,XIMID)));
            {  0                  $SET-PAIR-REJECTION-FUNCTION(REJMID,XIMID);
            {  0                  "ESTIMATE MAXIMUM OF THE REJECTION FUNCTION"
            {  0                  "FOR LATER USE BY THE REJECTION TECHNIQUE  "
            {  0                  REJTOP=1.02*MAX(REJMIN,REJMID);
            {  0                  LOOP[
            {  0                      $RANDOMSET XITST;
            {  0                      $SET-PAIR-REJECTION-FUNCTION(REJTST,XITST);
            {  0                      $RANDOMSET RTEST;
            {  0                      "CONVERT THE SUCCESSFUL CANDIDATE XITST TO AN ANGLE"
            {  0                      THETA=SQRT(1.0/XITST-1.0)/TTESE;
            {  0                      "LOOP UNTIL REJECTION TECHNIQUE ACCEPTS XITST"
            {  0                      REJTST_on_REJTOP   = REJTST/REJTOP;
            {  0                  ]UNTIL((RTEST <= REJTST_on_REJTOP) & (THETA < PI) );
            {  0                  SINTHE=SIN(THETA);COSTHE=COS(THETA);
            {  0              ]
            {  0              ELSE IF( iprdst_use = 3 ) [
            {  0                  $RANDOMSET COSTHE;COSTHE=1.0-2.0*COSTHE;
            {  0                  sinthe=(1-costhe)*(1+costhe);
            {  0                  IF( sinthe > 0 ) [ sinthe = sqrt(sinthe); ] ELSE [ sinthe = 0; ]
            {  0              ]
            {  0              ELSE [
            {  0                  "PSE=SQRT(MAX(1e-10,(ESE-RM)*(ESE+RM)));"
            {  0                  "$RANDOMSET costhe;"
            {  0                  "costhe=(ese-(ese+pse)*exp(-2*costhe*log((ese+pse)/rm)))/pse;"
            {  0                  $RANDOMSET costhe;
            {  0                  costhe=1-2*sqrt(costhe);
            {  0                  sinthe=(1-costhe)*(1+costhe);
            {  0                  IF( sinthe > 0 ) [ sinthe=sqrt(sinthe); ] ELSE [ sinthe=0; ]
            {  0              ]
            {  0              IF( ichrg = 1 ) [CALL UPHI(2,1);]
            {  0              ELSE [ sinthe=-sinthe; NP=NP+1; CALL UPHI(3,2); ]
            {  0          ]
            {  0          iq(np) = iq2; iq(np-1) = iq1; return;
            {  0      ]
            {  0      ELSE[
            {  0          THETA=0; "THETA=RM/EIG; "
            {  0      ]
            {  0  }
               0  ;
               0  "THIS IS THE FUNCTION d[G(XI)]/(d XI) OF PIRS0287    "
               0  "THE RESULT IS RETURNED IN {P1} AS A FUNCTION OF {P2}"
               0  "I.E. {P1}=G({P2}) WHERE {P2}=XI                     "
               0  "                                                    "
               0  REPLACE {$SET-PAIR-REJECTION-FUNCTION(#,#);} WITH {
            {  0  ; {P1} = 2.0+3.0*(ESEDEI+ESEDER) -
            {  0          4.00*(ESEDEI+ESEDER+1.0-4.0*({P2}-0.5)**2)*(
            {  0              1.0+0.25*LOG(
            {  0                  ((1.0+ESEDER)*(1.0+ESEDEI)/(2.*TTEIG))**2+ZTARG*{P2}**2
            {  0                  )
            {  0              )
            {  0          ;
            {  0  }
               0  ;
               0
               0  REPLACE {$SELECT-LOW-ENERGY-PAIR-PRODICTION;} WITH
               0  {
            {  0    $RANDOMSET RNNO30; $RANDOMSET rnno34;
            {  0    PESE2 = PRM + 0.5*RNNO30*(PEIG-2*PRM); PESE1 = PEIG - PESE2;
            {  0    IF( rnno34 < 0.5 ) [ iq1 = -1; iq2 = 1; ] ELSE [ iq1 = 1; iq2 = -1; ]
            {  0  }
               0  " IK introduced this macro because uniform energy distribution"
               0  " is probably a better approximation than a zero energy 'electron'"
               0  " for low energy pair production"
               0
               0  ;
               0
               0  "THIS MACRO EXCHANGES TWO POSITIONS ON THE STACK"
               0  "NB: LATCH IS A NON-STANDARD STACK VARIABLE     "
               0  "    REMOVE IT IF IT CAUSES PROBLEMS            "
               0  "                                               "
               0  REPLACE {$EXCHANGE-STACK(#,#);} WITH {
            {  0  ;
            {  0  FDUMMY = U({P2});     U({P2})     = U({P1});     U({P1})     = FDUMMY;
            {  0  FDUMMY = V({P2});     V({P2})     = V({P1});     V({P1})     = FDUMMY;
            {  0  FDUMMY = W({P2});     W({P2})     = W({P1});     W({P1})     = FDUMMY;
            {  0  FDUMMY = E({P2});     E({P2})     = E({P1});     E({P1})     = FDUMMY;
            {  0  FDUMMY = WT({P2});    WT({P2})    = WT({P1});    WT({P1})    = FDUMMY;
            {  0  IDUMMY = IQ({P2});    IQ({P2})    = IQ({P1});    IQ({P1})    = IDUMMY;
            {  0  "LATCH IS NOW STANDARD"
            {  0  IDUMMY = LATCH({P2}); LATCH({P2}) = LATCH({P1}); LATCH({P1}) = IDUMMY;
            {  0  }
               0  ;
               0
               0  REPLACE {;OUTPUT61#;#;} WITH {
            {  0  "       ==============="
            {  0  ;{SETR A=@LG}
            {  0  WRITE(6,{COPY A}){P1};WRITE(1,{COPY A}){P1};{COPY A}FORMAT{P2};}
               0  ;
               0
               0  " The following macro provides a second order evaluation of the   "
               0  " stopping power. The parameter is half of the initial estimate of"
               0  " the energy loss fraction. IK Oct 97                             "
               0  REPLACE {$RE-EVALUATE-DEDX(#);} WITH
               0  {
            {  0  ;
            {  0    elktmp = elke + Log(1 - {P1});
            {  0    $SET INTERVAL elktmp,eke;
            {  0    lelktmp = max(1,lelktmp);
            {  0    IF(lelec < 0)[$EVALUATE dedxmid USING ededx(elktmp);]
            {  0    ELSE         [$EVALUATE dedxmid USING pdedx(elktmp);]
            {  0    dedx = rhof*dedxmid*(1+0.17408298*({P1}/(1-{P1})/(eke+PRM))**2);
            {  0                     "0.17408298 is 2/3*m**2"
            {  0    {P1} = 2*{P1};
            {  0  }
               0
               0  ; "BUFFER FLUSH"
               0
               0
1              0  %E    "egsnrc.macros"
               0  "******************************************************************"
               0  "                                                                  "
               0  "       transport algorithm related stuff                          "
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  "Macros to denote the various transport algorithms"
               0  "These numbers just have to be distinct"
               0  "Note that the distributed version of EGSnrc does not include the VMC option"
               0  REPLACE {$PRESTA-II} WITH {0}
               0  REPLACE {$PRESTA--I} WITH {1}
               0  REPLACE {$VMC}       WITH {2}
               0
               0  REPLACE {$CALL-USER-ELECTRON} WITH {;}
               0
               0  ;
               0  REPLACE {$MSCAT-DATAFILE} WITH {i_mscat}
               0    "Fortran unit number used to read in new MS"
               0  ;
               0  REPLACE {$RANDOMIZE-TUSTEP} WITH {.false.}
               0    "Switches tustep randomization off"
               0  ;
               0  REPLACE {$SKIN-DEPTH-FOR-BCA} WITH {3}
               0  ;
               0  REPLACE {$PRESTA-DEBUG} WITH {.false.}
               0  ;
               0  REPLACE {$EXACT-BCA-XIMAX} WITH {0.5}
               0  ;
               0  REPLACE {$INEXACT-BCA-XIMAX} WITH {0.5} "this is not realy neccessary, "
               0                                          "it remained from Alex's coding"
               0  ;
               0  REPLACE {$MAX-ELOSS} WITH {0.25}
               0  ;
               0  REPLACE {$SUBSTEP-ELOSS-EVALUATION} WITH {.false.}
               0  ;
               0  REPLACE {$MAX-SMAX} WITH {1e10}
               0  ;
               0  REPLACE {$GLOBAL-ECUT} WITH {0.}
               0  ;
               0  REPLACE {$GLOBAL-PCUT} WITH {0.}
               0  ;
               0  REPLACE {$IBRDST-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$IBR-NIST-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$PAIR-NRC-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$TRIPLET-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$IPRDST-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$IBCMP-DEFAULT} WITH {3} "set to norej"
               0  ;
               0  REPLACE {$IEDGFL-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$IPHTER-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$TRANSPORT-ALGORITHM-DEFAULT} WITH {$PRESTA-II}
               0  ;
               0  REPLACE {$BCA-ALGORITHM-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$EXACT-BCA-DEFAULT} WITH {.true.}
               0  ;
               0  REPLACE {$SPIN-EFFECTS-DEFAULT} WITH {.true.}
               0  ;
               0  REPLACE {$IRAYLR-DEFAULT} WITH {1}
               0  ;
               0  REPLACE {$AP-DEFAULT} WITH {-1}
               0  ;
               0  REPLACE {$UP-DEFAULT} WITH {-1}
               0  ;
               0  REPLACE {$XSEC-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$XDATA-DEFAULT} WITH {'xcom'}
               0  ;
               0  REPLACE {$COMP-XDATA-DEFAULT} WITH {'default'}
               0  ;
               0  "EADL relaxation is now the default"
               0  REPLACE {$EADL-RELAX-DEFAULT} WITH {.true.}
               0  ;
               0  "Sabbatucci and Salvat PE xsections not the default yet"
               0  REPLACE {$MCDF-PE-DEFAULT} WITH {.false.}
               0  ;
               0  "Ali:photonuc, 2 lines"
               0  REPLACE {$IPHOTONUCR-DEFAULT} WITH {0}
               0  ;
               0  REPLACE {$PHOTONUC-XDATA-DEFAULT} WITH {'default'}
               0  ;
               0  "EMH:emf, 7 lines"
               0  REPLACE {$ExDEF} WITH {0}
               0  ;
               0  REPLACE {$EyDEF} WITH {0}
               0  ;
               0  REPLACE {$EzDEF} WITH {0}
               0  ;
               0  REPLACE {$BxDEF} WITH {0}
               0  ;
               0  REPLACE {$ByDEF} WITH {0}
               0  ;
               0  REPLACE {$BzDEF} WITH {0}
               0  ;
               0  REPLACE {$EMLMTDEF} WITH {0.02}
               0  ;
               0
               0              "This macro sets the minimum step size for a condensed"
               0              "history (CH) step. When the exact BCA is used, the minimum"
               0              "CH step is determined by efficiency considerations only"
               0              "At about 3 elastic MFP's single scattering becomes more"
               0              "efficient than CH and so the algorithm switches off CH"
               0              "If one of the various inexact BCA's is invoked, this macro"
               0              "provides a simple way to include more sophisticated"
               0              "decisions about the maximum acceptable approximated CH step"
               0
               0  "The parameters passed to the macro in ELECTR are  eke and elke "
               0
               0  REPLACE {$SET-SKINDEPTH(#,#);} WITH
               0  "        =================                  "
               0  {
            {  0     $CALCULATE-ELASTIC-SCATTERING-MFP(ssmfp,{P1},{P2});
            {  0     skindepth = skindepth_for_bca*ssmfp;
            {  0  }
               0  ;
               0
               0  "This macro calculates the elastic scattering MFP"
               0  "If spin_effects is .false., the screened Rutherford cross section"
               0  "is used, else the the elastic MFP is based on PWA cross sections"
               0
               0  REPLACE {$CALCULATE-ELASTIC-SCATTERING-MFP(#,#,#);} WITH
               0  "        =======================================           "
               0  {
            {  0      blccl = rhof*blcc(medium);
            {  0      xccl  = rhof*xcc(medium);
            {  0      p2 = {P2}*({P2}+rmt2); beta2 = p2/(p2 + rmsq);
            {  0      IF ( spin_effects ) [
            {  0        IF(lelec < 0) [ $EVALUATE etap USING etae_ms({P3}); ]
            {  0        ELSE          [ $EVALUATE etap USING etap_ms({P3}); ]
            {  0        $EVALUATE ms_corr USING blcce({P3});
            {  0        blccl = blccl/etap/(1+0.25*etap*xccl/blccl/p2)*ms_corr;
            {  0      ]
            {  0      {P1}=beta2/blccl;
            {  0  }
               0  ;
               0
               0  REPLACE {$SINGLE-SCATTERING(#);} WITH
               0  "        ======================                     "
               0  {
            {  0      $SET-SCREENING-ANGLE({P1});
            {  0      call sscat(chia2,costhe,sinthe);
            {  0  }
               0  ;
               0
               0  "The following macro will allow the use of better single scattering"
               0  "cross sections (PWA) and/or to take into account double counting  "
               0  "of the contribution of atomic electrons to the scattering power   "
               0
               0  REPLACE {$SET-SCREENING-ANGLE(#);} WITH
               0  "        ========================                   "
               0  {
            {  0      chia2   = xcc(medium)/(4*{P1}*({P1} + rmt2)*blcc(medium));
            {  0  }
               0  ;
               0
               0  REPLACE {$HARD-SCATTERING;} WITH {;}
               0  ;
               0
               0  REPLACE {$TURN_OFF_SCATTERING} WITH {;}
               0  ;
               0  "If the above is redefined in a user code or uncommented here                 "
               0  "REPLACE {$TURN_OFF_SCATTERING} WITH {;cost = 1.000; sint = 0.000; return;}   "
               0  "this will turn off all single and multiple scattering                        "
               0  "DR April 2012   see corresponding 2 additions to egsnrc,mortran in           "
               0  "                subroutines sscat and mscat
               0
1              0  %E "egsnrc.macros"
               0
               0  REPLACE {$CALL-HOWFAR-IN-ELECTR;} WITH {;
            {  0    IF(callhowfar | wt(np) <= 0) [ call howfar; ]
            {  0  };
               0
               0  REPLACE {$CALL-HOWFAR-IN-PHOTON;} WITH {;
            {  0    IF( ustep > dnear(np) | wt(np) <= 0 ) [ call howfar; ]
            {  0  };
               0
               0  REPLACE {$CALL-HOWNEAR(#);} WITH
               0  {
            {  0      OUTPUT 35; "35 in decimal is ascii code for the pound sign"
            {  0      (
            {  0          ' '/
            {  0          ' '/
            {  0          ' ***************************************************************'/
            {  0          ' ***************************************************************'/
            {  0          ' '/
            {  0          ' PRESTA-II is aborting execution because you have not defined   '/
            {  0          ' the HOWNEAR macro for your geometry.                           '/
            {  0          ' '/
            {  0          ' You MUST either do so or employ a limited form of PRESTA-II    '/
            {  0          ' which does not attempt the refined boundary crossing or lateral'/
            {  0          ' correlation features of the algorithm.                         '/
            {  0          ' '/
            {  0          ' If you include the following macro in your usercode:           '/
            {  0          ' '/
            {  0          ' REPLACE {$CALL-HOWNEAR(',a,');} WITH {;}                       '/
            {  0          ' '/
            {  0          ' you can choose between single scattering mode (very slow) and  '/
            {  0          ' standard EGS4 mode (no PRESTA enhancments) by the appropriate  '/
            {  0          ' choice of the parameters in your input file (see the PRESTA-II '/
            {  0          ' manual)                                                        '/
            {  0          ' '/
            {  0          ' ***************************************************************'/
            {  0          ' ***************************************************************'/
            {  0          ' '/
            {  0          ' '/
            {  0      );
            {  0      stop;
            {  0  }
               0
               0  "For compability with user codes with PRESTA-I implemented"
               0  REPLACE {$PRESTA-INPUT-SUMMARY;} WITH {;}
               0  REPLACE {$PRESTA-INPUTS;}        WITH {;}
               0
               0  "If you want to read P-II inputs using the get_input() routine by "
               0  "A. Merovitz and D.W.O.R. you need to either place the following  "
               0  "three macros at the top of your user code, or after the default"
               0  "definitions given below"
               0
               0  ;
               0
               0  REPLACE {$USE-GET-INPUTS} WITH {.true.} "To not use get_input replace this "
               0                                          "with .false.                      "
               0
               0  "The following are the ones used by default"
               0
               0
               0  REPLACE {$USE-GET-INPUTS} WITH {.false.}
               0
               0
               0  ;
1              0  %E    "egsnrc.macros"
               0
               0  "Macro for azimuthal angle selection
               0  "using a sampling within a box method
               0  "Choose a point randomly within a box such that
               0  "-1 <= x <= 1 and 0 <= y < = 1
               0  "Reject the set if it lies without the inscribed unit semicircle centered
               0  "at (x,y) = (0,0)
               0  "once out of the loop, use the trigonimetric relations (TeX notation)
               0  "\cos 2\phi = (x^2 - y^2)/(x^2 + y^2)
               0  "\sin 2\phi = 2xy/(x^2 + y^2)
               0  REPLACE {$SELECT-AZIMUTHAL-ANGLE(#,#);} WITH
               0  {
            {  0  ;
            {  0  LOOP
            {  0  [
            {  0      $RANDOMSET xphi;
            {  0      xphi  = 2*xphi - 1;
            {  0      xphi2 = xphi*xphi;
            {  0      $RANDOMSET yphi;
            {  0      yphi2  = yphi*yphi;
            {  0      rhophi2 = xphi2 + yphi2;
            {  0  ]WHILE(rhophi2 > 1);
            {  0  rhophi2 = 1/rhophi2;
            {  0  {P1}  = (xphi2 - yphi2)*rhophi2;
            {  0  {P2}  = 2*xphi*yphi*rhophi2;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;} WITH {;
            {  0    $REAL xphi,xphi2,yphi,yphi2,rhophi2;
            {  0  };
               0
1              0  %E     "egsnrc.macros"
               0  "************************************************************************"
               0  "                                                                        "
               0  "                 Definitions of local variables                         "
               0  "                                                                        "
               0  "************************************************************************"
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-ANNIH;} WITH
               0  {;
            {  0  "Local variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0        PAVIP,    "precise total energy in the laboratory frame"
            {  0        PESG1,    "precise energy of 1st annihilation photon"
            {  0        PESG2;    "precise energy of 2nd annihilation photon"
            {  0  $REAL AVIP,     "total energy in the laboratory frame"
            {  0        A,        "total energy in units of the electron's rest energy"
            {  0        G,T,P,    "energy, kinetic energy and momentum in units of RM"
            {  0        POT,      "P/T"
            {  0        EP0,      "minimum fractional energy"
            {  0        WSAMP,    "to avoid un-necessary calc. of Log((1-ep0)/ep0)"
            {  0        RNNO01,   "random numbers"
            {  0        RNNO02,
            {  0        EP,       "fractional energy of the more energetic photon"
            {  0        REJF,     "rejection function"
            {  0        ESG1,     "energy of the more energetic photon"
            {  0        ESG2,     "energy of the less energetic photon"
            {  0        aa,bb,cc,sinpsi,sindel,cosdel,us,vs,cphi,sphi;
            {  0                  "for inline rotations"
            {  0  $INTEGER
            {  0        ibr;
            {  0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-BHABHA;} WITH
               0  {;
            {  0  "Local variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0        PEIP,     "precise total energy of incident positron"
            {  0        PEKIN,    "precise kinetic energy of incident positron"
            {  0        PEKSE2,   "precise kinetic energy of second 'electron'"
            {  0        PESE1,    "precise total energy of first 'electron'"
            {  0        PESE2,    "precise total energy of second 'electron'"
            {  0        H1,       "used in direction cosine calculations"
            {  0        DCOSTH;   "polar scattering angle for more energetic 'electron'"
            {  0  $REAL EIP,      "total energy of incident positron"
            {  0        EKIN,     "kinetic energy of incident positron"
            {  0        T0,       "kinetic energy of incident positron in units of RM"
            {  0        E0,       "total energy of incident positron in units of RM"
            {  0        E02,      "E0**2"
            {  0        YY,       "1/(T0+2)"
            {  0        Y2,YP,YP2,"various functions of YY"
            {  0        BETA2,    "incident positron velocity in units of c"
            {  0        EP0,      "minimum fractional energy of a secondary 'electron'"
            {  0        EP0C,     "1-EP0"
            {  0        B1,B2,B3,B4,  "used in rejection function calculation"
            {  0        RNNO03,RNNO04,"random numbers"
            {  0        BR,       "kinetic energy fraction of the 2nd 'electron'"
            {  0        REJF2,    "rejection function"
            {  0        ESE1,     "total energy of 1st 'electron'"
            {  0        ESE2;     "total energy of 2nd 'electron'"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-BREMS;} WITH
               0  {;
            {  0  "Local variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0    PEIE,   "precise incident electron energy"
            {  0    PESG,   "presice energy of emitted photon"
            {  0    PESE;   "precise total energy of scattered electron"
            {  0  $REAL
            {  0    EIE,    "total incident electron energy"
            {  0    EKIN,   "kinetic incident energy"
            {  0    brmin,  " ap(medium)/ekin"
            {  0    waux,   "for faster sampling of 1/br"
            {  0    aux,    "ese/eie"
            {  0    r1,     "a random number"
            {  0    ajj,    "for energy bin determination if alias sampling is employed"
            {  0    alias_sample1,
            {  0    RNNO06, "random number"
            {  0    RNNO07, "random number"
            {  0    BR,     "energy fraction of secondary photon"
            {  0    ESG,    "energy of secondary photon"
            {  0    ESE,    "total energy of secondary electron"
            {  0    DELTA,  "scaled momentum transfer"
            {  0    phi1,   "screening function"
            {  0    phi2,   "screening function"
            {  0    REJF;   "screening rejection function"
            {  0
            {  0  "Brems angle selection variables"
            {  0  $REAL
            {  0    a,b,c,  "direction cosines of incident `electron'"
            {  0    sinpsi, sindel, cosdel, us, vs,
            {  0            "all used for rotations"
            {  0    ztarg,  "(Zeff**1/3/111)**2, used for 2BS angle sampling"
            {  0    tteie,  "total energy in units of rest energy"
            {  0    beta,   "electron velocity in units of speed of light"
            {  0    y2max,  "maximum possible scaled angle"
            {  0    y2maxi, "inverse of the above"
            {  0    ttese,  "new electron energy in units of rm"
            {  0    rjarg1,rjarg2,rjarg3,rejmin,rejmid,rejmax,rejtop,rejtst,
            {  0            "all of them used for angle rejection function calcs"
            {  0    esedei, "new total energy over old total energy"
            {  0    y2tst,  "scaled angle, costhe = 1 - 2*y2tst/y2max"
            {  0    y2tst1,
            {  0    rtest,  "random number for rejection"
            {  0    xphi,yphi,xphi2,yphi2,rhophi2,cphi,sphi;
            {  0            "all of the above is for azimuthal angle sampling"
            {  0
            {  0  $INTEGER
            {  0    L,L1,ibr,jj,j;
            {  0
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-VARIABLES-FOR-SET-BREMS-ANGLE;} WITH
               0  {;
            {  0  "Local variables for photon angle selection"
            {  0  $REAL ZTARG,  "( (1/111)*Zeff**(1/3) )**2"
            {  0        TTEIE,  "total incident electron energy in units of RM"
            {  0        TTESE,  "total scattered electron energy in units of RM"
            {  0        ESEDEI, "TTESE/TTEIE"
            {  0        beta,   "electron speed in units of c"
            {  0        Y2MAX,  "maximum value of the scaled angle"
            {  0        RJARG1,RJARG2,RJARG3,
            {  0                "arguments for which the rejection function is calculated"
            {  0        REJMIN,REJMID,REJMAX,
            {  0                "corresponding values of the rejection function"
            {  0        REJTOP, "max(REJMIN,REJMID,REJMAX)"
            {  0        Y2TST,  "random number and candidate for a scaled angle"
            {  0        REJTST, "rejection function at Y2TST"
            {  0        Y2TST1, "aux. variable for rejection function calculation"
            {  0        REJTST_on_REJTOP  ,  "ratio for rejection test"
            {  0        RTEST;  "random number for rejection"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-COMPT;} WITH
               0  {;
            {  0  "Local COMPT variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0        PEIG,   "precise energy of incident photon"
            {  0        PESG,   "precise energy of scattered photon"
            {  0        PESE;   "precise total energy of compton electron"
            {  0  $REAL ko,     "energy of incident photon in units of RM"
            {  0        broi,   "1+2*ko"
            {  0        broi2,  "broi*broi"
            {  0        bro,    "1/broi"
            {  0        bro1,   "1-bro"
            {  0        alph1,  "probability for the 1/BR part"
            {  0        alph2,  "probability for the BR part"
            {  0        alpha,  "alpha1/(alph1+alph2)"
            {  0        rnno15,rnno16,rnno17,rnno18,rnno19,
            {  0                "random numbers"
            {  0        br,     "scattered photon energy fraction"
            {  0        temp,   "aux. variable for polar angle calculation"
            {  0        rejf3,  "rejection function"
            {  0        rejmax, "max. of rejf3 in thge case of uniform sampling"
            {  0        Uj,     "binding energy of the selected shell"
            {  0        Jo,     "the Compton profile parameter"
            {  0        br2,    "br*br"
            {  0        fpz,fpz1,"used for limited pz-range rejection"
            {  0        qc,     "momentum transfer corresponding to the Compton line energy"
            {  0        qc2,    "qc squared"
            {  0        af,     "for calculating F"
            {  0        Fmax,   "maximum of F"
            {  0        frej,   "used for F-rejection"
            {  0        eta_incoh, eta, "random numbers"
            {  0        aux,aux1,aux2,aux3,aux4, "aux. variables"
            {  0        pzmax,  "max. possible z-component of the initial electron momentum"
            {  0        pz,     "initial electron momentum projection"
            {  0        pz2,    "pz*pz"
            {  0        rnno_RR;"for playing Russian Roulette"
            {  0  $INTEGER
            {  0        irl,    "local region number"
            {  0        i,      "loop variable for shell sampling (and then shell sampled)"
            {  0        j,      "pointer to the shell in the shell data list"
            {  0        iarg,   "argument for ausgab call"
            {  0        ip;     "a loop variable"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-COMPT-old;} WITH
               0  {;
            {  0  "Local COMPT variables in order of appearance"
            {  0  $ENERGY PRECISION
            {  0        PEIG,   "precise energy of incident photon"
            {  0        PESG,   "precise energy of scattered photon"
            {  0        PESE;   "precise total energy of compton electron"
            {  0  $REAL ko,     "energy of incident photon in units of RM"
            {  0        broi,   "1+2*ko"
            {  0        broi2,  "broi*broi"
            {  0        bro,    "1/broi"
            {  0        bro1,   "1-bro"
            {  0        alph1,  "probability for the 1/BR part"
            {  0        alph2,  "probability for the BR part"
            {  0        alpha,  "alpha1/(alph1+alph2)"
            {  0        rnno15,rnno16,rnno17,rnno18,rnno19,
            {  0                "random numbers"
            {  0        br,     "scattered photon energy fraction"
            {  0        temp,   "aux. variable for polar angle calculation"
            {  0        rejf3,  "rejection function"
            {  0        rejmax, "max. of rejf3 in thge case of uniform sampling"
            {  0        Uj,     "binding energy of the selected shell"
            {  0        br2,    "br*br"
            {  0        aux,aux1,aux2,"aux. variables"
            {  0        pzmax2, "max. possible momentum transfer squared"
            {  0        pz,     "momentum transfer prejection"
            {  0        pz2,    "pz*pz"
            {  0        rnno_RR;"for playing Russian Roulette"
            {  0  $INTEGER
            {  0        irl,    "local region number"
            {  0        i,      "loop variable for shell sampling (and then shell sampled)"
            {  0        j,      "pointer to the shell in the shell data list"
            {  0        iarg,   "argument for ausgab call"
            {  0        ip;     "a loop variable"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-ELECTR;} WITH
               0  {;
            {  0  " Local ELECTR variables"
            {  0  $ENERGY PRECISION "($ENERGY PRECISION means double precision)"
            {  0      demfp,        "differential electron mean free path"
            {  0      peie,         "precise energy of incident electron"
            {  0      total_tstep,  "total path-length to next discrete interaction"
            {  0      total_de      "total energy loss to next discrete interaction"
            {  0  ;
            {  0  $REAL
            {  0      ekems,      "kinetic energy used to sample MS angle (normally midpoint)"
            {  0      elkems,     "Log(ekems)"
            {  0      chia2,      "Multiple scattering screening angle"
            {  0      etap,       "correction to Moliere screening angle from PWA cross sections"
            {  0      lambda,     "number of mean free paths (elastic scattering cross section)"
            {  0      blccl,      "blcc(medium)*rhof"
            {  0      xccl,       "xcc(medium)*rhof"
            {  0      xi,         "used for PLC calculations (first GS moment times path-length)"
            {  0      xi_corr,    "correction to xi due to spin effects"
            {  0      ms_corr,
            {  0      p2,         "electron momentum times c, squared"
            {  0      beta2,      "electron speed in units of c, squared"
            {  0      de,         "energy loss to dedx"
            {  0      save_de,    "de saved before $DE-FLUCTUATION"
            {  0      dedx,       "stopping power after density scaling"
            {  0      dedx0,      "stopping power before density scaling"
            {  0      dedxmid,    "stopping power at mid-step before density scaling"
            {  0      ekei,       "used in $CALCULATE-TSTEP-FROM-DEMFP;"
            {  0      elkei,      "Log(ekei), used in $CALCULATE-TSTEP-FROM-DEMFP;"
            {  0      aux,        "aux. variable"
            {  0      ebr1,       "e- branching ratio into brem"
            {  0      eie,        "energy of incident electron"
            {  0      ekef,       "kinetic energy after a step"
            {  0      elkef,      "Log(ekef)"
            {  0      ekeold,     "kinetic energy before a step"
            {  0      eketmp,     "used to evaluate average kinetic energy of a step"
            {  0      elktmp,     "log(eketmp)"
            {  0      fedep,      "fractional energy loss used in stopping power calculation"
            {  0      tuss,       "sampled path-length to a single scattering event"
            {  0      pbr1,       "e+ branching ratio into brem"
            {  0      pbr2,       "e+ branching ratio into brem or Bhabha"
            {  0      range,      "electron range"
            {  0      rfict,      "rejection function for fictitious cross section"
            {  0      rnne1,      "random number"
            {  0      rnno24,     "random number"
            {  0      rnno25,     "random number"
            {  0      rnnotu,     "random number"
            {  0      rnnoss,     "random number"
            {  0      sig,        "cross section after density scaling but before a step"
            {  0      sig0,       "cross section before density scaling but before a step"
            {  0      sigf,       "cross section before density scaling but after a step"
            {  0      skindepth,  "skin depth employed for PRESTA-II boundary crossing"
            {  0      ssmfp,      "distance of one single elastic scattering mean free path"
            {  0      tmxs,       "electron step-size restriction"
            {  0      tperp,      "perpendicular distance to the closest boundary"
            {  0      ustep0,     "temporary storage for ustep"
            {  0      uscat,      "x-axis direction cosine for scattering"
            {  0      vscat,      "y-axis direction cosine for scattering"
            {  0      wscat,      "z-axis direction cosine for scattering"
            {  0      xtrans,     "final x-axis position after transport"
            {  0      ytrans,     "final y-axis position after transport"
            {  0      ztrans,     "final z-axis position after transport"
            {  0      cphi,sphi;  "for azimuthal angle selection for annih at rest"
            {  0
            {  0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
            {  0
            {  0  $INTEGER
            {  0      iarg,      "calling code for ausgab"
            {  0      idr,       "calling code for ausgab"
            {  0      ierust,    "error counter for negative ustep errors"
            {  0      irl,       "region number"
            {  0      lelec,     "charge of electron"
            {  0      qel,       " = 0 for electrons, = 1 for positrons "
            {  0      lelke,     "index into the energy grid of tabulated functions"
            {  0      lelkems,   "index into the energy grid of tabulated functions"
            {  0      lelkef,    "index into the energy grid of tabulated functions"
            {  0      lelktmp,   "index into the energy grid of tabulated functions"
            {  0      ibr;       "a loop variable"
            {  0
            {  0  $LOGICAL
            {  0      "BCA = boundary crossing algorithm"
            {  0      callhowfar, "= .true.  => BCA requires a call to howfar"
            {  0                  "= .false. => BCA does not require a call to howfar"
            {  0      domultiple, "= .true.  => inexact BCA requires multiple scattering"
            {  0      dosingle,   "= .true.  => exact BCA requires single scattering"
            {  0                  "= .false. => exact BCA requires no single scattering"
            {  0      callmsdist, "= .true.  => normal condensed-history transport"
            {  0                  "= .false. => one of the BCA's will be invoked"
            {  0      findindex,  "used for mscat"
            {  0      spin_index, "used for mscat with spin effects"
            {  0      compute_tstep
            {  0  ;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-HATCH;} WITH
               0  {;
            {  0  "Local HATCH variables in alphabetical order"
            {  0
            {  0  $TYPE MBUF(72),MDLABL(8);
            {  0
            {  0  $REAL
            {  0      ACD   , "used to test goodness of sine-table look-up"
            {  0      ADEV  , "absolute deviation in sine-table look-up"
            {  0      ASD   , "used to test goodness of sine-table look-up"
            {  0      COST  , "cos(theta) from instrinsic library function"
            {  0      CTHET , "use to calculate cos(theta) according to look-up tables"
            {  0      DEL   , "leat squares delta for sine-table look-up"
            {  0      DFACT , "converts rl to dunits"
            {  0      DFACTI, "converts rl**-1 to dunits**-1"
            {  0      DUNITO, "units scaling varable"
            {  0      DUNITR, "saved value of dunit"
            {  0      FNSSS , "real form of integer nsinss"
            {  0      P     , "counter used in the pwr2i(i) = 1/2**(i - 1) construction"
            {  0      PZNORM, "used in $INITIALIZE-BREMS-ANGLE"
            {  0      RDEV  , "relative deviation in sine-table look-up"
            {  0      S2C2  , "sinthe**2 + costhe**2, used to test look-up table"
            {  0      S2C2MN, "min(s2c2)"
            {  0      S2C2MX, "max(s2c2)"
            {  0      SINT  , "sin(theta) from instrinsic library function"
            {  0      SX    , "sum of angles for least squared analysis of look-up table errors"
            {  0      SXX   , "sum**2 of angles for least square analysis of look-up table errors"
            {  0      SXY   , "sum of angle*sin(angle) for least squared analysis of look-up"
            {  0              "table errors"
            {  0      SY    , "sum of sin(angle) for least squared analysis of look-up table "
            {  0              "errors"
            {  0      WID   , "width of sine-table mesh sub-interval (sine-table algorithm)"
            {  0      XS    , "angle value in a sub-sub-interval (sine-table algorithm)"
            {  0      XS0   , "lower limit of a sub-sub-interval (sine-table algorithm)"
            {  0      XS1   , "upwer limit of a sub-sub-interval (sine-table algorithm)"
            {  0      XSI   , "beginning angle of a sun-interval (sine-table algorithm)"
            {  0      WSS   , "width of a sub-sub-interval (sine-table algorithm)"
            {  0      YS    , "sin(angle) for least squared analysis of look-up table errors"
            {  0      ZEROS(3); "zeros of sine, 0,pi,twopi"
            {  0
            {  0  $INTEGER
            {  0      I     , "generic do-loop variable"
            {  0      I1ST  , "flag = 0 on first pass"
            {  0      IB    , "do-loop variable used for reading the medium type"
            {  0      ID    , "integer value of -dunit, when dunit is negative"
            {  0      IE    , "do-loop variable for reading over elements in a compound/mixture"
            {  0      IL    , "do-loop variable used for reading the medium type"
            {  0      IM    , "do-loop variable looping over nmed, number of media"
            {  0      IRAYL , "Rayleigh switch read in from PEGS"
            {  0      IRN   , "do-loop variable over random set of sine-table look-ups"
            {  0      ISTEST, "flag that switches on test of sine function fit"
            {  0      ISUB  , "do-loop variable over sub-intervals of the sine look-up table"
            {  0      ISS   , "do-loop variable over sub-sub-intervals of the sine look-up table"
            {  0      IZ    , "used to locate an exact zero of a sun-interval mesh point in the"
            {  0              "sine-table look-up"
            {  0      IZZ   , "do-loop variable over the exact zeros of the sine-table look-up"
            {  0      J     , "do-loop variable looping over nmed, number of media"
            {  0      JR    , "do-loop variable looping over number of regions"
            {  0      LCTHET, "$SET INTERVAL index for cos(theta) from look-up table"
            {  0      LMDL  , "character width of medium header ' MEDIUM='"
            {  0      LMDN  , "character width of medium description"
            {  0      LTHETA, "$SET INTERVAL index for sin(theta) from look-up table"
            {  0      MD    , "temporary storage for the medium number"
            {  0      MXSINC, "number of intervals approximating the sine function"
            {  0      NCMFP , "array size input from PEGS. Currently 0, but probably intended"
            {  0              "to be cumulative electron mean free path. Presently unused."
            {  0      NEKE  , "array size input from PEGS."
            {  0              "Number of electron mapped energy intervals."
            {  0      NGE   , "array size input from PEGS."
            {  0              "Number of photon mapped energy intervals."
            {  0      NGRIM , "Rayleigh cross section array size."
            {  0      NISUB , "mxsinc - 2. Size of array with endpoints removed."
            {  0      NLEKE , "array size input from PEGS. Currently 0, but probably intended"
            {  0              "to be number of electron energy intervals below threshold."
            {  0              "Presently unused."
            {  0      NM    , "number of media found in the "
            {  0      NRANGE, "array size input from PEGS. Currently 0, but probably intended"
            {  0              "to be number of intervals in an array giving the electron range."
            {  0              "Presently unused."
            {  0      NRNA  , "number of random angles testing sine function fit"
            {  0      NSEKE , "array size input from PEGS. Currently 0, but probably intended"
            {  0              "to be number of electron small energy intervals. Presently unused."
            {  0      NSGE  , "array size input from PEGS. Currently 0, but probably intended"
            {  0              "to be number of gamma small energy intervals. Presently unused."
            {  0      NSINSS, "number of sub-intervals for each sine function interval"
            {  0      LOK($MXMED); "flag indicating that medium has been found in the PEGS "
            {  0                   "datafile"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-MOLLER;} WITH
               0  {;
            {  0  "Local MOLLER variables in order of their appearance"
            {  0
            {  0  $ENERGY PRECISION
            {  0       PEIE,   "precise total energy of incident electron"
            {  0       PEKSE2, "precise kinetic energy of 2nd secondary electron"
            {  0       PESE1,  "precise total energy of 1st secondary electron"
            {  0       PESE2,  "precise total energy of 2nd secondary electron"
            {  0       PEKIN,  "precise kinetic energy of incident electron"
            {  0       H1,     "used for polar scattering angle calculation"
            {  0       DCOSTH; "polar scattering angle squared"
            {  0  $REAL EIE,    "total energy of incident electron"
            {  0       EKIN,   "kinetic energy of incident electron"
            {  0       T0,     "kinetic energy of incident electron in units of RM"
            {  0       E0,     "total energy of incident electron in units of RM"
            {  0       EXTRAE, "energy above the Moller threshold"
            {  0       E02,    "E0**2"
            {  0       EP0,    "minimum alowed kinetic energy fraction"
            {  0       G2,G3,  "used for rejection function calculation"
            {  0       GMAX,   "maximum value of the rejection function"
            {  0       BR,     "kinetic energy fraction to lowew energy electron"
            {  0       R,      "(1-BR)/BR"
            {  0       REJF4,  "rejection function"
            {  0       RNNO27, "random number for BR sampling"
            {  0       RNNO28, "random number for rejection"
            {  0       ESE1,   "energy of 1st secondary electron"
            {  0       ESE2;   "energy of 2nd secondary electron"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-PAIR;} WITH
               0  {;
            {  0  "Local PAIR variables in order of their appearance"
            {  0  $ENERGY PRECISION
            {  0        PEIG,      "precise energy of incident photon"
            {  0        PESE1,     "precise energy of 1st 'electron'"
            {  0        PESE2;     "precise energy of 2nd 'electron'"
            {  0
            {  0  $REAL EIG,       "energy of incident photon"
            {  0        ESE2,      "total energy of lower energy 'electron'"
            {  0        RNNO30,RNNO31,rnno32,rnno33,rnno34,
            {  0                   "random numbers"
            {  0        DELTA,     "scaled momentum transfer"
            {  0        REJF,      "screening rejection function"
            {  0        rejmax,    "the maximum of rejf"
            {  0        aux1,aux2, "auxilary variables"
            {  0        Amax,      "Maximum of the screening function used with (br-1/2)**2"
            {  0        Bmax,      "Maximum of the screening function used with the uniform part"
            {  0        del0,      "delcm*eig"
            {  0        br,        "fraction of the available energy (eig-rmt2) going to the"
            {  0                   "lower energy `electron'"
            {  0        Eminus,Eplus,Eavail,rnno_RR;
            {  0
            {  0  $INTEGER
            {  0        L,L1;  "flags for high/low energy distributions"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-VARIABLES-FOR-SET-PAIR-ANGLE;} WITH
               0  {;
            {  0  $REAL ESE,   "total energy of one of the 'electrons'"
            {  0        PSE,   "momentum corresponding to ESE"
            {  0        ZTARG, "( (1/111)*Zeff**(1/3) )**2"
            {  0        TTEIG, "incident photon energy in units of RM"
            {  0        TTESE, "energy of one of the 'electrons' in units of RM"
            {  0        TTPSE, "momentum of one of the 'electrons' in units of RM"
            {  0        ESEDEI,"TTESE/(TTEIG-TTESE) = ratio of secondary electron energies"
            {  0        ESEDER,"1/ESEDEI"
            {  0        XIMIN, "1st argument where rejection function might have a maximum"
            {  0        XIMID, "2nd argument where rejection function might have a maximum"
            {  0        REJMIN,"rejection function at XIMIN"
            {  0        REJMID,"rejection function at XIMID"
            {  0        REJTOP,"max(REJMIN,REJMID)"
            {  0        YA,XITRY,GALPHA,GBETA,
            {  0               "aux. variables for XIMID calculation"
            {  0        XITST, "random number for pair angle sampling"
            {  0        REJTST_on_REJTOP  ,  "ratio for rejection test"
            {  0        REJTST,"rejection function at XITST"
            {  0        RTEST; "random number for rejection"
            {  0  $INTEGER
            {  0        ICHRG; "loop variable"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTO;} WITH
               0  {;
            {  0  "Local PHOTO variables in order of their appearance"
            {  0
            {  0  $ENERGY PRECISION
            {  0        PEIG;         "precise energy of incident photon"
            {  0  $REAL BR,           "random number"
            {  0        sigma,        "elemental cross section"
            {  0        aux,aux1,     "aux. variables"
            {  0        probs($MXEL), "probability for an interaction with a given element"
            {  0        sigtot,       "total cross section"
            {  0        e_vac,        "shell binding energy"
            {  0        rnno_RR;      "for playing Russian Roulette"
            {  0  $INTEGER
            {  0        IARG,         "AUSGAB calling switch"
            {  0        iZ,           "Atomic number of the element the photon is "
            {  0                      "interactiong with"
            {  0        irl,          "local region number"
            {  0        ints($MXEL),  "energy interval number for a given element"
            {  0        j,ip,         "loop variables"
            {  0        n_warning,    "a warning counter"
            {  0        k;            "shell number"
            {  0
            {  0  $LOGICAL
            {  0        do_relax;
            {  0  save  n_warning;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-VARIABLES-FOR-SELECT-PHOTOELECTRON-DIRECTION;} WITH
               0  {;
            {  0  "Photo-electron angle selection variables"
            {  0  $REAL EELEC, "total energy of photo-electron"
            {  0        BETA,  "velocity of electron in units of c"
            {  0        GAMMA, "total energy of photo-electron in units of RM"
            {  0        ALPHA, "kinematic factor"
            {  0        RATIO, "=BETA/ALPHA"
            {  0        RNPHT, "random number"
            {  0        FKAPPA,"aux. variable for COSTHE calculation"
            {  0        XI,    "used in rejection function calculation"
            {  0        SINTH2,"SINTHE**2"
            {  0        RNPHT2;"random number for rejection"
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-EDGSET;} WITH
               0  {;
            {  0  "Local EDGSET variables in order of their appearance"
            {  0  $REAL EALF(100),EBET(100),OMEG(100),PHOTOK(100),PKA(100);
            {  0        "see the data statements in EDGSETfor definition of these arrays"
            {  0  $INTEGER JJ,IZ,IMED,I;
            {  0  }
               0  ;
               0
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTON;} WITH
               0  {;
            {  0  "Local PHOTON variables in order of their appearance"
            {  0  $ENERGY PRECISION
            {  0      PEIG;   "precise photon energy"
            {  0  ;
            {  0  $REAL
            {  0      EIG,    "photon energy"
            {  0      RNNO35, "random number for default MFP selection"
            {  0      GMFPR0, "photon MFP before density scaling and coherent correction"
            {  0      GMFP,   "photon MFP after density scaling"
            {  0      COHFAC, "Rayleigh scattering correction"
            {  0      RNNO37, "random number for Rayleigh scattering selection"
            {  0      XXX,    "random number for momentum transfer sampling in Rayleigh"
            {  0      X2,     "scaled momentum transfer in Rayleigh scattering event"
            {  0      Q2,     "momentum transfer squared in Rayleigh scattering event"
            {  0      CSQTHE, "COSTHE**2"
            {  0      REJF,   "Rayleigh scattering rejection function"
            {  0      RNNORJ, "random number for rejection in Rayleigh scattering"
            {  0      RNNO36, "random number for interaction branching"
            {  0      GBR1,   "probability for pair production"
            {  0      GBR2,   "probability for pair + compton"
            {  0      T,      "used for particle exchange on the stack"
            {  0  "Ali:photonuc, 2 lines"
            {  0      PHOTONUCFAC, "photonuclear correction"
            {  0      RNNO39; "random number for photonuclear selection (RNNO38 is taken)"
            {  0  ;
            {  0  $INTEGER
            {  0      IARG,   "parameter for AUSGAB"
            {  0      IDR,    "parameter for AUSGAB"
            {  0      IRL,    "region number"
            {  0      LGLE,   "index for GMFP interpolation"
            {  0      LXXX;   "index for Rayleigh scattering cummulative distribution int."
            {  0  }
               0  ;
               0
               0  "Ali:photonuc, 1 block"
               0  REPLACE {$DEFINE-LOCAL-VARIABLES-PHOTONUC;} WITH {;}
               0  ;
               0
               0  " Handling track-ends "
               0  " By default, just call AUSGAB and drop energy on the spot"
               0
               0  REPLACE {$ELECTRON-TRACK-END;} WITH {; $AUSCALL(idr); }
               0  REPLACE {$PHOTON-TRACK-END;}   WITH {; $AUSCALL(IDR); }
               0  ;
               0
               0  " Macros for the fictitious method  "
               0  "==================================="
               0
               0  " The following version uses sub-threshold energy loss "
               0  " as a measure of path-length => cross section is actual "
               0  " cross section divided by restricted stopping power "
               0  " The global maximum of this quantity called esig_e (electrons) or "
               0  " psig_e (positrons) and is determined in HATCH "
               0
               0  REPLACE {$EVALUATE-SIG0;} WITH
               0  "        ==============="
               0  {;
            {  0     IF( sig_ismonotone(qel,medium) ) [
            {  0         $EVALUATE-SIGF; sig0 = sigf;
            {  0     ]
            {  0     ELSE [
            {  0         IF( lelec < 0 ) [sig0 = esig_e(medium);]
            {  0         ELSE            [sig0 = psig_e(medium);]
            {  0     ]
            {  0  }
               0
               0  REPLACE {$EVALUATE-SIGF;} WITH
               0  "        ==============="
               0  {;
            {  0    IF(lelec < 0)
            {  0    [
            {  0        $EVALUATE sigf USING esig(elke);
            {  0        $EVALUATE dedx0 USING ededx(elke);
            {  0        sigf = sigf/dedx0;
            {  0    ]
            {  0    ELSE
            {  0    [
            {  0        $EVALUATE sigf USING psig(elke);
            {  0        $EVALUATE dedx0 USING pdedx(elke);
            {  0        sigf = sigf/dedx0;
            {  0    ]
            {  0  }
               0  ;
               0
               0  REPLACE {$EVALUATE-EBREM-FRACTION;} WITH {
            {  0      $EVALUATE ebr1 USING ebr1(elke);
            {  0  };
               0  REPLACE {$EVALUATE-PBREM-FRACTION;} WITH {
            {  0      $EVALUATE pbr1 USING pbr1(elke);
            {  0  };
               0  REPLACE {$EVALUATE-BHABHA-FRACTION;} WITH {
            {  0      $EVALUATE pbr2 USING pbr2(elke);
            {  0  };
               0
               0
               0  " Because the cross section is interactions per energy loss, no "
               0  " rhof-scaling is required "
               0  REPLACE {$SCALE-SIG0;} WITH
               0  "        ============"
               0  {
            {  0     sig = sig0;
            {  0  }
               0  ;
               0
               0  " Once the sub-threshold processes energy loss to the next discrete "
               0  " interaction is determined, the corresponding path-length has to be"
               0  " calculated. This is done by the macro below. This macro           "
               0  " assumes the energy at the begining to be eke, the logarithm of it "
               0  " elke, lelke - the corresponding interpolation index and makes     "
               0  " use of $COMPUTE-DRANGE(#,#,#,#,#,#)                               "
               0
               0  REPLACE {$CALCULATE-TSTEP-FROM-DEMFP;} WITH
               0  "        ============================"
               0  {;
            {  0    IF( compute_tstep ) [
            {  0      total_de = demfp/sig; fedep = total_de;
            {  0      ekef  = eke - fedep;
            {  0      IF( ekef <= E_array(1,medium) ) [ tstep = vacdst; ]
            {  0      ELSE
            {  0      [
            {  0        elkef = Log(ekef);
            {  0        $SET INTERVAL elkef,eke;
            {  0        IF( lelkef = lelke )
            {  0        [       " initial and final energy are in the same interpolation bin "
            {  0            $COMPUTE-DRANGE(eke,ekef,lelke,elke,elkef,tstep);
            {  0        ]
            {  0        ELSE
            {  0        [   " initial and final energy are in different interpolation bins, "
            {  0            " calc range from ekef to E(lelkef+1) and from E(lelke) to eke  "
            {  0            " and add the pre-calculated range from E(lelkef+1) to E(lelke) "
            {  0            ekei = E_array(lelke,medium);
            {  0            elkei = (lelke - eke0(medium))/eke1(medium);
            {  0            $COMPUTE-DRANGE(eke,ekei,lelke,elke,elkei,tuss);
            {  0            ekei = E_array(lelkef+1,medium);
            {  0            elkei = (lelkef + 1 - eke0(medium))/eke1(medium);
            {  0            $COMPUTE-DRANGE(ekei,ekef,lelkef,elkei,elkef,tstep);
            {  0            tstep=tstep+tuss+
            {  0                    range_ep(qel,lelke,medium)-range_ep(qel,lelkef+1,medium);
            {  0        ]
            {  0      ]
            {  0      total_tstep = tstep;
            {  0      compute_tstep = .false.;
            {  0    ]
            {  0    tstep = total_tstep/rhof;  " non-default density scaling "
            {  0  }
               0  ;
               0
               0  " The following macro computes the path-length traveled while going from  "
               0  " energy {P1} to energy {P2}, both energies being in the same             "
               0  " interpolation bin, given by {P3}. {P4} and {P5} are the logarithms of   "
               0  " {P1} and {P2}. The expression is based on logarithmic interpolation as  "
               0  " used in EGSnrc (i.e. dedx = a + b*Log(E) ) and a power series expansion "
               0  " of the ExpIntegralEi function that is the result of the integration.    "
               0  " The result is returned in {P6}.                                         "
               0
               0  REPLACE {$COMPUTE-DRANGE(#,#,#,#,#,#);} WITH
               0  "        ============================="
               0  {
            {  0    fedep = 1 - {P2}/{P1};
            {  0    elktmp = 0.5*({P4}+{P5}+0.25*fedep*fedep*(1+fedep*(1+0.875*fedep)));
            {  0             " the above evaluates the logarithm of the midpoint energy"
            {  0    lelktmp = {P3};
            {  0    IF(lelec < 0) [
            {  0        $EVALUATE dedxmid USING ededx(elktmp);
            {  0        dedxmid = 1/dedxmid;
            {  0        aux = ededx1(lelktmp,medium)*dedxmid;
            {  0        "aux = ededx1(lelktmp,medium)/dedxmid;"
            {  0    ]
            {  0    ELSE [
            {  0        $EVALUATE dedxmid USING pdedx(elktmp);
            {  0        dedxmid = 1/dedxmid;
            {  0        aux = pdedx1(lelktmp,medium)*dedxmid;
            {  0        "aux = pdedx1(lelktmp,medium)/dedxmid;"
            {  0    ]
            {  0    aux = aux*(1+2*aux)*(fedep/(2-fedep))**2/6;
            {  0    "{P6} = fedep*{P1}/dedxmid*(1+aux);"
            {  0    {P6} = fedep*{P1}*dedxmid*(1+aux);
            {  0  }
               0  ;
               0
               0  " The following macro computes the range to the minimum table energy "
               0  " It uses $COMPUTE-DRANGE                                            "
               0  " Note that range_ep array is precomputed in subroutine mscati and   "
               0  " gives the range from the energy interval end points to AE for each "
               0  " medium.
               0
               0  REPLACE {$COMPUTE-RANGE;} WITH
               0  "        ==============="
               0  {
            {  0  ;
            {  0    ekei = E_array(lelke,medium);
            {  0    elkei = (lelke - eke0(medium))/eke1(medium);
            {  0    $COMPUTE-DRANGE(eke,ekei,lelke,elke,elkei,range);
            {  0    range = (range + range_ep(qel,lelke,medium))/rhof;
            {  0  }
               0  ;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  " The following macro updates demfp. As energy loss is used as the  "
               0  " 'path-length' variable (see above), it just substracts the energy "
               0  " loss for the step.                                                "
               0  REPLACE {$UPDATE-DEMFP;} WITH
               0  "        =============="
               0  {
            {  0    demfp = demfp - save_de*sig;
            {  0    total_de = total_de - save_de;
            {  0    total_tstep = total_tstep - tvstep*rhof;
            {  0    IF( total_tstep < 1e-9 ) [ demfp = 0; ]
            {  0  }
               0  ;
               0
               0  " The following macro computes the energy loss due to sub-threshold "
               0  " processes for a path-length {P1}. The energy at the beginning of  "
               0  " the step is {P2}, {P3}=Log({P2}), {P4} is the interpolation index "
               0  " The formulae are based on the logarithmic interpolation for dedx  "
               0  " used in EGSnrc. The result is returned in {P5}. Assumes that      "
               0  " initial and final energy are in the same interpolation bin.       "
               0
               0  REPLACE {$COMPUTE-ELOSS(#,#,#,#,#);} WITH
               0  "        =========================="
               0  {;
            {  0    IF( lelec < 0 ) [
            {  0        $EVALUATE dedxmid USING ededx({P3});
            {  0        aux = ededx1({P4},medium)/dedxmid;
            {  0    ]
            {  0    ELSE [
            {  0        $EVALUATE dedxmid USING pdedx({P3});
            {  0        aux = pdedx1({P4},medium)/dedxmid;
            {  0    ]
            {  0
            {  0
            {  0
            {  0    {P5} = dedxmid*{P1}*rhof; "IK: rhof scaling bug, June 9 2006"
            {  0                              "rhof scaling must be done here and NOT in "
            {  0                              "$COMPUTE-ELOSS-G below!"
            {  0    fedep = {P5}/{P2};
            {  0    {P5} = {P5}*(1-0.5*fedep*aux*(1-0.333333*fedep*(aux-1-
            {  0               0.25*fedep*(2-aux*(4-aux)))));
            {  0  }
               0  ;
               0
               0  " The following is a generalized version of $COMPUTE-ELOSS.        "
               0
               0  REPLACE {$COMPUTE-ELOSS-G(#,#,#,#,#);} WITH
               0  "        ============================"
               0  {
            {  0    tuss = range - range_ep(qel,{P4},medium)/rhof;
            {  0      " here tuss is the range between the initial energy and the next lower "
            {  0      " energy on the interpolation grid "
            {  0    IF( tuss >= {P1} ) [  " Final energy is in the same interpolation bin "
            {  0        $COMPUTE-ELOSS({P1},{P2},{P3},{P4},{P5});
            {  0
            {  0        "IK: rhof scaling bug, June 9 2006. rhof scaling is done in "
            {  0        "    $COMPUTE-ELOSS above!                                  "
            {  0    ]
            {  0    ELSE [ " Must find first the table index where the step ends using "
            {  0           " pre-calculated ranges                                     "
            {  0        lelktmp = {P4};
            {  0        tuss = (range - {P1})*rhof;
            {  0           " now tuss is the range of the final energy electron "
            {  0           " scaled to the default mass density from PEGS4      "
            {  0        IF( tuss <= 0 ) [ {P5} = {P2} - TE(medium)*0.99; ]
            {  0          " i.e., if the step we intend to take is longer than the particle "
            {  0          " range, the particle energy goes down to the threshold "
            {  0          "({P2} is the initial particle energy)  "
            {  0          "originally the entire energy was lost, but msdist_xxx is not prepared"
            {  0          "to deal with such large eloss fractions => changed July 2005."
            {  0        ELSE [
            {  0            WHILE ( tuss < range_ep(qel,lelktmp,medium) ) [
            {  0                lelktmp = lelktmp - 1; ]
            {  0            elktmp = (lelktmp+1-eke0(medium))/eke1(medium);
            {  0            eketmp = E_array(lelktmp+1,medium);
            {  0            "tuss = range_ep(qel,lelktmp+1,medium) - tuss;"
            {  0            "IK: rhof scaling bug, June 9 2006: because of the change in "
            {  0            "    $COMPUTE-ELOSS above, we must scale tuss by rhof        "
            {  0            tuss = (range_ep(qel,lelktmp+1,medium) - tuss)/rhof;
            {  0            $COMPUTE-ELOSS(tuss,eketmp,elktmp,lelktmp,{P5});
            {  0            {P5} = {P5} + {P2} - eketmp;
            {  0        ]
            {  0    ]
            {  0  }
               0  ;
1              0  %E  "egsnrc.macros"
               0  "============================================================================"
               0  "
               0  "   The following is related to use of the NRC auxilliary get_inputs
               0  "   routine which is part of the standard NRC user-codes.
               0  "
               0  "   It is not an essential part of EGSnrc but is most easily defined here.
               0  "
               0  "============================================================================"
               0  "
               0  " Input stuff for the get_inputs() routine.                                  "
               0  " As the expirience has shown that get_inputs() is frequently used in several"
               0  " subroutines, I changed the parameter passed to get_inputs() to a common    "
               0  " block. Otherwise, the parameters have to be defined in each subroutine using"
               0  " get_inputs() and, with static variables, this lead to a memory use         "
               0  " explosion (e.g. 8 MB for CAVRZ vs. 0.8 MB without get_inputs()!)           "
               0  " IK, Dec. 1998                                                              "
               0
               0  REPLACE {$NMAX} WITH {100};
               0  REPLACE {$NVALUE} WITH {100};
               0  REPLACE {$STRING80} WITH {80};
               0  REPLACE {$STRING32} WITH {64};
               0  REPLACE {$STRING40} WITH {40};
               0  REPLACE {$STRING256} WITH {256};
               0  REPLACE {$MXALINP} WITH {5};
               0
               0  REPLACE {COMIN/GetInput/;} WITH
               0  "        ================"
               0  {
            {  0    ;COMMON/GetInput/
            {  0          ALLOWED_INPUTS($NMAX,0:$MXALINP), "Associates a name with each second "
            {  0                                     "array index(0:4) for a value sought"
            {  0          VALUES_SOUGHT($NMAX),      "Name of each input                 "
            {  0          CHAR_VALUE($NMAX,$NVALUE), "For returning character inputs     "
            {  0          VALUE($NMAX,$NVALUE),      "For returning int. or real inputs  "
            {  0          DEFAULT($NMAX),            "Default value, only for type 0 & 1 "
            {  0          VALUE_MIN($NMAX),          "Min and max value defining         "
            {  0          VALUE_MAX($NMAX),          "the acceptable input range         "
            {  0          NVALUE($NMAX),             "Number of values per value sought  "
            {  0          TYPE($NMAX),               "Type of the value sought           "
            {  0                                     "0 for integer                      "
            {  0                                     "1 for real                         "
            {  0                                     "2 for character                    "
            {  0                                     "3 for character with allowed_inputs"
            {  0          ERROR_FLAGS($NMAX),        "An error flag for each of the      "
            {  0                                     "attempted inputs                   "
            {  0          i_errors,                  "Unit no. for .errors output file   "
            {  0          NMIN, NMAX,                "Minimum and maximum index number of"
            {  0                                     "the values sought                  "
            {  0          ERROR_FLAG,                "0 for no errors, 1 for errors      "
            {  0          DELIMETER;                 "Name of the delimeter              "
            {  0     character ALLOWED_INPUTS*$STRING32,VALUES_SOUGHT*$STRING32,
            {  0               CHAR_VALUE*$STRING80,DELIMETER*$STRING32;
            {  0     $REAL     VALUE,DEFAULT,VALUE_MIN,VALUE_MAX;
            {  0     $INTEGER  NVALUE,TYPE,NMIN,NMAX,ERROR_FLAG,ERROR_FLAGS,i_errors;
            {  0  }
               0  ;
               0
               0  REPLACE {$GET_INPUT(#);} WITH { NMIN = {P1}; NMAX = {P1}; CALL GET_INPUT; }
               0  ;
               0
               0  REPLACE {$GET_INPUTS(#,#);} WITH { NMIN = {P1}; NMAX = {P2}; CALL GET_INPUT; }
               0  ;
               0
               0  "The following macro is used in the egs_init1 subroutine (in the file
               0  "egs_utilities.mortran.  Here it is replaced by null so that we insist that
               0  "the .egsinp file be opened with unit=5 (standard input) and the .egslog
               0  "file (if required) be opened with unit=6 (standard output).  This is
               0  "replaced by a search for available units in beamnrc_lib.mortran to avoid
               0  "unit collisions with BEAM shared library sources
               0
               0  REPLACE {$AVAILABLE_UNIT(#,#)} WITH {;}
               0
               0  " The following two macros are defined so that if the nrcaux.mortran file
               0  " is included in the configuration file these are defined at least.
               0  " If the NRC statistics routine  SIGMA is to be used these must have realistic
               0  " definitions in the user-code.
               0
               0  REPLACE {$MXDATA} WITH {1};
               0  REPLACE {$STAT} WITH {2};
               0
1              0  %E  "egsnrc.macros"
               0  "============================================================================"
               0  "   The following is related to use of the NRC auxilliary
               0  "   routine xvgrplot which is called from some of the standard
               0  "   NRC user-codes.
               0  "
               0  "   It is not an essential part of EGSnrc but is most easily defined here.
               0  "============================================================================"
               0  REPLACE{$PLTDIM} WITH {300};"Unique array dimension for XVGRPLOT and PLOTSN"
               0                          "Suppresses warnings from Intel compiler on Windows"
               0                     "when arrays have different dimensions in diff. routines"
               0
1              0  %E   "egsnrc.macros"
               0  "***************************************************************************"
               0  "                                                                           "
               0  "         EGSnrc internal Variance Reduction Macros                         "
               0  "                                                                           "
               0  "***************************************************************************"
               0
               0  REPLACE {;COMIN/EGS-VARIANCE-REDUCTION/;} WITH {;
            {  0
            {  0    common/egs_vr/
            {  0      e_max_rr($MXREG), "max energy at which to do range rejection (RR)"
            {  0      prob_RR,          "probability for survival in R. Roulette"
            {  0      nbr_split,        "do brems splitting if > 1"
            {  0      i_play_RR,        "0=>don't play Russian Roulette,1=>play Russian Roulette"
            {  0      i_survived_RR,    "0=> all particles survive RR, n=> n partilces were"
            {  0                        "eliminated by RR in this interaction"
            {  0      n_RR_warning,     "a counter for user errors"
            {  0      i_do_rr($MXREG);  "0=>no RR, region by region, 1=>there is RR"
            {  0    $REAL          e_max_rr,prob_RR;
            {  0    $INTEGER       nbr_split,i_play_RR,i_survived_RR,n_RR_warning;
            {  0    $SHORT_INT     i_do_rr;
            {  0  };
               0
               0  REPLACE {$MAX-RR-WARNING} WITH {50}
               0
               0  "This macro implements Russian Roulette (most useful  with brems splitting)"
               0  "It is more efficient than having the user do it via AUSGAB since it avoids"
               0  "considerable handling of the particles by ELECTR"
               0  "The user must set i_play_RR (defaults to 0) and prob_RR"
               0  "Both are in COMIN EGS-VARIANCE-REDUCTION"
               0  ""
               0  "Note that this macro is called as $PLAY RUSSIAN ROULETTE WITH ELECTRONS..."
               0  "Note also that subroutine pair has its own, internal version"
               0
               0  REPLACE {$PLAYRUSSIANROULETTEWITHELECTRONSFROM#;} WITH {;
            {  0
            {  0    i_survived_RR = 0;   "flag all survive"
            {  0    ;IF( i_play_RR = 1 ) [
            {  0        IF( prob_RR <= 0 ) [
            {  0            IF( n_RR_warning < $MAX-RR-WARNING ) [
            {  0              n_RR_warning = n_RR_warning + 1;
            {  0              OUTPUT prob_RR;
            {  0    ('**** Warning, attempt to play Roussian Roulette with prob_RR<=0! ',g14.6);
            {  0            ]
            {  0        ]
            {  0        ELSE [
            {  0            ip = {P1};
            {  0            LOOP [     "handle all particles from p1 to np"
            {  0                IF( iq(ip) ~= 0 ) [   "i.e. charged particles"
            {  0                    $RANDOMSET rnno_RR;
            {  0                    IF( rnno_RR < prob_RR ) [ "particle survives"
            {  0                        wt(ip) = wt(ip)/prob_RR;
            {  0                        ip = ip + 1; "increase local pointer"
            {  0                    ]
            {  0                    ELSE [                    "particle killed"
            {  0                        ;i_survived_RR = i_survived_RR + 1;
            {  0                        ;IF(ip < np) [
            {  0                            "=>replace it with last particle on stack"
            {  0                            e(ip) = e(np); iq(ip) = iq(np); wt(ip) = wt(np);
            {  0                            u(ip) = u(np); v(ip) = v(np); w(ip) = w(np);
            {  0                        ]
            {  0                        np = np-1; "reduce stack by one=> particle gone"
            {  0                    ] "end of kill particle block"
            {  0                ] ELSE [ "this is a photon, leave it. Change pointer" ip = ip+1; ]
            {  0            ] UNTIL (ip > np);
            {  0            "loops until either np is decreased to ip, or ip increased to np"
            {  0            IF( np = 0 ) [ " we need at least one particle on the stack "
            {  0                           " so that the transport routines can exit properly"
            {  0                np = 1; e(np) = 0; iq(np) = 0; wt(np) = 0;
            {  0            ]
            {  0        ] "end of russian roulette block"
            {  0    ] "end of flag set block"
            {  0  };
               0
               0  "*********************************************************************"
               0  "  Stuff related to radiative corrections for Compton scattering      "
               0  "                                                                     "
               0  "  For now we exclude such corrections by default. They can be        "
               0  "  included by adding the file rad_compton.mortran to the list of     "
               0  "  files used to build EGSnrc just before egsnrc.mortran              "
               0  "  The reason is that there is a fairly large amount of data needed   "
               0  "  and this would be wasteful if the effect turns out to be small     "
               0  "*********************************************************************"
               0
               0  REPLACE {$RADC_CHECK;} WITH {;}
               0  REPLACE {$RADC_REJECTION;} WITH {;}
               0  REPLACE {$RADC_WARNING;} WITH {;
            {  0      IF( radc_flag = 1 ) [
            {  0          $egs_warning(*,'You are trying to use radiative Compton corrections');
            {  0          $egs_info(*,'without having included rad_compton1.mortran');
            {  0          $egs_info('(a//)','Turning radiative Compton corrections OFF ...');
            {  0          radc_flag = 0;
            {  0      ]
            {  0  };
               0  REPLACE {$RADC_HATCH;} WITH {$RADC_WARNING;}
               0  REPLACE {$COMIN-RADC-INIT;} WITH {
            {  0          ;COMIN/RAD_COMPTON,EGS-IO,COMPTON-DATA,MEDIA,PHOTIN,USEFUL/;
            {  0  };
               0  REPLACE {$COMIN-RADC-SAMPLE;} WITH {
            {  0          ;COMIN/RAD_COMPTON,RANDOM,STACK,USEFUL,EGS-IO/;
            {  0  };
               0
               0
               0  "*********************************************************************"
               0  "  I/O, parallel processing, string manipulations, etc.
               0  "*********************************************************************"
               0
               0  "how many chunks do we want to split the parallel run into
               0  REPLACE {$N_CHUNKS} WITH {10};
               0
               0  " String manipulations, error messages, etc. "
               0  REPLACE {$cstring(#)} WITH {{P1}(:lnblnk1({P1}))};
               0  REPLACE {$set_string(#,#);} WITH {;
            {  0    DO i=1,len({P1}) [ {P1}(i:i) = {P2}; ] ;
            {  0  };
               0
               0  REPLACE {$egs_debug(#,#);} WITH { write(i_log,{P1}) {P2}; };
               0  REPLACE {$egs_fatal(#,#,#);} WITH {
            {  0    $warning('(/a)','***************** Error: ');
            {  0    $warning({P1},{P2});
            {  0    $warning('(/a)','***************** Quiting now.');
            {  0    $CALL_EXIT({P3});
            {  0  };
               0  REPLACE {$egs_fatal(#,#);} WITH {
            {  0    $warning('(/a)','***************** Error: ');
            {  0    $warning({P1},{P2});
            {  0    $warning('(/a)','***************** Quiting now.');
            {  0    $CALL_EXIT(1);
            {  0  };
               0  REPLACE {$egs_warning(#,#);} WITH {
            {  0    $warning('(/a)','***************** Warning: ');
            {  0    $warning({P1},{P2});
            {  0  };
               0  REPLACE {$warning(#,#);} WITH { write(i_log,{P1}) {P2}; };
               0  REPLACE {$egs_info(#,#);} WITH { write(i_log,{P1}) {P2}; };
               0  REPLACE {$declare_write_buffer;} WITH {;};
               0
               0
               0  " Common block containing various directories, file names, etc. "
               0  REPLACE {$mx_units} WITH {20};
               0  REPLACE {$max_extension_length} WITH {10};
               0  REPLACE {;COMIN/EGS-IO/;} WITH {;
            {  0    common /egs_io/ file_extensions($mx_units),
            {  0                    file_units($mx_units),
            {  0                    user_code,  "The name of the user code"
            {  0                    input_file, "The input file name with path but no extension"
            {  0                    output_file,"Same as above but for output"
            {  0                    pegs_file,  "The pegs file name with path and extension"
            {  0                    hen_house,  "The HEN_HOUSE directory"
            {  0                    egs_home,   "The EGS_HOME directory"
            {  0                    work_dir,   "The working directory within the user code dir."
            {  0                    host_name,  "The name of the host"
            {  0                    n_parallel, "if >0, number of parallel jobs"
            {  0                    i_parallel, "if >0, parallel job number"
            {  0                    first_parallel,"first parallel job (default is 1)"
            {  0                    n_max_parallel,"if parallel run, max. number of running jobs"
            {  0                    n_chunk,    "Histories per calculation chunk"
            {  0                    n_files,
            {  0                    i_input,    "unit no. for .egsinp if required"
            {  0                    i_log,      "unit no. for .egslog if required"
            {  0                    i_incoh,    "unit no. for Compton data"
            {  0                    i_nist_data, "unit no. for NIST data"
            {  0                    i_mscat,     "unit no. for multiple scattering data"
            {  0                    i_photo_cs,  "unit no. for photon cross-section data"
            {  0                    i_photo_relax, "unit no. for photon relaxation data"
            {  0                    xsec_out,     "switches on/off xsection file output"
            {  0                    is_batch,   "True for batch mode"
            {  0                    is_pegsless; "true if you are running without pegs file"
            {  0    character input_file*256, output_file*256, pegs_file*256,
            {  0              file_extensions*$max_extension_length,
            {  0              hen_house*128, egs_home*128, work_dir*128, user_code*64,
            {  0              host_name*64;
            {  0    $INTEGER  n_parallel, i_parallel, first_parallel,n_max_parallel,
            {  0              n_chunk, file_units, n_files,i_input,i_log,i_incoh,
            {  0              i_nist_data,i_mscat,i_photo_cs,i_photo_relax, xsec_out;
            {  0    $LOGICAL  is_batch,is_pegsless;
            {  0  };
               0
               0  "The following macro sets the EGS_HOME directory               "
               0  "The defualt implementation is to use the environment variable "
               0  "EGS_HOME. But at the NRC EGS_HOME is set using the macro      "
               0  "$EGS_HOME defined in machine.macros.                          "
               0  REPLACE {$set_egs_home;} WITH {;
            {  0    $set_string(egs_home,' ');
            {  0    call getenv('EGS_HOME',egs_home);
            {  0  };
               0
               0
               0  " Initialization of various variables on a region-by-region basis "
               0  " This is made a macro so that it can be replaced with a different "
               0  " version for the C/C++ interface                                 "
               0  REPLACE {$set-region-by-region-defaults;} WITH {;
            {  0  DO i=1,$MXREG [
            {  0      ecut(i) = $GLOBAL-ECUT; pcut(i) = $GLOBAL-PCUT; "cut-off energies"
            {  0      ibcmp(i) = $IBCMP-DEFAULT;    "Compton "
            {  0      iedgfl(i) = $IEDGFL-DEFAULT;  "Relaxations"
            {  0      iphter(i) = $IPHTER-DEFAULT;  "photo-electron angular distribution"
            {  0      smaxir(i) = $MAX-SMAX;        "maximum step size"
            {  0      i_do_rr(i) = 0;               "range rejection flag"
            {  0      e_max_rr(i) = 0;              "`save' energy for range rejection"
            {  0      med(i) = 1;                   "default medium"
            {  0      rhor(i) = 0;                  "default mass density"
            {  0      iraylr(i) = $IRAYLR-DEFAULT;  "Rayleigh flag"
            {  0  "Ali:photonuc, 1 line"
            {  0      iphotonucr(i) = $IPHOTONUCR-DEFAULT;  "photonuclear flag per region"]
            {  0  };
               0
               0  " Make sure ecut and pcut are at least ae/ap and set default densities "
               0  " This is made a macro so that it can be replaced with a different "
               0  " version for the C/C++ interface                                 "
               0  REPLACE {$adjust_rhor_ecut_pcut;} WITH {;
            {  0  DO JR=1,$MXREG [
            {  0      MD=MED(JR);
            {  0      IF ((MD.GE.1).AND.(MD.LE.NMED))["IT IS LEGAL NON-VACUUM MEDIUM."
            {  0          ECUT(JR)=max(ECUT(JR),AE(MD));
            {  0          PCUT(JR)=max(PCUT(JR),AP(MD));
            {  0          "   USE STANDARD DENSITY FOR REGIONS NOT SPECIALLY SET UP"
            {  0          IF (RHOR(JR).EQ.0.0)[RHOR(JR)=RHO(MD);]
            {  0      ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$adjust_pcut;} WITH {;
            {  0  DO JR=1,$MXREG [
            {  0      MD=MED(JR);
            {  0      IF ((MD.GE.1).AND.(MD.LE.NMED))["IT IS LEGAL NON-VACUUM MEDIUM."
            {  0          PCUT(JR)=max(PCUT(JR),AP(MD));
            {  0      ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$start_new_particle;} WITH { medium = med(irl); };
               0
               0  REPLACE {$electron_region_change;} WITH {
            {  0      ir(np) = irnew; irl = irnew; medium = med(irl);
            {  0  };
               0  REPLACE {$photon_region_change;} WITH { $electron_region_change; }
               0
               0  REPLACE {$declare_max_medium;} WITH {;};
               0
               0  REPLACE {$need_bound_compton_data(#);} WITH {
            {  0    {P1} = .false.;
            {  0    DO j=1,$MXREG [
            {  0        medium = med(j);
            {  0        IF( medium > 0 & medium <= nmed) [
            {  0            IF( ibcmp(j) > 0 ) [ {P1} = .true.; EXIT; ]
            {  0        ]
            {  0    ]
            {  0  };
               0
               0  REPLACE {$need_relaxation_data(#);} WITH {
            {  0    {P1} = .false.;
            {  0    DO j=1,$MXREG [
            {  0        IF( iedgfl(j) > 0 & iedgfl(j) <= $MXELEMENT ) [ {P1} = .true.; EXIT; ]
            {  0    ]
            {  0  };
               0
               0  REPLACE {$need_rayleigh_data;} WITH {;
            {  0  DO J=1,NMED [
            {  0  :LOOP-OVER-REGIONS:  DO I=1,$MXREG [
            {  0  IF(IRAYLR(I).EQ.1.AND.MED(I).EQ.J) [
            {  0  "REGION I = MEDIUM J AND WE WANT RAYLEIGH SCATTERING, SO"
            {  0  "SET FLAG TO PICK UP DATA FOR MEDIUM J AND TRY NEXT MEDIUM."
            {  0  IRAYLM(J)=1; EXIT :LOOP-OVER-REGIONS:;]
            {  0  "END OF REGION-LOOP"]
            {  0  "END OF MEDIA-LOOP"]
            {  0  };
               0
               0  "Ali:photonuc, 1 block"
               0  REPLACE {$need_photonuc_data;} WITH {;
            {  0  IPHOTONUC=0;
            {  0  DO J=1,NMED [
            {  0  :LOOP-OVER-REGIONS-PHOTONUC: DO I=1,$MXREG [
            {  0  IF(IPHOTONUCR(I).EQ.1.AND.MED(I).EQ.J) [
            {  0  "REGION I = MEDIUM J AND WE WANT PHOTONUCLEAR, SO"
            {  0  "SET FLAG TO PICK UP DATA FOR MEDIUM J AND TRY NEXT MEDIUM."
            {  0  IPHOTONUCM(J)=1; IPHOTONUC=1; EXIT :LOOP-OVER-REGIONS-PHOTONUC:;]
            {  0  "END OF REGION-LOOP"]
            {  0  "END OF MEDIA-LOOP"]
            {  0  };
               0
               0  REPLACE {$set_ecutmn;} WITH {
            {  0    ecutmn = 1e30;
            {  0    DO i=1,$MXREG [
            {  0        IF( med(i) > 0 & med(i) <= nmed ) [
            {  0                  ecutmn = Min(ecutmn,ecut(i));
            {  0        ]
            {  0    ]
            {  0  };
               0
               0  " default numer of media. "
               0  REPLACE {$default_nmed} WITH {1}
               0
               0  REPLACE {$GET-PEGSLESS-XSECTIONS;} WITH {;
            {  0  $egs_fatal('(a/a)',' Code cannot be run in pegsless mode.',
            {  0  ' Compile with required files and try again.');
            {  0  ;
            {  0  }
               0
               0  REPLACE {$INIT-PEGS4-VARIABLES;} WITH {;}
               0
               0  REPLACE {$DECLARE-PEGS4-COMMON-BLOCKS;} WITH {;}
               0
               0  " The following macro is defined to fool the Intel Fortran compiler "
               0  " version 8.0, which miscompiles init_spin when certain optimizations"
               0  " are turned on and the code is run on an Athlon CPU. "
               0  REPLACE {$FOOL-INTEL-OPTIMIZER(#) #;} WITH {;
            {  0      IF( fool_intel_optimizer ) [ write({P1},*) {P2}; ]
            {  0  }
               0  ;
1              0  %E
               0  %I4                                                                            ;
               0  !INDENT F2;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
               0  "#############################################################################"
               0  "                                                                             "
               0  " EGSnrc machine dependent macro file for linux                               "
               0  "                                                                             "
               0  " Created by configure version 2.0 on Sat Jan  5 21:42:46 EST 2019            "
               0  "                                                                             "
               0  " You may add your own machine dependent macros to this file,                 "
               0  " but be carefull to not overwrite it if you re-run configure.                "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0  REPLACE {$MACHINE} WITH
               0  {,'linux',};
               0  REPLACE {$HEN_HOUSE} WITH
               0  {'/opt/source/EGSnrc/HEN_HOUSE/'};
               0  REPLACE {$CANONICAL_SYSTEM} WITH
               0  {'x86_64-unknown-linux-gnu'};
               0  REPLACE {$CONFIGURATION_NAME} WITH
               0  {'linux'};
               0  REPLACE {$EGS_CONFIG} WITH
               0  {'/opt/source/EGSnrc/HEN_HOUSE/specs/linux.conf'};
               0
               0  " System dependent stuff "
               0  "========================================"
               0  " Unfortunately, there appears to be no reliable way of copying files "
               0  " under Fortran => we use a system call for this"
               0  REPLACE {$copy_file} WITH {'cp '};
               0
               0  " Although one can move files using Fortran's intrinsic rename, "
               0  " we don't know whether the user has not created additional files in "
               0  " the temporary working directory => it is easiest to use a system call "
               0  " to move all files from the temporary working directory to the user-code "
               0  " directory. "
               0  REPLACE {$move_file} WITH {'mv -f '};
               0
               0  " There appears to be no way of removing a directory from Fortran "
               0  " => we use a system call for this. "
               0  REPLACE {$remove_directory} WITH {'rm -rf '};
               0
               0  " The directory separator "
               0  REPLACE {$file_sep} WITH {'/'};
               0
               0  REPLACE {$LONG_INT} WITH { integer*8 };
               0  REPLACE {$SHORT_INT} WITH { integer*2 };
               0  "$MAX_INT SET TO 2^63-1 in egsnrc.macros"
               0  "The machine byte order"
               0  REPLACE {$BYTE_ORDER} WITH {'1234'};
               0  ;
               0  REPLACE {$RECL-FACTOR} WITH {4};
               0  ;
               0  REPLACE {$FLUSH_UNIT(#);} WITH {call flush({P1});}
               0  ;
               0  " If you want your user-code to return an exit status, use the "
               0  " following macro to terminate execution"
               0  REPLACE {$CALL_EXIT(#);} WITH {call exit({P1});}
               0  ;
               0  " mortran3 gets confused by the # char => we need to pass it as an "
               0  " argument to the macro. "
               0  REPLACE {$HAVE_C_COMPILER(#);} WITH {{EMIT;{P1}define HAVE_C_COMPILER};}
               0  ;
               0  REPLACE {$HAVE_LOAD_DSO(#);} WITH {{EMIT;{P1}define HAVE_LOAD_DSO};}
               0  ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc pegs4 macros                                                        "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Blake Walters, 2013                                       "
               0  "                                                                             "
               0  "  Contributors:    Reid Townson                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The content of this file was adapted from the original pegs4 source code   "
               0  "  to enable on-the-fly pegs data generation in EGSnrc. Please see the pegs4  "
               0  "  sources for more information on the authorship of the original code.       "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  "Compiler directives"
               0  "==================="
               0  %Q1         "Automatically close comments at end of line                       ;
               0  "but this DOES NOT apply withing macro definitions!!
               0  %C80        "Allow 80 columns of source/line (default is 72)                   ;
               0  %L          "Turn on listing                                                   ;
               0
               0  "MACROS TO SPLIT LONG STRING INTO A1 STRINGS"
               0  REPLACE {$S'{SYMBOL}#'} WITH
               0  {'#1'[IF]{EXIST 2}[,$S'{P2}']};
               0
               0  "pegs4 uses single precision.  real*8 causes problems"
               0  REPLACE {$REAL4} WITH {real*4};
               0
               0  PARAMETER $MXSTC=73;"NUMBER OF MEDIA WITH STERNHEIMER COEFFICIENTS"
               0  PARAMETER $RERR=1.E-5;      "RERR-VALUE NEEDED BY DCADRE"
               0  PARAMETER $AERR=1.E-16;     "AERR-VALUE NEEDED BY DCADRE"
               0  PARAMETER $FUDGEMS=1.0;  "FULL MS OFF ATOMIC ELECTRONS"
               0
               0  REPLACE {;COMIN/LBREMZ/;} WITH {
            {  0  ;COMMON/LBREMZ/CONST,DELC,EBREMZ,DELTAM,XLNZ;
            {  0  $REAL4 CONST,DELC,EBREMZ,DELTAM,XLNZ;
            {  0  }
               0
               0  REPLACE {;COMIN/PMCONS/;} WITH
               0  {;COMMON/PMCONS/PIP,C,RME,HBAR,ECGS,EMKS,AN;
            {  0  $REAL4 PIP,C,RME,HBAR,ECGS,EMKS,AN;
            {  0  };
               0
               0  REPLACE {;COMIN/DERCON/;} WITH
               0  {;COMMON/DERCON/RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680;
            {  0  $REAL4 RADDEG,FSC,ERGMEV,R0,RMP,RMPT2,RMPSQ,A22P9,A6680;
            {  0  };
               0
               0  REPLACE {;COMIN/THRESHP/;} WITH
               0  {;COMMON/THRESHP/APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP,IUNRSTP;
            {  0  $REAL4 APP,AEP,UPP,UEP,THBREMP,THMOLLP,TEP;
            {  0  $INTEGER IUNRSTP;
            {  0  };
               0
               0  REPLACE {;COMIN/BREMPRP/;} WITH
               0  {;COMMON/BREMPRP/DLP1(6),DLP2(6),DLP3(6),DLP4(6),DLP5(6),DLP6(6),
            {  0  DELCMP,ALPHIP(2),BPARP(2),DELPOSP(2);
            {  0  $REAL4 dlP1,dlP2,dlP3,dlP4,dlP5,dlP6,delcmP,alphiP,bparP,delposP;
            {  0  };
               0
               0  REPLACE {;COMIN/EPSTAR/;} WITH
               0  {;
            {  0  COMMON/EPSTAR/EPSTEN(150),EPSTD(150),WEPST(20),
            {  0  EPSTTL,NEPST,IEPST,EPSTFLP,
            {  0  NELEPS,ZEPST(20),IAPRFL,IAPRIMP;
            {  0  $INTEGER    ZEPST,NELEPS,IAPRFL,NEPST,IEPST,EPSTFLP,IAPRIMP;
            {  0  CHARACTER   EPSTTL*80;
            {  0  $REAL4       EPSTEN,EPSTD,WEPST;
            {  0  };
               0
               0  "THIS COMMON IS USED FOR OPTION WHICH READS IN DENSITY EFFECT "
               0  "CORRECTION IN SPINIT AND CALCULATES USING IT IN SPIONB       "
               0  "THE FLAG EPSTFL IS READ UNDER NAMELIST INPUT, AND DEFAULTS   "
               0  "   TO ZERO IN THE BLOCK DATA. SET TO UNITY TO USE THE OPTION "
               0  "PEGS USES THE I-VALUE IN THE DENSITY INPUT FILE              "
               0  "VARIOUS CHECKS ARE DONE TO ENSURE THE DENSITY CORRECTION     "
               0  "   CORRESPONDS TO THE MATERIAL DEFINITION IN PEGS            "
               0  "THE ENERGY TABLE READ IN IS ASSUMED TO BE KINETIC ENERGY IN  "
               0  "   MEV BUT IS CONVERTED TO TOTAL ENERGY BY THE CODE.         "
               0  "THE ENERGY OPTION MUST BE USED IN PEGS PRIOR TO THE MIXT,COMP"
               0  "   OR ELEM OPTIONS TO ALLOW ALL THE CHECKS TO WORK PROPERLY. "
               0  "NELEPS IS THE NUMBER OF ELEMENTS IN THE MATERIAL             "
               0  "ZEPST(I) (INTEGER), WEPST(I) ARE THE Z VALUE AND FRACTION    "
               0  "   BY WEIGHT OF THE I-TH ELEMENT IN THE DATA FILE.           "
               0  "IAPRIM is a flag to tell which correction to the bremsstrahlung        "
               0  "       cross section to use:      0 =>  old Koch and Motz    "
               0  " =1(defaulat) read in new data file; =2, use no corrections. "
               0  "IAPRFL is a flag to say if APRIM file has been initialized   "
               0
               0  REPLACE {;COMIN/MOLVAR/;} WITH
               0  {;COMMON/MOLVAR/WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,
            {  0  RLCP,EDEN,RHOP,XCCP,BLCCP,TEFF0P,XR0P;
            {  0  $REAL4 WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZA,ZG,ZP,ZV,ZU,RLCP,EDEN,RHOP,
            {  0  XCCP,BLCCP,TEFF0P,XR0P;
            {  0  };
               0
               0  REPLACE {;COMIN/MIMSD/;} WITH
               0  {;COMMON/MIMSD/BMIN;
            {  0  $REAL4 BMIN;
            {  0  };
               0
               0  REPLACE {;COMIN/RADLEN/;} WITH
               0  {;COMMON/ADLEN/ALRAD(4),ALRADP(4),A1440,A183;
            {  0  $REAL4 ALRAD,ALRADP,A1440,A183;
            {  0  };
               0
               0  "------------------------------------------------------------------"
               0  "*** LSPION--COMMON FOR COMMUNICATION BETWEEN SPINIT AND SPIONB    "
               0  "------------------------------------------------------------------"
               0  REPLACE {;COMIN/LSPION/;} WITH
               0  {;COMMON/LSPION/CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV;
            {  0  $REAL4 CBAR,X0,X1,SK,TOLN10,AFACT,SPC1,SPC2,IEV;
            {  0  };
               0
               0  REPLACE {;COMIN/SPCOMM/;} WITH
               0  {;COMMON/SPCOMM/MEDTBL(24,$MXSTC),
            {  0  NUMSTMED,STDATA(6,$MXSTC);
            {  0  $TYPE MEDTBL;
            {  0  $INTEGER NUMSTMED;
            {  0  $REAL4    STDATA;
            {  0  }
               0
               0  REPLACE {;COMIN/PWLFIN/;} WITH
               0  {;COMMON/PWLFIN/EPE,ZTHRE(8),ZEPE(8),NIPE,NALE;
            {  0  $REAL4 EPE,ZTHRE,ZEPE;
            {  0  $INTEGER NIPE,NALE;
            {  0  };
               0
               0  REPLACE {;COMIN/RSLTS/;} WITH
               0  {;COMMON/RSLTS/NEL,AXE,BXE,AFE($MXEKE,8),BFE($MXEKE,8);
            {  0  $REAL4 AXE,BXE,AFE,BFE;
            {  0  $INTEGER NEL;
            {  0  };
               0
               0  REPLACE {;COMIN/ELEMTB/;} WITH
               0  {;COMMON/ELEMTB/NET,ITBL(100),WATBL(100),RHOTBL(100),ASYMT(100);
            {  0  $INTEGER NET;
            {  0  $REAL4 ITBL,WATBL,RHOTBL;
            {  0  $TYPE ASYMT;
            {  0  }
               0
               0  REPLACE {;COMIN/MIXDAT/;} WITH
               0  {;COMMON/MIXDAT/NEP,LMED,PZP($MXEL),ZELEMP($MXEL),WAP($MXEL),RHOZP($MXEL),
            {  0  GASPP,EZ,TPZ,IDSTRN(24);
            {  0  $INTEGER NEP,LMED;
            {  0  $REAL4 PZP,ZELEMP,WAP,RHOZP,GASPP,EZ,TPZ;
            {  0  $TYPE IDSTRN;
            {  0  }
               0
               0  REPLACE {;COMIN/DBRPR/;} WITH
               0  {;COMMON/DBRPR/ALFP1(2),ALFP2(2),AL2;
            {  0  $REAL4 ALFP1,ALFP2,al2;
            {  0  };
               0
               0  "This block contains some media parameters required for"
               0  "cross-section calculations but not covered in any of the"
               0  "egsnrc common blocks.  It also contains $REAL4 versions"
               0  "of some egsnrc media parameters to allow direct comparison"
               0  "with cross-sections calculated by pegs4.mortran"
               0  REPLACE {;COMIN/MEDINP/;} WITH
               0  {;COMMON/MEDINP/inpdensity_file($MXMED),inpasym($MXMED,$MXEL),
            {  0  inpstrn(24,$MXMED),pz4($MXMED,$MXEL),
            {  0  rhoz4($MXMED,$MXEL),wa4($MXMED,$MXEL),inpgasp($MXMED);
            {  0  character*256 inpdensity_file;
            {  0  $TYPE inpasym,inpstrn;
            {  0  $REAL4 pz4,rhoz4,wa4,inpgasp;
            {  0  };
               0
               0  REPLACE {$DECLARE-PEGS4-COMMON-BLOCKS;} WITH {
            {  0  ;COMIN/LBREMZ,PMCONS,DERCON,EPSTAR,MOLVAR,LSPION,PWLFIN,
            {  0  RSLTS,SPCOMM,MIXDAT,RADLEN,MIMSD,THRESHP,BREMPRP,ELEMTB,MEDINP/;
            {  0  $REAL4 XSIFP,WADUM,PZDUM,RHOZDUM,RLCDUM,ALKE,ALKEI;
            {  0  $INTEGER I01;
            {  0  EXTERNAL ALKE,ALKEI,EFUNS;
            {  0  $TYPE MEDTB1(24,20),MEDTB2(24,20),MEDTB3(24,20),MEDTB4(24,13);
            {  0  EQUIVALENCE (MEDTBL(1,1),MEDTB1(1,1));
            {  0  EQUIVALENCE (MEDTBL(1,21),MEDTB2(1,1));
            {  0  EQUIVALENCE (MEDTBL(1,41),MEDTB3(1,1));
            {  0  EQUIVALENCE (MEDTBL(1,61),MEDTB4(1,1));
            {  0  }
               0
               0  REPLACE {$GET-PEGSLESS-XSECTIONS;} WITH
               0  {;
            {  0
            {  0  call get_media_inputs(-1);
            {  0
            {  0  DO IM=1,NMED[
            {  0
            {  0  "store values in variables used to calculate cross-sections"
            {  0  AEP=AE(IM);
            {  0  UEP=UE(IM);
            {  0  APP=AP(IM);
            {  0  UPP=UP(IM);
            {  0  NEP=NNE(IM);
            {  0  IUNRSTP=IUNRST(IM);
            {  0  IAPRIMP=IAPRIM(IM);
            {  0  EPSTFLP=EPSTFL(IM);
            {  0  GASPP=INPGASP(IM); "recall gasp not an egsnrc variable"
            {  0  RHOP=RHO(IM);
            {  0  DO J=1,NEP[
            {  0  ZELEMP(J)=ZELEM(IM,J);
            {  0  "use the $REAL4 variables from MEDINP for these ones, for now"
            {  0  "since these have been calculated using $REAL4 math"
            {  0  PZP(J)=PZ4(IM,J);
            {  0  RHOZP(J)=RHOZ4(IM,J);
            {  0  WAP(J)=WA4(IM,J);
            {  0  ]
            {  0  DO IB=1,LMDN[
            {  0  IDSTRN(IB)=INPSTRN(IB,IM);
            {  0  ]
            {  0  TEP=AEP-RMP; THMOLLP=AEP+TEP ; "equation in pegs4.mortran"
            {  0
            {  0  IF (UEP.LE.AEP)[
            {  0  write(i_log,'(a,24a1)')'  Error: Material not defined: ',
            {  0  (media(j,IM),j=1,24);
            {  0  $egs_fatal(*,'Material used in the geometry was not defined in the'
            {  0  ,' material data.');
            {  0  ]
            {  0
            {  0  CALL MIX; "calculates MS parameters"
            {  0
            {  0  CALL SPINIT(inpdensity_file(IM)); "density corrections, may open density file"
            {  0
            {  0  CALL DIFFER;
            {  0  "do not know why we call above subroutine since"
            {  0  "bremsstrahlung cross-sections get reset in fix_brems"
            {  0
            {  0  "now call the piecewise linear fit subroutine to generate the remainder of"
            {  0  "the electron cross-sections"
            {  0  CALL PWLF1(NEL,NALE,AEP,UEP,THMOLLP,EPE,ZTHRE,ZEPE,NIPE,ALKE,
            {  0  ALKEI,AXE,BXE,$MXEKE,8,AFE,BFE,EFUNS);
            {  0
            {  0  "cross-sections are now calculated"
            {  0  "store generated data in egsnrc variables"
            {  0
            {  0  "recompute the following two, note the different form of the equation for"
            {  0  "THMOLL compared to pegs4.mortran"
            {  0  TE(IM)=AE(IM)-RM; THMOLL(IM)=TE(IM)*2. + RM ;
            {  0
            {  0  "cross-section parameters"
            {  0  RLC(IM)=RLCP;"RLCP gets calculated in MIX"
            {  0
            {  0  XCC(IM)=XCCP;
            {  0  BLCC(IM)=BLCCP;
            {  0  XR0(IM)=XR0P;
            {  0  TEFF0(IM)=TEFF0P;
            {  0
            {  0  "all of the below gets reset in fix_brems"
            {  0  DELCM(IM)=DELCMP;
            {  0  DO I=1,2[
            {  0  ALPHI(I,IM)=ALPHIP(I);
            {  0  BPAR(I,IM)=BPARP(I);
            {  0  DELPOS(I,IM)=DELPOSP(I);
            {  0  ]
            {  0  DO I=1,6[
            {  0  DL1(I,IM)=DLP1(I);
            {  0  DL2(I,IM)=DLP2(I);
            {  0  DL3(I,IM)=DLP3(I);
            {  0  DL4(I,IM)=DLP4(I);
            {  0  DL5(I,IM)=DLP5(I);
            {  0  DL6(I,IM)=DLP6(I);
            {  0  ]
            {  0
            {  0
            {  0  "the following egsnrc quantities are all zeroed in the pegs4 generated data"
            {  0  "so they shall be zeroed here"
            {  0  MSGE(IM)=0;MSEKE(IM)=0;MLEKE(IM)=0;MCMFP(IM)=0;MRANGE(IM)=0;
            {  0
            {  0  "now, the non-zero quantities"
            {  0  MGE(IM)=$MXGE; "we do not use PWLF1 for photon quantities"
            {  0  "this setting is also done in init_user_photon"
            {  0  MEKE(IM)=NEL; "no. of electron energies as determed from PWLF1"
            {  0
            {  0  "now, set secondary egsnrc variables"
            {  0
            {  0  NSGE=MSGE(IM);NGE=MGE(IM);NSEKE=MSEKE(IM);NEKE=MEKE(IM);
            {  0  NLEKE=MLEKE(IM);NCMFP=MCMFP(IM);NRANGE=MRANGE(IM);
            {  0
            {  0  "store results of pwlf in egsnrc variables"
            {  0  EKE0(IM)=BXE;
            {  0  EKE1(IM)=AXE;
            {  0
            {  0  "BFE and AFE were acquired with the call to"
            {  0  "PWLF1 above but we need to fill in the arrays"
            {  0  DO I=1,NEKE[
            {  0  ESIG0(I,IM)=BFE(I,1);
            {  0  ESIG1(I,IM)=AFE(I,1);
            {  0  PSIG0(I,IM)=BFE(I,2);
            {  0  PSIG1(I,IM)=AFE(I,2);
            {  0  EDEDX0(I,IM)=BFE(I,3);
            {  0  EDEDX1(I,IM)=AFE(I,3);
            {  0  PDEDX0(I,IM)=BFE(I,4);
            {  0  PDEDX1(I,IM)=AFE(I,4);
            {  0  EBR10(I,IM)=BFE(I,5);
            {  0  EBR11(I,IM)=AFE(I,5);
            {  0  PBR10(I,IM)=BFE(I,6);
            {  0  PBR11(I,IM)=AFE(I,6);
            {  0  PBR20(I,IM)=BFE(I,7);
            {  0  PBR21(I,IM)=AFE(I,7);
            {  0  TMXS0(I,IM)=BFE(I,8);
            {  0  TMXS1(I,IM)=AFE(I,8);
            {  0  ]
            {  0
            {  0  "below is for debugging to ensure that"
            {  0  "pegsless and pegs versions would give identical"
            {  0  "results if pegsless cross sections were to be"
            {  0  "read from a file a la pegs"
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0
            {  0  ]
            {  0
            {  0  "put rescaling here in case we want to plot stopping powers via"
            {  0  "show_media_parameters below"
            {  0  "   WE NOW HAVE DATA FOR ALL MEDIA REQUESTED.  NOW DO DISTANCE UNIT"
            {  0  "   CHANGE.  DATA FROM PEGS IS IN UNITS OF RADIATION LENGTHS."
            {  0  "   EGS IS RUN IN UNITS OF 'DUNIT' CENTIMETERS, IF DUNIT.GT.0 "
            {  0  "   OR IN UNITS OF RLC(-DUNIT) CENTIMETERS IF DUNIT.LT.0."
            {  0  "   THAT IS, A NEGATIVE DUNIT MEANS UNIT IS TO BE THE RADIATION"
            {  0  "   LENGTH OF THE MEDIUM WHOSE INDEX IS -DUNIT"
            {  0  DUNITR=DUNIT; "SAVE REQUESTED"
            {  0  IF(DUNIT.LT.0.0)[ID=MAX0(1,MIN0($MXMED,int(-DUNIT)));
            {  0  DUNIT=RLC(ID);]
            {  0  IF(DUNIT.NE.1.0) [
            {  0  $egs_info('(a,1PE14.5,E14.5,a)',' DUNIT REQUESTED&USED ARE: ',
            {  0  DUNITR,DUNIT,'(CM.)' );
            {  0  ]
            {  0  DO IM=1,NMED [
            {  0  DFACT=RLC(IM)/DUNIT; "CONVERTS RL TO DUNITS"
            {  0  DFACTI=1.0/DFACT;    "CONVERT RL**-1 TO DUNITS**-1"
            {  0
            {  0  FOR I=1 TO MEKE(IM) [
            {  0  $SCALE $LGN(ESIG,PSIG,EDEDX,PDEDX(I,IM)/0,1/) BY DFACTI;
            {  0  $SCALE $LGN(TMXS(I,IM)/0,1/) BY DFACT;]
            {  0  $SCALE TEFF0(IM) BY DFACT;
            {  0  $SCALE BLCC(IM) BY DFACTI;
            {  0  $SCALE XCC(IM) BY SQRT(DFACTI);
            {  0  RLDU(IM)=RLC(IM)/DUNIT;
            {  0  FOR I=1 TO MGE(IM) [$SCALE $LGN(GMFP(I,IM)/0,1/) BY DFACT; ]
            {  0  ] "END IM DO"
            {  0
            {  0  "   SCALE VACDST.  UNDO PREVIOUS SCALE, THEN DO NEW."
            {  0  VACDST=VACDST*DUNITO/DUNIT;
            {  0  DUNITO=DUNIT; "SAVE OLD DUNIT"
            {  0
            {  0  call show_media_parameters(i_log);
            {  0
            {  0  ;
            {  0  }
               0
               0  REPLACE {$INIT-PEGS4-VARIABLES;} WITH {
            {  0  ;
            {  0  "***PHYSICAL AND MATHEMATICAL CONSTANTS                                "
            {  0  "     C        SPEED OF LIGHT(CM/SEC)                                  "
            {  0  "     RME      ELECTRON REST MASS(GRAMS)                               "
            {  0  "     HBAR     PLANCK'S CONSTANT/(2*PI)  (ERG SEC)                     "
            {  0  "     ECGS     ELECTRON CHARGE (ESU)                                   "
            {  0  "     EMKS     ELECTRON CHARGE (COULOMB)                               "
            {  0  "     AN       AVOGADRO'S NUMBER                                       "
            {  0  PIP=3.1415926536;
            {  0  C=2.997925E+10;
            {  0  HBAR=1.05450E-27;
            {  0  ECGS=4.80298E-10;
            {  0  EMKS=1.60210E-19;
            {  0  AN=6.02252E+23;
            {  0  "***DERIVED CONSTANTS                                                  "
            {  0  "     RADDEG   ONE RADIAN IN DEGREES                                   "
            {  0  "     FSC      FINE STRUCTURE CONSTANT                                 "
            {  0  "     ERGMEV   ONE MILLION ELECTRON VOLTS EXPRESSED IN ERGS            "
            {  0  "     R0       CLASSICAL ELECTRON RADIUS                               "
            {  0  "     RM       ELECTRON REST ENERGY IN MEV                             "
            {  0  RADDEG=180./PIP;
            {  0  FSC = ECGS**2/(HBAR*C);
            {  0  "     1.E+7 IS THE NUMBER OF ERGS PER JOULE                            "
            {  0  ERGMEV = (1.E+6)*(EMKS*1.E+7);
            {  0  RME = PRM/C**2*ERGMEV;
            {  0  "We are using RMP instead of PRM because single precision is required"
            {  0  RMP = PRM;
            {  0  R0 = (ECGS**2)/(RME*C**2);
            {  0  RMPSQ = RMP*RMP;
            {  0  A22P9 = RADDEG*SQRT(4.*PIP*AN)*ECGS**2/ERGMEV;
            {  0  A6680 = 4.0*PIP*AN*(HBAR/(RME*C))**2*(0.885**2/(1.167*1.13));
            {  0
            {  0  "DATA FOR COMMON BLOCK LSPION"
            {  0  DATA AFACT/0.0/,SK/0.0/,X0/0.0/,X1/0.0/,CBAR/0.0/,IEV/0.0/;
            {  0
            {  0  "DATA for COMMON BLOCK SPCOMM"
            {  0  DATA LMED/24/,NUMSTMED/$MXSTC/;
            {  0
            {  0  "DATA for COMMON BLOCK PWLFIN"
            {  0  DATA EPE/.01/,ZTHRE,ZEPE/16*0.0/,NIPE/20/,NALE/$MXEKE/;
            {  0
            {  0  "DATA for COMMON BLOCK MIMSD"
            {  0  DATA BMIN/4.5/;
            {  0
            {  0  "DATA for COMMON BLOCK RADLEN"
            {  0  DATA ALRAD/5.31,4.79,4.74,4.71/,ALRADP/6.144,5.621,5.805,5.924/,
            {  0  A1440/1194.0/,A183/184.15/;
            {  0
            {  0  DATA MEDTB1/
            {  0  $S'H2-GAS',18*' ',$S'H2-LIQUID',15*' ',$S'HE-GAS',18*' ',$S'LI',22*' ',
            {  0  $S'BE',22*' ',$S'C-2.265 G/CM**3',9*' ',$S'C-1.70 G/CM**3',10*' ',
            {  0  $S'N2-GAS',18*' ',$S'O2-GAS',18*' ',$S'NE-GAS',18*' ',$S'NA',22*' ',
            {  0  $S'MG',22*' ',$S'AL',22*' ',$S'SI',22*' ',$S'AR-GAS',18*' ',
            {  0  $S'K',23*' ',$S'CA',22*' ',$S'TI',22*' ',$S'V',23*' ',$S'MN',22*' '
            {  0  /;
            {  0
            {  0  DATA MEDTB2/
            {  0  $S'FE',22*' ',$S'CO',22*' ',$S'NI',22*' ',$S'CU',22*' ',$S'ZN',22*' ',
            {  0  $S'GE',22*' ',$S'SE',22*' ',$S'KR-GAS',18*' ',$S'RB',22*' ',
            {  0  $S'MO',22*' ',$S'AG',22*' ',$S'CD',22*' ',$S'IN',22*' ',$S'SN',22*' ',
            {  0  $S'XE-GAS',18*' ',$S'CS',22*' ',$S'GD',22*' ',$S'TA',22*' ',
            {  0  $S'W',23*' ',$S'PT',22*' '
            {  0  /;
            {  0
            {  0  DATA MEDTB3/
            {  0  $S'AU',22*' ',$S'HG',22*' ',$S'PB',22*' ',$S'RN-GAS',18*' ',
            {  0  $S'U',23*' ',
            {  0  $S'AIR-GAS',17*' ',$S'CO2-GAS',17*' ',$S'POLYETHYLENE',12*' ',
            {  0  $S'POLYPROPYLENE',11*' ',$S'XYLENE',18*' ',$S'TOLUENE',17*' ',
            {  0  $S'NYLON',19*' ',$S'VINYLTOLUENE',12*' ',$S'A150-PLASTIC',12*' ',
            {  0  $S'STILBENE',16*' ',$S'POLYSTYRENE',13*' ',$S'ANTHRACENE',14*' ',
            {  0  $S'LEXAN',19*' ',$S'LUCITE',18*' ',$S'H2O',21*' '
            {  0  /;
            {  0
            {  0  DATA MEDTB4/
            {  0  $S'MYLAR',19*' ',
            {  0  $S'KAPTON',18*' ',$S'LIF',21*' ',$S'POLYVINYL-CL',12*' ',
            {  0  $S'PYREX-GLASS',13*' ',$S'SIO2',20*' ',$S'CAF2',20*' ',
            {  0  $S'PHOTOEMULSION',11*' ',$S'AGCL',20*' ',$S'NAI',21*' ',
            {  0  $S'LII',21*' ',$S'AGBR',20*' ',$S'CSI',21*' '
            {  0  /;
            {  0
            {  0  DATA NET/100/;
            {  0
            {  0  DATA ITBL/19.2,41.8,40.,63.7,76.0,78.0,82.0,95.0,115.,137.,
            {  0  149.,156.,166.,173.,173.,180.,174.,188.,190.,191.,216.,233.,245.,
            {  0  257.,272.,286.,297.,311.,322.,330.,334.,350.,347.,348.,357.,352.,
            {  0  363.,366.,379.,393.,417.,424.,428.,441.,449.,470.,470.,469.,488.,
            {  0  488.,487.,485.,491.,482.,488.,491.,501.,523.,535.,546.,560.,574.,
            {  0  580.,591.,614.,628.,650.,658.,674.,684.,694.,705.,718.,727.,736.,
            {  0  746.,757.,790.,790.,800.,810.,823.,823.,830.,825.,794.,827.,826.,
            {  0  841.,847.,878.,890.,902.,921.,934.,939.,952.,966.,980.,994./;
            {  0
            {  0  DATA WATBL/1.00797,4.0026,6.939,9.0122,10.811,12.01115,14.0067,
            {  0  15.9994,18.9984,20.183,22.9898,24.312,26.9815,28.088,30.9738,
            {  0  32.064,35.453,39.948,39.102,40.08,44.956,47.90,50.942,51.998,
            {  0  54.9380,55.847,58.9332,58.71,63.54,65.37,69.72,72.59,74.9216,
            {  0  78.96,79.808,83.80,85.47,87.62,88.905,91.22,92.906,95.94,99.0,
            {  0  101.07,102.905,106.4,107.87,112.4,114.82,118.69,121.75,127.60,
            {  0  126.9044,131.30,132.905,137.34,138.91,
            {  0  140.12,140.907,144.24,147.,150.35,151.98,157.25,158.924,162.50,
            {  0  164.930,167.26,168.934,173.04,174.97,178.49,180.948,183.85,
            {  0  186.2,190.2,192.2,195.08,196.987,200.59,204.37,207.19,208.980,
            {  0  210.,210.,222.,223.,226.,227.,232.036,231.,238.03,237.,242.,
            {  0  243.,247.,247.,248.,254.,253./;
            {  0
            {  0  DATA RHOTBL/0.0808,0.19,0.534,1.85,2.5,2.26,1.14,1.568,1.5,1.0,
            {  0  0.9712,1.74,2.702,2.4,1.82,2.07,2.2,1.65,0.86,1.55,3.02,4.54,
            {  0  5.87,7.14,7.3,7.86,8.71,8.90,8.9333,7.140,5.91,5.36,5.73,4.80,
            {  0  4.2,3.4,1.53,2.6,4.47,6.4,8.57,9.01,11.50,12.20,12.50,12.,10.5,
            {  0  8.65,7.30,7.31,6.684,6.24,4.93,2.7,1.873,3.5,6.15,6.90,6.769,
            {  0  7.007, 1.  ,7.54,5.17,7.87,8.25,8.56,8.80,9.06,9.32,6.96,9.85,
            {  0  11.40,16.60,19.30,20.53,22.48,22.42,21.45,19.30,14.19,11.85,
            {  0  11.34,9.78,9.30, 1.  ,4., 1.  ,5.,  1. ,11.0,15.37,18.90,
            {  0  20.5,19.737,11.7,7.,1.   , 1.  , 1.  ,  1. /;
            {  0
            {  0  DATA ASYMT/'H','HE','LI','BE','B','C','N','O','F','NE',
            {  0  'NA','MG','AL','SI','P','S','CL','AR','K','CA','SC','TI',
            {  0  'V','CR','MN','FE','CO','NI','CU','ZN','GA','GE','AS','SE','BR',
            {  0  'KR','RB','SR','Y','ZR','NB','MO','TC','RU','RH','PD','AG','CD',
            {  0  'IN','SN','SB','TE','I','XE','CS','BA','LA','CE','PR','ND',
            {  0  'PM','SM','EU','GD','TB','DY','HO','ER','TM','YB','LU','HF','TA',
            {  0  'W','RE','OS','IR','PT','AU','HG','TL','PB','BI','PO','AT','RN',
            {  0  'FR','RA','AC','TH','PA','U','NP','PU','AM','CM','BK','CF','ES',
            {  0  'FM'/;
            {  0
            {  0  "for COMMON BLOCK EPSTAR"
            {  0  DATA EPSTFLP/0/,IEPST/1/,IAPRIMP/1/,IAPRFL/0/;
            {  0
            {  0  }
               0
               0  ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc common block reorganization for C interface                         "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Iwan Kawrakow, 2003                                       "
               0  "                                                                             "
               0  "  Contributors:    Ernesto Mainegra-Hing                                     "
               0  "                   Blake Walters                                             "
               0  "                   Reid Townson                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  This is a set of macros that slightly re-organizes EGSnrc common blocks,   "
               0  "  so that only a relatively small set of common blocks needs to be exported  "
               0  "  as C structures. It is only needed when generating the EGSnrc fortran code "
               0  "  used with the C inteface and should get included after egsnrc.macros.      "
               0  "                                                                             "
               0  "  In the original ecut, pcut are arrays of dimension $MXREG, where $MXREG is "
               0  "  a macro that defines the maximum number of regions the geometry can have.  "
               0  "  For the C/C++ interface we wish to completely decouple EGSnrc routines     "
               0  "  from the geometry so that the C/C++ user code programmer can dynamically   "
               0  "  allocate resources depending on the actual number of regions. We therefore "
               0  "  use ecut, pcut, ecut_new, pcut_new to interact with the user with respect  "
               0  "  to particle transport cut-off energies. ecut, ecut_new, pcut, pcut_new are "
               0  "  initialized to zero by default. If the user does not wish to use transport "
               0  "  thresholds different than the particle production thresholds ae and ap,    "
               0  "  they don't need to do anything with ecut, ecut_new, pcut, pcut_new. If the "
               0  "  user wants to use higher thresholds, possibly different from one region to "
               0  "  another, then the user code must do the following:                         "
               0  "                                                                             "
               0  "  - In the function start_new_particle() called before the transport of      "
               0  "    a new particle starts, the user should set pcut and ecut to the desired  "
               0  "    values based on the region number of the top particle on the stack.      "
               0  "                                                                             "
               0  "  - In howfar(), the user should set ecut_new, pcut_new to the desired       "
               0  "    values in the new region after the step (provided the particle is        "
               0  "    entering a new region, i.e., irnew is different from ir(np), see the     "
               0  "    geometry interface specs)                                                "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  " Single or double precision for floating point operations "
               0  REPLACE {$REAL} WITH {EGS_Float};
               0
               0
               0  " Take care of the rundom numner generator "
               0  REPLACE {$NRANDOM} WITH {128};
               0  REPLACE {;COMIN/RANDOM/;} WITH {;
            {  0  common/randomm/ rng_array($NRANDOM), rng_seed;
            {  0  integer*4       rng_seed;
            {  0  $REAL           rng_array;
            {  0  };
               0  REPLACE {$RANDOMSET#;} WITH {;
            {  0  IF( rng_seed > $NRANDOM ) [
            {  0  rng_seed = $NRANDOM;
            {  0  call egs_fill_rndm_array(rng_seed,rng_array);
            {  0  rng_seed = 1;
            {  0  ]
            {  0  {P1} = rng_array(rng_seed); rng_seed = rng_seed + 1;
            {  0  };
               0  REPLACE {$RNG-DEFAULT-INITIALIZATION;} WITH {;};
               0  REPLACE {$INITIALIZERNGUSING#AND#;} WITH {;
            {  0  $egs_fatal(*,
            {  0  'The INITIALIZE RNG USING macro should not be used with the C++ interface!');
            {  0  };
               0
               0  REPLACE {;COMIN/BOUNDS/;} WITH {
            {  0
            {  0  ;common/bounds/ ecut, pcut, ecut_new, pcut_new, vacdst;
            {  0  $REAL          ecut, pcut, ecut_new, pcut_new, vacdst;
            {  0
            {  0  };
               0
               0  " Remove iprdst, ibrdst and ibr_nist, they will go into a "
               0  " a cross section options common that will get exported   "
               0  REPLACE {;COMIN/BREMPR/;} WITH {
            {  0  ;common/brempr/
            {  0  $LGN(DL(8,$MXMED)/1,2,3,4,5,6/),
            {  0  $LGN(ALPHI,BPAR,DELPOS(2,$MXMED)),
            {  0  $LGN(WA,PZ,ZELEM,RHOZ($MXMED,$MXEL)),
            {  0  PWR2I($MXPWR2I),
            {  0  $LGN(DELCM,ZBRANG,LZBRANG,NNE($MXMED)),
            {  0  ASYM($MXMED,$MXEL,2);
            {  0  $TYPE     ASYM;
            {  0  $REAL     $LGN(DL/1,2,3,4,5,6/),ALPHI,BPAR,DELPOS,WA,PZ,ZELEM,
            {  0  RHOZ,PWR2I,DELCM,ZBRANG,LZBRANG;
            {  0  $INTEGER  NNE;
            {  0
            {  0  };
               0
               0  " Remove ibcmp, which will go into the cross section options common "
               0  " that will get exported                                            "
               0  REPLACE {;COMIN/COMPTON-DATA/;} WITH {
            {  0
            {  0  ;common/compton_data/ iz_array($MXTOTSH),be_array($MXTOTSH),
            {  0  Jo_array($MXTOTSH),erfJo_array($MXTOTSH),
            {  0  ne_array($MXTOTSH),shn_array($MXTOTSH),
            {  0  shell_array($MXMDSH,$MXMED),
            {  0  eno_array($MXMDSH,$MXMED),
            {  0  eno_atbin_array($MXMDSH,$MXMED),n_shell($MXMED);
            {  0  $INTEGER              iz_array,ne_array,shn_array,
            {  0  shell_array,eno_atbin_array,n_shell;
            {  0  $REAL                 be_array,Jo_array,erfJo_array,eno_array;
            {  0
            {  0  };
               0
               0  " Remove iedgfl and iphter, to go into the cross section options common "
               0  REPLACE {;COMIN/EDGE/;} WITH
               0  {;
            {  0  COMMON/EDGE/binding_energies($MXSHXSEC,$MXELEMENT),
            {  0  interaction_prob($MXSHELL,$MXELEMENT),
            {  0  relaxation_prob($MXTRANS,$MXELEMENT),
            {  0  edge_energies($MXEDGE,$MXELEMENT),
            {  0  edge_number($MXELEMENT),
            {  0  edge_a($MXEDGE,$MXELEMENT),
            {  0  edge_b($MXEDGE,$MXELEMENT),
            {  0  edge_c($MXEDGE,$MXELEMENT),
            {  0  edge_d($MXEDGE,$MXELEMENT);
            {  0  $REAL       binding_energies, interaction_prob, relaxation_prob,
            {  0  edge_energies, edge_a,edge_b,edge_c,edge_d;
            {  0  $INTEGER    edge_number;
            {  0  };
               0
               0  " Remove spin_effects, which determines a cross section being used     "
               0  " and is therefore logically better to be in the cross section options "
               0  " common. smaxir used to be an array that provides a max. geometrical  "
               0  " step size restriction on a region-by-region basis. But we wish to    "
               0  " decouple EGSnrc for the geometry (see comments about ecut, pcut      "
               0  " above). smaxir, smax_new are set by default to 1e10, i.e. no step    "
               0  " size restriction. If the user wishes to control smax, possibly on a  "
               0  " region by region bases, then                                         "
               0  "   - set smaxir to the desired value in start_new_particle()          "
               0  "   - set smax_new to the desired value in howfar(), if the particle   "
               0  "     will enter a new region after the step.                          "
               0  REPLACE {;COMIN/ET-Control/;} WITH {
            {  0  ;common/ET_control/
            {  0  smaxir,smax_new,estepe,ximax,skindepth_for_bca,
            {  0  transport_algorithm,bca_algorithm,exact_bca;
            {  0  $REAL     smaxir,smax_new,estepe,ximax,skindepth_for_bca;
            {  0  $INTEGER  transport_algorithm,bca_algorithm;
            {  0  $LOGICAL  exact_bca;
            {  0  };
               0
               0  " From MEDIA, the only variables that the C user should have access to "
               0  " rho and nmed (the functions egs_add_medium and egs_set_medium are    "
               0  " provided for accessing media names)                                  "
               0  " => split COMIN/MEDIA/ into 2 commons and export only the second      "
               0  REPLACE {;COMIN/MEDIA/;} WITH {
            {  0  ;COMMON/MEDIA_p/ $LGN(RLC,RLDU,MSGE,MGE,MSEKE,
            {  0  MEKE,MLEKE,MCMFP,MRANGE,IRAYLM,IPHOTONUCM($MXMED)),
            {  0  MEDIA(24,$MXMED);
            {  0  $TYPE    MEDIA;
            {  0  $REAL    RLC,RLDU;
            {  0  $INTEGER MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE,IRAYLM,
            {  0  IPHOTONUCM;
            {  0  common/media/   rho($MXMED),photon_xsections,eii_xfile,
            {  0  comp_xsections,photonuc_xsections,
            {  0  nmed;
            {  0  $REAL           rho;
            {  0  $INTEGER        nmed;
            {  0  character*16    photon_xsections;
            {  0  character*16    eii_xfile;
            {  0  character*16    comp_xsections;
            {  0  character*16    photonuc_xsections;
            {  0  };
               0
               0  " IRAYLR gets removed and goes into the x-section options.             "
               0  " rhor and med are also removed so that EGSnrc can be decoupled from the"
               0  " geometry (see comment about ecut, pcut and also smax above)          "
               0  " EGSnrc obtains medium information in the following manner:           "
               0  "  - in start_new_particle() the user must set medium and rhor (in     "
               0  "    common/useful/) to the medium index and mass density scaling for  "
               0  "    region of the top particle on the stack. rhor is the ratio of the "
               0  "    mass density in that region to the default mass density of the    "
               0  "    medium occupying the region and is normally 1, but can be used    "
               0  "    to overwrite the default mass density. Note that this is different"
               0  "    from the original EGSnrc implementation where rhor(irl) was the   "
               0  "    actual mass density, not the ratio of actual to default.          "
               0  "  - in howfar(), the user must set medium_new and rhof_new to the     "
               0  "    values in the new region, if the particle will enter a new region "
               0  "    after the step.                                                   "
               0
               0  REPLACE {;COMIN/EII-DATA/;} WITH {;
            {  0  common/eii_data/
            {  0  eii_xsection_a($MAX_EII_BINS), "EII x-section interpolation coeff."
            {  0  eii_xsection_b($MAX_EII_BINS), "EII x-section interpolation coeff."
            {  0  eii_cons($MXMED),
            {  0  eii_a($MAX_EII_SHELLS),        "energy grid coeff. for each shell "
            {  0  eii_b($MAX_EII_SHELLS),        "energy grid coeff. for each shell "
            {  0  eii_L_factor,                  "L-shell EII xsection scaling factor"
            {  0  eii_z($MAX_EII_SHELLS),        "Z of each shell                   "
            {  0  eii_sh($MAX_EII_SHELLS),       "shell type (1=K, 2=LI, eyc.)      "
            {  0  eii_nshells($MXELEMENT),       "No. of EII shells for each element"
            {  0  eii_nsh($MXMED),               "No. of EII shells for each medium "
            {  0  eii_first($MXMED,$MXEL),       "First EII shell in the list of shells"
            {  0  eii_no($MXMED,$MXEL);          "N. of EII shells                  "
            {  0  $REAL     eii_xsection_a,eii_xsection_b,eii_a,eii_b,eii_cons,eii_L_factor;
            {  0  $INTEGER  eii_z,eii_sh,eii_nshells;
            {  0  $INTEGER  eii_first,eii_no;
            {  0  $INTEGER  eii_elements,eii_nsh;
            {  0  };
               0
               0  REPLACE {;COMIN/MISC/;} WITH {
            {  0  ;common/misc/ DUNIT,KMPI,KMPO;
            {  0  $REAL        DUNIT;
            {  0  $INTEGER     KMPI,KMPO;
            {  0  };
               0
               0  REPLACE {;COMIN/USEFUL/;} WITH {
            {  0  ;common/useful/ pzero, prm, prmt2, rm, rhor, rhor_new, medium, medium_new,
            {  0  medold;
            {  0  real*8         pzero, prm, prmt2;
            {  0  $REAL          rm, rhor, rhor_new;
            {  0  $INTEGER       medium, medium_new, medold;
            {  0  data rm,prm,prmt2,pzero/0.5109989461,0.5109989461,1.0219978922,0.D0/;
            {  0  };
               0
               0  " And now the cross section options common                             "
               0  " Some of the flags were originally arrays for turning on/off options  "
               0  " on a region-by-rgion basis (ibcmp, iraylr, iedgfl, iphter).          "
               0  " If you wish to change the options from their default, use this common"
               0  " For the options that need data to be loaded (iraylr, ibcmp, iedgfl,  "
               0  " ibr_nist, spin_effects), make sure that they are set before calling  "
               0  " hatch. If you want to vary these options by region, then             "
               0  "   - set the appropriate ausgab flag to be called before the          "
               0  "     interaction                                                      "
               0  "   - in ausgab, set the flag to the desired value.                    "
               0  REPLACE {;COMIN/X-OPTIONS/;} WITH {
            {  0  ;common/xsection_options/ ibrdst, iprdst, ibr_nist, spin_effects,
            {  0  ibcmp,iraylr,iedgfl,iphter,pair_nrc,itriplet,
            {  0  radc_flag,eii_flag,iphotonuc,
            {  0  eadl_relax, mcdf_pe_xsections;
            {  0  $INTEGER                 ibrdst, iprdst, ibr_nist,eii_flag,iphotonuc,
            {  0  ibcmp,iraylr,iedgfl,iphter,pair_nrc,
            {  0  radc_flag,itriplet;
            {  0  $LOGICAL                 spin_effects;
            {  0  $LOGICAL  eadl_relax, mcdf_pe_xsections;
            {  0  };
               0
               0  " Again, to remove geometry dependence make e_max_rr and i_do_rr sclars"
               0  REPLACE {;COMIN/EGS-VARIANCE-REDUCTION/;} WITH {;
            {  0  common/egs_vr/  e_max_rr, e_max_rr_new, prob_RR, nbr_split, i_play_RR,
            {  0  i_survived_RR, n_RR_warning, i_do_rr;
            {  0  $REAL          e_max_rr,e_max_rr_new,prob_RR;
            {  0  $INTEGER       nbr_split,i_play_RR,i_survived_RR,n_RR_warning, i_do_rr;
            {  0  };
               0
               0  " We now have to replace all occurences of arrays of dimension $MXREG "
               0  " to scalars                                                          "
               0  REPLACE {pcut(#)} WITH {pcut};
               0  REPLACE {PCUT(#)} WITH {pcut};
               0  REPLACE {ecut(#)} WITH {ecut};
               0  REPLACE {ECUT(#)} WITH {ecut};
               0  REPLACE {med(#)} WITH {med};
               0  REPLACE {MED(#)} WITH {med};
               0  REPLACE {rhor(#)} WITH {rhor};
               0  REPLACE {RHOR(#)} WITH {rhor};
               0  REPLACE {ibcmp(#)} WITH {ibcmp};
               0  REPLACE {IBCMP(#)} WITH {ibcmp};
               0  REPLACE {iraylr(#)} WITH {iraylr};
               0  REPLACE {IRAYLR(#)} WITH {iraylr};
               0  REPLACE {iedgfl(#)} WITH {iedgfl};
               0  REPLACE {IEDGFL(#)} WITH {iedgfl};
               0  REPLACE {iphter(#)} WITH {iphter};
               0  REPLACE {IPHTER(#)} WITH {iphter};
               0  REPLACE {smaxir(#)} WITH {smaxir};
               0  REPLACE {SMAXIR(#)} WITH {smaxir};
               0  REPLACE {e_max_rr(#)} WITH {e_max_rr};
               0  REPLACE {i_do_rr(#)} WITH {i_do_rr};
               0  REPLACE {iphotonucr(#)} WITH {iphotonuc};
               0  REPLACE {IPHOTONUCR(#)} WITH {IPHOTONUC};
               0
               0  " Set default values "
               0  REPLACE {$set-region-by-region-defaults;} WITH {;
            {  0  ecut = 0; pcut = 0; smaxir = $MAX-SMAX;
            {  0  ecut_new = 0; pcut_new = 0; smax_new = $MAX-SMAX;
            {  0  rhor = 1; rhor_new = 1;
            {  0  ibcmp = $IBCMP-DEFAULT;
            {  0  iraylr = $IRAYLR-DEFAULT; iphotonuc=$IPHOTONUCR-DEFAULT;
            {  0  iedgfl = $IEDGFL-DEFAULT; iphter = $IPHTER-DEFAULT;
            {  0  i_do_rr = 0; e_max_rr = 0; e_max_rr_new = 0;
            {  0  };
               0
               0  "below replaces version in $HEN_HOUSE/egsnrc.macros"
               0  "necessary for setting smax_new to default SMAX in the case where"
               0  "smaxir was set by the user <=0.  Both SMAXIR and smax_new must then be reset"
               0  "to the default SMAX.  Situation arises because user values are input"
               0  "after setting defaults via the $set-region-by-region-defaults macro"
               0  "above."
               0  REPLACE {$HATCH-USER-INPUT-INIT;} WITH {;
            {  0  DO J=1,$MXREG [
            {  0  IF(smaxir(J)<=0.0) [smaxir(J)=$MAX-SMAX;]
            {  0  ]
            {  0  IF(smax_new<=0.0) [smax_new=$MAX-SMAX;]
            {  0  ;}
               0
               0  " Should bound compton data be loaded ? "
               0  REPLACE {$need_bound_compton_data(#);} WITH { {P1} = ibcmp.gt.0; };
               0
               0  " Should relaxation data be loaded ? "
               0  REPLACE {$need_relaxation_data(#);} WITH {
            {  0  {P1} = (iedgfl.gt.0.and.iedgfl.le.100);
            {  0  };
               0
               0  " Are Rayleigh data required ? "
               0  REPLACE {$need_rayleigh_data;} WITH {;
            {  0  DO j=1,nmed [ iraylm(j) = iraylr; ]
            {  0  };
               0
               0  " Are photonuclear data required ? "
               0  REPLACE {$need_photonuc_data;} WITH {;
            {  0  DO j=1,nmed [ iphotonucm(j) = iphotonuc; ]
            {  0  };
               0
               0  " rhor, ecut, pcut initializtion in hatch "
               0  REPLACE {$adjust_rhor_ecut_pcut;} WITH {;
            {  0  DO md=1,nmed [
            {  0  ecut = max(ecut,ae(md));
            {  0  pcut = max(pcut,ap(md));
            {  0  ]
            {  0  };
               0
               0  " hownear and range discard: before calling hownear, we set e_range in "
               0  " common/epcont/ to the residual range of the electron and idisc to 0  "
               0  " In hownear the user calculates the minimum perpendicular distance to "
               0  " a boundary. If the user wishes to range-discard the electron, he/she "
               0  " should set idisc (also in /epcont/) to 50 + 49*iq(np).               "
               0
               0  REPLACE {$CALL-HOWNEAR(#);} WITH {
            {  0  e_range = range; idisc = 0; call egs_hownear({P1});
            {  0  };
               0
               0  REPLACE {$CALL-HOWFAR-IN-ELECTR;} WITH {;
            {  0  IF(callhowfar | wt(np) <= 0) [ call egs_howfar; ]
            {  0  };
               0
               0  REPLACE {$CALL-HOWFAR-IN-PHOTON;} WITH {;
            {  0  IF( ustep > dnear(np) | wt(np) <= 0 ) [ call egs_howfar; ]
            {  0  };
               0
               0  REPLACE {$AUSCALL(#);} WITH {
            {  0  iarg={P1};
            {  0  IF (IAUSFL(IARG+1).NE.0) [call egs_ausgab(iarg);]
            {  0  };
               0
               0
               0
               0  " Range discard is up to the user
               0  REPLACE {$RANGE-DISCARD;} WITH {;
            {  0  IF( idisc > 0 ) goto :USER-ELECTRON-DISCARD:;
            {  0  };
               0
               0  " Minimum ecut for default min. step-size for PRESTA-I BCA "
               0  REPLACE {$set_ecutmn;} WITH {
            {  0  ecutmn = 1e30;
            {  0  DO i=1,nmed [
            {  0  ecutmn = Min(ecutmn,ae(i));
            {  0  ]
            {  0  ecutmn = Max(ecutmn,ecut);
            {  0  };
               0
               0  REPLACE {$start_new_particle;} WITH {
            {  0  call egs_start_particle;
            {  0  IF( idisc > 0 ) [ np=np-1; return; ]
            {  0  };
               0
               0  REPLACE {$electron_region_change;} WITH {
            {  0  ir(np) = irnew; irl = irnew; rhor = rhor_new;
            {  0  medium = medium_new; ecut = ecut_new; smaxir = smax_new;
            {  0  Bx=Bx_new;By=By_new;Bz=Bz_new;
            {  0  };
               0
               0  REPLACE {$photon_region_change;} WITH {
            {  0  ir(np) = irnew; irl = irnew; rhor = rhor_new;
            {  0  medium = medium_new; pcut = pcut_new;
            {  0  };
               0
               0  REPLACE {$SET-RHOF;} WITH { rhof = rhor; };
               0
               0  REPLACE {$default_nmed} WITH {0};
               0
               0  REPLACE {narg = iargc();} WITH {call egs_iargc(narg);};
               0  REPLACE {call getarg(#,#);} WITH {call egs_getarg({P1},{P2});};
               0
               0  " The following set of macros is there so that $MXSTACK and $MXMED "
               0  " get defined via the macros in array_sizes.h                      "
               0  REPLACE {$MXMED} WITH {max_med};
               0  REPLACE {$MXSTACK} WITH {max_stack};
               0  REPLACE {;COMIN/STACK/;} WITH {;
            {  0  integer max_stack; parameter (max_stack = MXSTACK);
            {  0  common/stack/
            {  0  $LGN(E,X,Y,Z,U,V,W,DNEAR,WT,IQ,IR,LATCH($MXSTACK)),
            {  0  LATCHI,NP,NPold;
            {  0  $ENERGY PRECISION E;
            {  0  $REAL             X,Y,Z,U,V,W,DNEAR,WT;
            {  0  $INTEGER          IQ,IR,LATCH,LATCHI,NP,NPold;
            {  0  };
               0  REPLACE {$COMIN-BREMS;} WITH {;
            {  0  ;integer max_med; parameter (max_med = MXMED);
            {  0  ;COMIN/DEBUG,BREMPR,EPCONT,NIST-BREMS,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
            {  0  EGS-VARIANCE-REDUCTION,EGS-IO/;
            {  0  };
               0  REPLACE {$COMIN-HATCH;} WITH {;
            {  0  ;integer max_med; parameter (max_med = MXMED);
            {  0  ;COMIN/DEBUG,BOUNDS,BREMPR,ELECIN,MEDIA,MISC,PHOTIN,STACK,THRESH,
            {  0  UPHIIN,UPHIOT,USEFUL,USER,RANDOM,ET-Control,
            {  0  EGS-VARIANCE-REDUCTION,EGS-IO/;
            {  0  };
               0  REPLACE {$COMIN-PAIR;} WITH {;
            {  0  ;integer max_med; parameter (max_med = MXMED);
            {  0  ;COMIN/DEBUG,BREMPR,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
            {  0  EPCONT,NRC-PAIR-DATA,TRIPLET-DATA,EGS-VARIANCE-REDUCTION,EGS-IO/;
            {  0  };
               0  REPLACE {$COMIN-PHOTO;} WITH {;
            {  0  ;integer max_med; parameter (max_med = MXMED);
            {  0  ;COMIN/BOUNDS,BREMPR,DEBUG,EDGE,EPCONT,MEDIA,PHOTIN,RANDOM,
            {  0  STACK,UPHIOT,USEFUL,EGS-VARIANCE-REDUCTION,EGS-IO,RELAX-DATA/;
            {  0  };
               0  REPLACE {$COMIN-PHOTON;} WITH {;
            {  0  ;integer max_med; parameter (max_med = MXMED);
            {  0  ;COMIN/DEBUG,BOUNDS,MEDIA,MISC,EPCONT,PHOTIN,STACK,THRESH,UPHIOT,
            {  0  USEFUL,USER,RANDOM,EGS-VARIANCE-REDUCTION,EGS-IO/;
            {  0  };
               0  REPLACE {$COMIN-SET-DEFAULTS;} WITH {;
            {  0  ;integer max_med; parameter (max_med = MXMED);
            {  0  ;COMIN/BOUNDS,BREMPR,COMPTON-DATA,EDGE,ELECIN,EPCONT,CH-Steps,ET-Control,
            {  0  MEDIA,MISC,PHOTIN,RANDOM,STACK,THRESH, UPHIIN,UPHIOT,USEFUL,
            {  0  EGS-VARIANCE-REDUCTION,EGS-IO,Spin-Data,EII-DATA,rayleigh_inputs,
            {  0  EMF-INPUTS/;
            {  0  };
               0  REPLACE {$COMIN-INIT-COMPT;} WITH {;
            {  0  ;integer max_med; parameter (max_med = MXMED);
            {  0  ;COMIN/COMPTON-DATA,BREMPR,EDGE,MEDIA,MISC,USEFUL,EGS-IO/;
            {  0  };
               0  REPLACE {$COMIN-COMPT;} WITH {;
            {  0  ;integer max_med; parameter (max_med = MXMED);
            {  0  ;COMIN/COMPTON-DATA,DEBUG,EPCONT,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
            {  0  EGS-VARIANCE-REDUCTION,EGS-IO,RELAX-DATA/;
            {  0  };
               0  REPLACE {$COMIN-ELECTR;} WITH {;
            {  0  ;integer max_med; parameter (max_med = MXMED);
            {  0  ;COMIN/DEBUG,BOUNDS,ELECIN,EPCONT,MEDIA,MISC,STACK,THRESH,
            {  0  UPHIIN,UPHIOT,USEFUL,USER,RANDOM,ET-Control,CH-Steps,
            {  0  EGS-VARIANCE-REDUCTION,EGS-IO,EMF-INPUTS/;
            {  0  };
               0  REPLACE {$COMIN-MSCATI;} WITH {;
            {  0  ;integer max_med; parameter (max_med = MXMED);
            {  0  ;COMIN/BOUNDS,ELECIN,MEDIA,MISC,RANDOM,ET-Control,USEFUL,EGS-IO/;
            {  0  };
               0  REPLACE {$COMIN-MOLLER;} WITH {;
            {  0  ;integer max_med; parameter (max_med = MXMED);
            {  0  ;COMIN/DEBUG,STACK,THRESH,UPHIOT,USEFUL,RANDOM,
            {  0  EGS-VARIANCE-REDUCTION,EGS-IO/;
            {  0  };
               0  REPLACE {$COMIN-BHABHA;} WITH {;
            {  0  ;integer max_med; parameter (max_med = MXMED);
            {  0  ;COMIN/DEBUG,STACK, THRESH,UPHIOT,USEFUL,RANDOM,EGS-VARIANCE-REDUCTION,
            {  0  EGS-IO/;
            {  0  };
               0
               0  REPLACE {$COMIN-EII-INIT;} WITH {;
            {  0  ;integer max_med; parameter (max_med = MXMED);
            {  0  ;COMIN/BREMPR,EDGE,EGS-IO,EII-DATA,ELECIN,MEDIA,THRESH,USEFUL/;
            {  0  };
               0  REPLACE {$COMIN-EII-SAMPLE;} WITH {
            {  0  ;integer max_med; parameter (max_med = MXMED);
            {  0  ;COMIN/EPCONT,EII-DATA,EGS-VARIANCE-REDUCTION,RANDOM,STACK,THRESH,
            {  0  UPHIOT,USEFUL,EGS-IO,RELAX-DATA/;
            {  0  };
               0
               0  REPLACE {$declare_max_medium;} WITH {
            {  0  ;integer max_med; parameter (max_med = MXMED);
            {  0  };
               0
               0  #include 'array_sizes.h';
               0  #ifdef SINGLE;
               0  #define EGS_Float real*4;
               0  #else;
               0  #define EGS_Float real*8;
               0  #endif;
               0  #define EGS_Float4 real*4;
               0
               0  " The following set of macros takes care of the various cross section "
               0  " options being available when needed                                 "
               0
               0  APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-SET-DEFAULTS;};
               0  APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-BREMS;};
               0  APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-COMPT;};
               0  APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-ELECTR;};
               0  APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-HATCH;};
               0  APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-INIT-COMPT;};
               0  APPEND {;COMIN/THRESH,X-OPTIONS/;} TO {$COMIN-MSCATI;};
               0  APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-PAIR;};
               0  APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-PHOTO;};
               0  APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-PHOTON;};
               0  APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-EII-INIT;};
               0  APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-INIT-TRIPLET;};
               0  "APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-GET-TRANSPORTP;}; already there"
               0  APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-MOLLER;};
               0  APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-RADC-INIT;};
               0  APPEND {;COMIN/X-OPTIONS/;} TO {$COMIN-INIT-NIST-BREMS;};
               0
               0  " make a couple of renames "
               0  REPLACE {subroutine egs_init;} WITH {subroutine egs_init_f;};
               0  REPLACE {SUBROUTINE HATCH;} WITH {subroutine egs_hatch;};
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  C##############################################################################
               0  C
               0  C   This file was automatically generated by configure version 2.0
               0  C   It contains various subroutines and functions for date, time,
               0  C   CPU time, host name, etc.
               0  C
               0  C   Attention: all changes will be lost the next time you run configure!
               0  C
               0  C##############################################################################
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_system subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C egs_system(command)  runs a system command and returns the status
               0  C                      command must be null-terminated
               0  C*****************************************************************************
               0  integer function egs_system(command)
               0  character*(*) command
               0  integer system, istat
               0  istat = system(command)
               0  egs_system = istat
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_isdir subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C  egs_isdir(file_name)  Returns .true., if the string file_name points to
               0  C                        an existing directory. This version uses the lstat
               0  C                        intrinsic and then tests for bit 14 being set in
               0  C                        the mode element. This works on all Unix systems
               0  C                        that I have access to (Linux, Aix, HP-UX, OSF1,
               0  C                        Solaris, IRIX)
               0  C
               0  C*****************************************************************************
               0
               0  logical function egs_isdir(file_name)
               0  implicit none
               0  character*(*) file_name
               0  integer*4 lnblnk1, res, array(13), l, lstat
               0  logical btest
               0  egs_isdir = .false.
               0  l = lnblnk1(file_name)
               0  if( l.lt.len(file_name) ) file_name(l+1:l+1) = char(0)
               0  ! On some systems lstat only works if the string is 0-terminated
               0  res = lstat(file_name,array)
               0  if( l.lt.len(file_name) ) file_name(l+1:l+1) = ' '
               0  if( res.eq.0 ) then
               0  ! Amost all compilers that have the lstat intrinsic return the
               0  ! file mode in the 3rd array element. But the PGI compiler has
               0  ! its own opinion on the subject and returns it in the 5th element
               0  ! That's why the relevant element is written as 3
               0  ! here, 3 gets replaced by the appropriate element
               0  ! by the configure script.
               0  if( btest(array(3),14) ) egs_isdir = .true.
               0  end if
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc date subroutines v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C***************************************************************************
               0  C
               0  C   egs_fdate(out):  print a 24 char date and time string in the form
               0  C                         'Tue Mar 18 08:16:42 2003'
               0  C                    to the unit specified by out without end of line
               0  C                    i.e. the sequence
               0  C                    write(6,'(a,$)') 'Today is '
               0  C                    call egs_fdate(6)
               0  C                    write(6,'(a)') '. Have a nice date'
               0  C                    should result in something like
               0  C                    Today is Tue Mar 18 08:16:42 2003. Have a nice date
               0  C                    printed to unit 6.
               0  C
               0  C***************************************************************************
               0
               0  subroutine egs_fdate(ounit)
               0  integer ounit
               0  character*24 string
               0  call fdate(string)
               0  write(ounit,'(a,$)') string
               0  end
               0
               0  C***************************************************************************
               0  C
               0  C   egs_get_fdate(string) assignes a 24 char date and time string to string
               0  C                         string must be at least 24 chars long, otherwise
               0  C                         this subroutine has no effect.
               0  C
               0  C***************************************************************************
               0
               0  subroutine egs_get_fdate(string)
               0  character*(*) string
               0  if( len(string).ge.24 ) call fdate(string)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_date_and_time subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  subroutine egs_date_and_time(vnow)
               0  integer vnow(8)
               0  character dat*8,tim*10,zon*5
               0  call date_and_time(dat,tim,zon,vnow)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_date subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*************************************************************************
               0  C
               0  C egs_date(ounit): print a 11 char string in the form
               0  C                     '18-Mar-2003'
               0  C                  to the unit specified by ounit
               0  C                  No end of line character is inserted
               0  C
               0  C*************************************************************************
               0
               0  subroutine egs_date(ounit)
               0  integer ounit
               0  character string*24, dat*11
               0  call fdate(string)
               0  dat(1:2) = string(9:10)
               0  dat(3:3) = '-'
               0  dat(4:6) = string(5:7)
               0  dat(7:7) = '-'
               0  dat(8:11) = string(21:24)
               0  write(ounit,'(a,$)') dat
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_time subroutine v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C $Id: egs_time_v1.f,v 1.1 2003/07/11 19:17:08 iwan Exp $
               0  C*************************************************************************
               0  C
               0  C egs_time(ounit): print a 8 char string in the form hh:mm:ss
               0  C                  to the unit specified by ounit
               0  C                  No end of line character is inserted
               0  C
               0  C*************************************************************************
               0
               0  subroutine egs_time(ounit)
               0  integer ounit
               0  character string*24
               0  call fdate(string)
               0  write(ounit,'(a,$)') string(12:19)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc seconds timing subroutines v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C real function egs_secnds(t0): returns seconds passed since midnight minus t0
               0  C
               0  C*****************************************************************************
               0
               0  real function egs_secnds(t0)
               0  real t0,t1
               0  character dat*8,tim*10,zon*5
               0  integer values(8)
               0  call date_and_time(dat,tim,zon,values)
               0  t1 = 3600.*values(5) + 60.*values(6) + values(7) + 0.001*values(8)
               0  egs_secnds = t1 - t0
               0  return
               0  end
               0
               0  C*****************************************************************************
               0  C
               0  C real function egs_tot_time()
               0  C
               0  C   On first call returns seconds passed since 1/1/1970
               0  C   On subsequent calls returns
               0  C     - seconds since last call, if flag = 0
               0  C     - seconds since first call, else
               0  C
               0  C*****************************************************************************
               0
               0  real function egs_tot_time(flag)
               0  integer flag
               0  character dat*8,tim*10,zon*5
               0  integer vnow(8), vlast(8),i
               0  real t,egs_time_diff,t0
               0  data vlast/1970,1,1,5*0/,t0/-1/
               0  save vlast,t0
               0  call date_and_time(dat,tim,zon,vnow)
               0  t = egs_time_diff(vlast,vnow)
               0  do i=1,8
               0  vlast(i)=vnow(i)
               0  end do
               0  if( t0.lt.0 ) then
               0  t0 = 0
               0  egs_tot_time = t
               0  else
               0  t0 = t0 + t
               0  if(flag.eq.0) then
               0  egs_tot_time = t
               0  else
               0  egs_tot_time = t0
               0  end if
               0  end if
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc date and time subroutines
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C****************************************************************************
               0  C
               0  C Returns the time difference between vstart and vend
               0  C vstart and vend are integer arrays of dimension 8 with elements
               0  C corresponding to the specification of the data_and_time routine, i.e.
               0  C   array(1) = year
               0  C   array(2) = month of the year   (1...12)
               0  C   array(3) = day of the month    (1...31)
               0  C   array(4) = difference in minutes from UTC
               0  C   array(5) = hour of the day     (1...23)
               0  C   array(6) = minute of the hour  (1...59)
               0  C   array(7) = seconds of the minute (1...59)
               0  C   array(8) = miliseconds of the second (1...999)
               0  C
               0  C Note: this implementation ignores the time difference from UTC field
               0  C
               0  C*****************************************************************************
               0  real function egs_time_diff(vstart,vend)
               0  integer    vstart(8),vend(8)
               0  real       egs_time_diff_o
               0  if( vend(1).lt.vstart(1).or.
               0  &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
               0  egs_time_diff = -egs_time_diff_o(vend,vstart)
               0  else
               0  egs_time_diff = egs_time_diff_o(vstart,vend)
               0  end if
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C day difference between the dates specified by the integer arrays vstart and
               0  C vend. The arrays are v(1)=year, v(2)=month, v(3)=day
               0  C
               0  C******************************************************************************
               0  integer function egs_day_diff(vstart,vend)
               0  integer vstart(3),vend(3),egs_day_diff_o
               0  if( vend(1).lt.vstart(1).or.
               0  &  (vend(1).eq.vstart(1).and.vend(2).lt.vstart(2)) ) then
               0  egs_day_diff = -egs_day_diff_o(vend,vstart)
               0  else
               0  egs_day_diff = egs_day_diff_o(vstart,vend)
               0  end if
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Returns a 3-letter abreviation of the day of the week in the string day,
               0  C given a day specified by the integer array values
               0  C   values(1)=year, values(2)=month, values(3)=day
               0  C
               0  C******************************************************************************
               0  subroutine egs_weekday(values,day)
               0  character*(*) day
               0  integer       values(3)
               0  integer       days,vtmp(3),egs_day_diff,aux
               0  character*3   wdays(7)
               0  data wdays/'Mon','Tue','Wed','Thu','Fri','Sat','Sun'/
               0  vtmp(1) = 1970
               0  vtmp(2) = 1
               0  vtmp(3) = 1
               0  days = egs_day_diff(vtmp,values)
               0  aux = mod(days,7)
               0  days = 4 + aux
               0  if( days.gt.7 ) days = days - 7
               0  day(:len(day)) = ' '
               0  aux = min(len(day),3)
               0  day(:aux) = wdays(days)(:aux)
               0  return
               0  end
               0
               0  C*****************************************************************************
               0  C
               0  C Same as egs_day_diff above, but assumes that vend specifies a later date
               0  C than vstart.
               0  C
               0  C*****************************************************************************
               0  integer function egs_day_diff_o(vstart,vend)
               0  integer vstart(3),vend(3)
               0  integer    days
               0  logical    next_month
               0  integer    tm,m,ty,y
               0  integer    mdays(12)
               0  data       mdays/31,28,31,30,31,30,31,31,30,31,30,31/
               0  days = 0
               0  ty = vstart(1)
               0  y  = vend(1)
               0  tm = vstart(2)
               0  m  = vend(2)
               0  next_month = .true.
               0  do while(next_month)
               0  if( tm.eq.m.and.ty.eq.y ) then
               0  next_month = .false.
               0  else
               0  days = days + mdays(tm)
               0  if( tm.eq.2.and.mod(ty,4).eq.0 ) days = days + 1
               0  tm = tm + 1
               0  if( tm.gt.12 ) then
               0  ty = ty + 1
               0  tm = 1
               0  end if
               0  end if
               0  end do
               0  days = days + vend(3) - vstart(3)
               0  egs_day_diff_o = days
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Same as egs_time_diff above, but assumes that vend specifies a later date
               0  C than vstart.
               0  C
               0  C******************************************************************************
               0  real function egs_time_diff_o(vstart,vend)
               0  integer    vstart(8),vend(8)
               0  integer    days,hours,minutes,secs,msecs
               0  integer    egs_day_diff_o
               0  days = egs_day_diff_o(vstart,vend)
               0  hours = vend(5) - vstart(5)
               0  minutes = vend(6) - vstart(6)
               0  secs = vend(7) - vstart(7)
               0  msecs = vend(8) - vstart(8)
               0  egs_time_diff_o = 3600.*(24.*days+hours)+60.*minutes+secs+
               0  &                  0.001*msecs
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Returns in month a 3-letter abreviation of the month specified by mo, if
               0  C mo is between 1 and 12, or an empty string otherwise.
               0  C
               0  C******************************************************************************
               0  subroutine egs_month(mo,month)
               0  integer mo
               0  character*(*) month
               0  integer iaux
               0  character*3   months(12)
               0  data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
               0  *,'Oct','Nov','Dec'/
               0  iaux = min(len(month),3)
               0  month(:len(month)) = ' '
               0  if( mo.ge.1.and.mo.le.12 ) month(:iaux) = months(mo)(:iaux)
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Converts a 3-letter abreviation of a month to its corresponding integer
               0  C value, if the string month is a valid month, or -1 otherwise.
               0  C
               0  C******************************************************************************
               0  integer function egs_conver_month(month)
               0  character*3 month
               0  character*3 months(12)
               0  integer i
               0  data months/'Jan','Feb','Mar','Apr','May','Jun', 'Jul','Aug','Sep'
               0  *,'Oct','Nov','Dec'/
               0  do i=1,12
               0  if( month.eq.months(i) ) then
               0  egs_conver_month = i
               0  return
               0  end if
               0  end do
               0  egs_conver_month = -1
               0  return
               0  end
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc egs_etime subroutine
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C real function egs_etime(): returns CPU time consumed since the start of
               0  C                            the program
               0  C
               0  C*****************************************************************************
               0
               0  real function egs_etime()
               0  real tarray(2),etime
               0  egs_etime = etime(tarray)
               0  return
               0  end
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc canonical system name subroutines
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C******************************************************************************
               0  C
               0  C Print the canonical system name as determined by the config.guess script
               0  C or the Windows installation program to the unit specified by ounit.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_print_canonical_system(ounit)
               0  integer ounit
               0  write(6,'(a,$)') 'x86_64-unknown-linux-gnu'
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Assign the canonical system name as determined by the config.guess script
               0  C or the Windows installation program to the string pointed to by res
               0  C
               0  C******************************************************************************
               0
               0  subroutine egs_get_canonical_system(res)
               0  character*(*) res
               0  integer l1,l2
               0  l1 = lnblnk1('x86_64-unknown-linux-gnu')
               0  l2 = len(res)
               0  res(:l2) = ' '
               0  if( l2.ge.l1 ) then
               0  res(:l1) = 'x86_64-unknown-linux-gnu'
               0  else
               0  res(:l2) = 'x86_64-unknown-linux-gnu'
               0  end if
               0  return
               0  end
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc configuration name subroutines
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C******************************************************************************
               0  C
               0  C Print the configuration name as specified suring the configuration
               0  C process to the unit specified by ounit.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_print_configuration_name(ounit)
               0  integer ounit
               0  write(6,'(a,$)') 'linux'
               0  return
               0  end
               0
               0  C******************************************************************************
               0  C
               0  C Assign the configuration name as specified suring the configuration
               0  C process to the string pointed to by res
               0  C
               0  C******************************************************************************
               0
               0  subroutine egs_get_configuration_name(res)
               0  character*(*) res
               0  integer l1,l2
               0  l1 = lnblnk1('linux')
               0  l2 = len(res)
               0  res(:l2) = ' '
               0  if( l2.ge.l1 ) then
               0  res(:l1) = 'linux'
               0  else
               0  res(:l2) = 'linux'
               0  end if
               0  return
               0  end
               0
               0
               0  C##############################################################################
               0  C
               0  C  EGSnrc hostname subroutines v1
               0  C  Copyright (C) 2015 National Research Council Canada
               0  C
               0  C  This file is part of EGSnrc.
               0  C
               0  C  EGSnrc is free software: you can redistribute it and/or modify it under
               0  C  the terms of the GNU Affero General Public License as published by the
               0  C  Free Software Foundation, either version 3 of the License, or (at your
               0  C  option) any later version.
               0  C
               0  C  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY
               0  C  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
               0  C  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for
               0  C  more details.
               0  C
               0  C  You should have received a copy of the GNU Affero General Public License
               0  C  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.
               0  C
               0  C##############################################################################
               0  C
               0  C  Author:          Iwan Kawrakow, 2003
               0  C
               0  C  Contributors:
               0  C
               0  C##############################################################################
               0
               0
               0  C*****************************************************************************
               0  C
               0  C Print the host name to the unit specified by ounit without inserting
               0  C a new line character.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_print_hostnm(ounit)
               0  integer ounit
               0  character*256 string
               0  integer res,hostnm,lnblnk1
               0  res = hostnm(string)
               0  if( res.ne.0 ) then
               0  write(6,'(a,a)') 'hostnm returned with a non-zero status '
               0  stop
               0  end if
               0  write(ounit,'(a,$)') string(:lnblnk1(string))
               0  return
               0  end
               0
               0  C*****************************************************************************
               0  C
               0  C Assign the host name to the string pointed to be hname.
               0  C
               0  C*****************************************************************************
               0
               0  subroutine egs_get_hostnm(hname)
               0  character*(*) hname
               0  character*256 string
               0  integer res,hostnm,lnblnk1,l1,l2,l
               0  res = hostnm(string)
               0  if( res.ne.0 ) then
               0  write(6,'(a,a)') 'hostnm returned with a non-zero status '
               0  stop
               0  end if
               0  l1 = lnblnk1(string)
               0  l2 = len(hname)
               0  hname(:l2) = ' '
               0  l = min(l1,l2)
               0  hname(:l) = string(:l)
               0  return
               0  end
               0
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc I/O functions                                                       "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Iwan Kawrakow, 2003                                       "
               0  "                                                                             "
               0  "  Contributors:    Dave Rogers                                               "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                   Blake Walters                                             "
               0  "                   Frederic Tessier                                          "
               0  "                   Reid Townson                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  " Iwan Kawrakow, 2004:                                                        "
               0  "                                                                             "
               0  " re-factored egs_init so that it is easy to program a corresponding egs_init "
               0  " when one loads a EGSnrc user code as a library and therefore no command     "
               0  " line arguments are available. (see beam library).                           "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  %I4                                                                            ;
               0  %C80                                                                           ;
               0  %Q1                                                                            ;
               0  !INDENT F2;
               0  REPLACE {$max_unit} WITH {99}
               0
               0  REPLACE {$egs_debug(#,#);} WITH {;} " no need for debug info "
               0
               0  REPLACE {;COMIN/my_times/;} WITH {;
            {  0  common/my_times/ t_elapsed, t_cpu, t_first;
            {  0  $REAL            t_elapsed, t_cpu;
            {  0  integer          t_first(8);
            {  0  real             egs_tot_time,egs_etime;
            {  0  };
               0
               0  "******************************************************************************
               0  " subroutine egs_init;
               0  "******************************************************************************
               0  " A call to this subroutine becomes Step 0 in every EGSnrc user code.
               0  " Its purpose is to:
               0  "   - initialize arrays and default values for various transport options
               0  "     (this was previously done in block data, but due to the GNU Fortran
               0  "     compiler complaints and extremely slow compilation when the number of
               0  "     regions is large, we decided to remove block data from the source)
               0  "   - Process command line arguments specifying input file, pegs4 data file,etc.
               0  "     In the current version the following command line options are supported:
               0  "
               0  "       -i or --input ifile          Input file is ifile.egsinp
               0  "
               0  "       -p or --pegs-file file_name  The pegs4 data file is file_name.pegs4dat
               0  "                                    The system will look for it in the
               0  "                                    HEN_HOUSE and the user's pegs4 data areas
               0  "
               0  "       -o or --output ofile         Output data will be writtent to
               0  "                                    ofile.egslog, ofile.egslst, etc., instead
               0  "                                    of ifile.egslog, etc.
               0  "
               0  "       -H or --hen-house dir        Change the HEN_HOUSE to be dir instead
               0  "                                    of the directory specified in the
               0  "                                    machine.macros file.
               0  "
               0  "       -e or --egs-home dir         Change EGS_HOME to be dir instead of
               0  "                                    the directory specified by the EGS_HOME
               0  "                                    environment variable
               0  "
               0  "       -h or --help                 Print a help message and exit
               0  "                                    ignoring all other arguments
               0  "
               0  "       -b or --batch                Specify a 'batch' run. The difference
               0  "                                    between a 'batch' run and an interactive
               0  "                                    run is that in 'batch' mode unit 6 is
               0  "                                    connected to a file, whereas in intarctive
               0  "                                    mode unit 6 goes to the standard output.
               0  "                                    The file name in batch run is determined
               0  "                                    as follows:
               0  "                                     - ofile.egslog, if ofile was specified
               0  "                                       with the -o option
               0  "                                     - ifile.egslog, if there was no -o option
               0  "                                       used but an input file was specified
               0  "                                       with -i
               0  "                                     - test.egslog, if neither -i nor -o was
               0  "                                       used.
               0  "
               0  "       -P or --parallel n           Tell the system that this run is part of
               0  "                                    a parallel run and that this is job number
               0  "                                    n (so that the random number sequence
               0  "                                    can be initialized differently)
               0  "
               0  "       -c or --chunk N              Tell the system to use N histories per
               0  "                                    calculation 'chunk' in parallel runs.
               0  "
               0  "   - open default EGSnrc data file units thus avoiding the necessity for
               0  "     symbolik links
               0  "   - open user code specific I/O units if a .io file is found in
               0  "     the user code area. The format of this file is an integer
               0  "     followed by a string on every line.
               0  "     The string specifies the file extension
               0  "     and the integer the unit number this file should connect to, e.g.
               0  "       4   .egsdat
               0  "       15  .egserr
               0  "       1   .egslst
               0  "     will result in connecting unit 4 to the file ifile.egsdat
               0  "     (or ofile.egsdat, see above) to unit 4, [i|o]file.egserr to unit 15, etc.
               0  "  -  Outputs a summary to standard output about configuration etc
               0  "  -  Creates a temporary working directory in the user code area
               0  "
               0  "  The files always opened (appart from the ones specified in the .io file)
               0  "  are the following:
               0  "
               0  "  1. The PEGS data file (and so, for now, the -p pegs_file command line
               0  "     option must be always given)
               0  "     The algorithm for looking for a PEGS data file is:
               0  "       - The file name passed with -p. In this way, PEGS files can be located
               0  "         everywhere on the file system (not just in $HEN_HOUSE/pegs4/data
               0  "         and $EGS_HOME/pegs4/data) if the absolute path name is given after
               0  "         the -p option.
               0  "       - $EGS_HOME/pegs4/data/pegs_file or
               0  "         $EGS_HOME/pegs4/data/pegs_file.pegs4dat
               0  "       - $HEN_HOUSE/pegs4/data/pegs_file or
               0  "         $HEN_HOUSE/pegs4/data/pegs_file.pegs4dat
               0  "     See note below on how $HEN_HOUSE and $EGS_HOME are determined
               0  "
               0  "  2. If a -i ifile option was given as argument, ifile.egsinp is
               0  "     opened as fortran unit 5.
               0  "     The input file MUST be in the user code directory on $EGS_HOME
               0  "
               0  "  3. If the run is a batch run (the -b option was present on the command
               0  "     line), fortran unit 6 is connected to an output file with a .egslog
               0  "     extension instead of going to standard output.
               0  "     The algorithm for determining the .egslog file name is the following:
               0  "       - If the -o ofile option was present, the output to unit 6 will go
               0  "         to ofile.egslog
               0  "       - If there was no -o option, but there is an inpuit file specified
               0  "         with -i ifile, output to unit 6 will go to ifile.egslog
               0  "       - If neither of the above is true, the output will go to
               0  "         test.egslog.
               0  "
               0  "  Note on determining EGS_HOME:
               0  "  EGS_HOME is normally taken from the environment variable EGS_HOME.
               0  "  However, one can overwrite the environment by giving the
               0  "    -e | --egs-home  new_egs_home_location
               0  "  option on the command line.
               0  "  EGS_HOME must be set, either via the environment or via the command line,
               0  "  otherwise the job will abort.
               0  "
               0  "  Note on determining HEN_HOUSE:
               0  "  HEN_HOUSE is set to the value defined in machine.macros, which is
               0  "  created by the configure script or the configuration wizard in the GUI
               0  "  This value can be overwritten by giving the
               0  "    -H | --hen-house new_hen_house_location
               0  "  option on the command line.
               0  "  HEN_HOUSE is NOT taken from the environment.
               0  "
               0  "  The name of the temporary working directory is created using
               0  "    egsrun_getpid_ifile_hostname, if there was an input file, or
               0  "    egsrun_getpid_noinput_hostname, if there was no input file specified.
               0  "  In the above, getpid is the process id returned bt the getpid() intrinsic
               0  "  and hostname is the host name as determined by egs_get_hostnm().
               0  "  During run time, all output from the program (the .egslog file and
               0  "  all other files specified in the .io file) is kept in the
               0  "  temporary working directory. After succesful completion, egs_finish
               0  "  moves all output back to the user code area and removes the
               0  "  temporary working directory. This implies that if for whatever reason
               0  "  the job terminates prematurely, the temporary working directory
               0  "  with all output will be left behind.
               0  "
               0  "
               0  "
               0  "******************************************************************************
               0  subroutine egs_init;
               0  "******************************************************************************
               0  implicit none;
               0  ;COMIN/my_times/;
               0  $REAL dum;
               0
               0
               0
               0
               0
               0  call egs_set_defaults;
               0  call egs_check_arguments;
               0  call egs_init1;
               0  return; end;
               0
               0  "******************************************************************************
               0  subroutine egs_init1;
               0  "******************************************************************************
               0
               0  implicit none;
               0  ;COMIN/EGS-IO,MISC,my_times/;
               0  integer   l, lnblnk1, l1, l2;
               0  integer   i;
               0  character arg*256,tmp_string*512, tmp1_string*512, ucode_dir*512,
               0  line*80,
               0  line1*80,dattim*24;
               0  $LOGICAL  have_input,egs_isdir,egs_strip_extension,ex,
               0  on_egs_home,is_opened;
               0  $INTEGER  mypid;
               0  integer   getpid;
               0  integer   istat, egs_system, u, pos1, pos2,egs_get_unit,itmp;
               0  $REAL     dum;
               0  $declare_write_buffer;
               0
               0  t_elapsed = 0; t_cpu = egs_etime(); dum = egs_tot_time(1);
               0  call egs_date_and_time(t_first);
               0
               0  $set_string(line,'=');
               0  $set_string(line1,'.');
               0
               0  " Handy macros for checking command line arguments "
               0  REPLACE {$check_get_argument(#,#,#);} WITH {
            {  0  have_arg = .false.;
            {  0  DO i=1,narg-1 [
            {  0  call getarg(i,{P3}); l = lnblnk1({P3});
            {  0  IF( ( l = lnblnk1({P1}) & {P3}(:l) = {P1} ) |
            {  0  ( l = lnblnk1({P2}) & {P3}(:l) = {P2} ) ) [
            {  0  have_arg = .true.; call getarg(i+1,{P3}); EXIT;
            {  0  ]
            {  0  ]
            {  0  };
               0
               0  REPLACE {$check_argument(#,#,#);} WITH {
            {  0  have_arg = .false.;
            {  0  DO i=1,narg [
            {  0  call getarg(i,{P3}); l = lnblnk1({P3});
            {  0  IF( ( l = lnblnk1({P1}) & {P3}(:l) = {P1} ) |
            {  0  ( l = lnblnk1({P2}) & {P3}(:l) = {P2} ) ) [
            {  0  have_arg = .true.; EXIT;
            {  0  ]
            {  0  ]
            {  0  };
               0
               0  IF(~is_pegsless)[
               1      " Get the pegs4 data file "
               1      on_egs_home = .false.;
               1      inquire(file=pegs_file,exist=ex);
               1      IF( ex ) [
               2          kmpi=egs_get_unit(kmpi);
               2          IF(kmpi<0)[
               3              $egs_fatal(*,'failed to get a free Fortran I/O unit for pegs file');
               3              ]
               2          open(kmpi,file=pegs_file,status='old',err=:open_pegs_error:);
               2          $egs_debug('(a,a)','opened pegs file ',$cstring(pegs_file));
               2          goto :found_pegs_file:;
               2          ]
               1      arg = $cstring(pegs_file);
               1      ex = egs_strip_extension(arg,'.pegs4dat');
               1      l = lnblnk1(egs_home); l1 = lnblnk1('pegs4data') + 2*lnblnk1($file_sep);
               1      l2 = lnblnk1(arg) + lnblnk1('.pegs4dat');
               1      IF( l + l1 + l2 > 256 ) [
               2          $egs_warning(*,'pegs4 data file name (including absolute path)');
               2          $warning('(a,i4,a)','is too long (',l+l1+l2,') characters');
               2          ]
               1      ELSE [
               2          pegs_file = $cstring(egs_home) // 'pegs4' // $file_sep // 'data' //
               2          $file_sep // $cstring(arg) // '.pegs4dat';
               2          $egs_debug('(a,a)','checking for pegs file ',$cstring(pegs_file));
               2          inquire(file=pegs_file,exist=ex);
               2          IF( ex ) [
               3              kmpi=egs_get_unit(kmpi);
               3              IF(kmpi<0)[
               4                  $egs_fatal(*,'failed to get a free Fortran I/O unit for pegs file');
               4                  ]
               3              open(kmpi,file=pegs_file,status='old',err=:open_pegs_error:);
               3              $egs_debug('(a,a)','opened pegs file ',$cstring(pegs_file));
               3              on_egs_home = .true.;
               3              goto :found_pegs_file:;
               3              ]
               2          ]
               1      l = lnblnk1(hen_house);
               1      IF( l + l1 + l2 > 256 ) [
               2          $egs_warning(*,'pegs4 data file name (including absolute path)');
               2          $warning('(a,i4,a)','is too long (',l+l1+l2,') characters');
               2          ]
               1      ELSE [
               2          pegs_file = $cstring(hen_house) // 'pegs4' // $file_sep // 'data' //
               2          $file_sep // $cstring(arg) // '.pegs4dat';
               2          $egs_debug('(a,a)','checking for pegs file ',$cstring(pegs_file));
               2          inquire(file=pegs_file,exist=ex);
               2          IF( ex ) [
               3              kmpi=egs_get_unit(kmpi);
               3              IF(kmpi<0)[
               4                  $egs_fatal(*,'failed to get a free Fortran I/O unit for pegs file');
               4                  ]
               3              open(kmpi,file=pegs_file,status='old',err=:open_pegs_error:);
               3              $egs_debug('(a,a)','opened pegs file ',$cstring(pegs_file));
               3              goto :found_pegs_file:;
               3              ]
               2          ]
               1
               1      $egs_fatal(*,'could not find pegs4 file named ',$cstring(arg));
               1
               1      ]
               0
               0  :found_pegs_file:
               0  ;
               0  " Open egsnrc data files "
               0  $set_string(tmp_string,' ');
               0  tmp_string = $cstring(hen_house) // 'data' // $file_sep;
               0
               0  "set proposed unit numbers"
               0  i_nist_data=76;
               0  i_incoh=78;
               0  i_photo_relax=77;
               0  i_photo_cs=79;
               0  i_mscat=11;
               0
               0  REPLACE {$open_data_file(#,#,#,#);} WITH {;
            {  0  $set_string({P2},' ');
            {  0  {P2} = $cstring({P1}) // {P3};
            {  0  inquire(file={P2},exist=ex,opened=is_opened,number=itmp);
            {  0  IF( ~ex ) [
            {  0  $egs_fatal(*,'EGSnrc data file ',{P3},' does not exist');
            {  0  ]
            {  0  IF( ~is_opened ) [
            {  0  {P4}=egs_get_unit({P4});
            {  0  IF({P4}<0)[
            {  0  $egs_fatal(*,'failed to get a free Fortran I/O unit for data file ',
            {  0  $cstring({P2}));
            {  0  ]
            {  0  open({P4},file={P2},status='old',err=:data_file_error:);
            {  0  ]
            {  0  ELSE [ {P4} = itmp; ]
            {  0  $egs_debug('(a,a)','opened data file ',$cstring({P2}));
            {  0  };
               0  $open_data_file(tmp_string,tmp1_string,'photo_cs.data',$PHOCSUNIT);
               0  $open_data_file(tmp_string,tmp1_string,'msnew.data',$MSCAT-DATAFILE);
               0  $open_data_file(tmp_string,tmp1_string,'incoh.data',$INCOHUNIT);
               0  $open_data_file(tmp_string,tmp1_string,'photo_relax.data',$PHOTOUNIT);
               0
               0  $set_string(ucode_dir,' ');
               0  ucode_dir = $cstring(egs_home) // $cstring(user_code) // $file_sep;
               0
               0  have_input = .false.;
               0  i_input=5;
               0  IF( lnblnk1(input_file) > 0 ) [
               1      have_input = .true.;
               1      l = lnblnk1(egs_home); l1 = lnblnk1(user_code)+1;
               1      l2 = lnblnk1(input_file) + lnblnk1('.egsinp');
               1      IF( l + l1 + l2 > 1024 ) [
               2          $egs_fatal(*,'input file name (including path) is too long ',l+l1+l2);
               2          ]
               1      ex = egs_strip_extension(input_file,'.egsinp');
               1      tmp_string = $cstring(ucode_dir) // $cstring(input_file) // '.egsinp';
               1      inquire(file=tmp_string,exist=ex);
               1      IF( ~ex ) [
               2          $egs_fatal(*,'Input file ',$cstring(tmp_string),' does not exist.');
               2          ]
               1      $AVAILABLE_UNIT(i_input,tmp_string);
               1      open(i_input,file=tmp_string,status='old',err=:open_input_error:);
               1      ]
               0
               0  " Construct a temporary directory name to run from "
               0  $set_string(work_dir,' ');
               0  work_dir = 'egsrun_'; mypid = getpid();
               0  call egs_itostring(work_dir,mypid,.false.);
               0  call egs_get_hostnm(host_name);
               0  IF( lnblnk1(host_name) < 1 ) host_name = 'unknown';
               0  IF( have_input ) [
               1      work_dir = $cstring(work_dir) // '_' // $cstring(input_file) //
               1      '_' // $cstring(host_name) // $file_sep;
               1      ]
               0  ELSE [
               1      work_dir = $cstring(work_dir) // '_noinput_' // $cstring(host_name) //
               1      $file_sep;
               1      ]
               0  $set_string(tmp_string,' ');
               0  tmp_string = $cstring(ucode_dir) // $cstring(work_dir);
               0  DO i=1,lnblnk1(tmp_string) [
               1      IF( tmp_string(i:i) = '/' ) [
               2          tmp_string(i:i) = $file_sep;
               2          ]
               1      ]
               0  ex = egs_isdir(tmp_string);
               0  IF( ex ) [
               1      $egs_fatal(*,'a directory named ',$cstring(tmp_string),' already exists?');
               1      ]
               0  tmp1_string = 'mkdir ' // $cstring(tmp_string);
               0  l = lnblnk1(tmp1_string); tmp1_string(l+1:l+1) = char(0);
               0  " some systems need the command string to be 0 terminated"
               0  istat = egs_system(tmp1_string);
               0  IF( istat ~= 0 ) [
               1      $egs_fatal(*,'failed to create working directory ',$cstring(tmp1_string));
               1      ]
               0
               0  call egs_open_units(.true.);
               0
               0  " Now print a summary of what happened "
               0  $egs_info('(a)',line);
               0  $egs_info('(a,a,t55,a,$)','EGSnrc version 4 for ',$CANONICAL_SYSTEM,' ');
               0  call egs_get_fdate(dattim);
               0  $egs_info('(a,/,a)',dattim,line);
               0
               0  REPLACE {$write_description(#);} WITH {;
            {  0  $egs_info('(a,$)',{P1}); l = pos2 - lnblnk1({P1});
            {  0  $egs_info('(a,$)',line1(:l));
            {  0  };
               0  pos1 = lnblnk1('output file(s)');
               0  pos2 = 80 - lnblnk1($CONFIGURATION_NAME);
               0  pos2 = min(pos2,80-lnblnk1(user_code));
               0  $set_string(tmp_string,' '); tmp_string = pegs_file;
               0  call egs_strip_path(tmp_string);
               0  ex = egs_strip_extension(tmp_string,'.pegs4dat');
               0  IF( on_egs_home ) [ tmp_string = $cstring(tmp_string) // ' on EGS_HOME'; ]
               0  ELSE [ tmp_string = $cstring(tmp_string) // ' on HEN_HOUSE'; ]
               0  IF( lnblnk1(tmp_string) > lnblnk1(pegs_file) ) [
               1      $set_string(tmp_string,' '); tmp_string = pegs_file;
               1      ]
               0  pos2 = min(pos2,80-lnblnk1(tmp_string));
               0  pos2 = min(pos2,80-lnblnk1(host_name));
               0  IF( have_input ) pos2 = min(pos2,80-lnblnk1(input_file));
               0  pos2 = min(pos2,80-lnblnk1(output_file));
               0  IF( pos2 < pos1+2 ) pos2 = pos1 + 2;
               0
               0  $write_description('configuration'); $egs_info('(a)',$CONFIGURATION_NAME);
               0  $write_description('user code'); $egs_info('(a)',$cstring(user_code));
               0  $write_description('pegs file'); $egs_info('(a)',$cstring(tmp_string));
               0  $write_description('using host'); $egs_info('(a)',$cstring(host_name));
               0  IF( have_input ) [
               1      $write_description('input file'); $egs_info('(a)',$cstring(input_file));
               1      ]
               0  $write_description('output file(s)'); $egs_info('(a)',$cstring(output_file));
               0  IF( n_parallel > 0 ) [
               1      $write_description('number of parallel jobs');
               1      $egs_info('(i2)',n_parallel);
               1      $write_description('job number'); $egs_info('(i2)',i_parallel);
               1      ]
               0  $egs_info('(a)',line);
               0
               0  return;
               0
               0  " Errors "
               0  :open_input_error:
               0  $egs_fatal(*,'failed to open input file ',$cstring(tmp_string));
               0
               0  :open_pegs_error:
               0  $egs_fatal(*,'failed to open existing pegs file ',$cstring(pegs_file));
               0
               0  :data_file_error:
               0  $egs_fatal(*,'failed to open EGSnrc data file ',$cstring(tmp1_string));
               0
               0  return; end;
               0
               0  "*****************************************************************************
               0  subroutine egs_check_arguments;
               0  "*****************************************************************************
               0  implicit none;
               0
               0  ;COMIN/EGS-IO/;
               0
               0  character arg*256,tmp_string*512, line1*80;
               0  $LOGICAL  have_arg,egs_isdir,egs_strip_extension,ex,
               0  on_egs_home;
               0  integer   narg, iargc, i, lnblnk1, l, l2,i_help,egs_get_unit;
               0  $declare_write_buffer;
               0
               0  narg = iargc();
               0  IF( narg < 1 ) return;
               0
               0  " Check for hen_house "
               0  $check_get_argument('-H','--hen-house',arg);
               0  IF( have_arg ) [
               1      l = lnblnk1(arg); $set_string(hen_house,' ');
               1      IF( l > 0 ) [
               2          IF( l > 254 ) [
               3              $egs_fatal('(a,i5)',' HEN_HOUSE argument is too long',l);
               3              ]
               2          hen_house(:l) = $cstring(arg);
               2          IF( hen_house(l:l) ~= $file_sep ) hen_house(l+1:l+1) = $file_sep;
               2          ]
               1      ELSE [
               2          $egs_fatal('(a)',' empty argument after -H');
               2          ]
               1      DO i=1,lnblnk1(hen_house) [
               2          IF( hen_house(i:i) = '/' ) [
               3              hen_house(i:i) = $file_sep;
               3              ]
               2          ]
               1      ]
               0  IF( ~egs_isdir(hen_house) ) [
               1      $egs_warning('(a,a)',' HEN_HOUSE directory ',$cstring(hen_house));
               1      $warning('(a)','does not exist. Hope you know what you are doing.');
               1      ]
               0
               0  " Check if the user requested help "
               0  $check_argument('-h','--help',arg);
               0  IF( have_arg ) [
               1      call getarg(0,arg); call egs_strip_path(arg);
               1      $egs_info('(//,a,a,a,//)','Usage: ',$cstring(arg),' [args] ');
               1      tmp_string = $cstring(hen_house) // 'pieces/help_message';
               1      i_help=98;
               1      i_help=egs_get_unit(i_help);
               1      IF(i_help<0)[
               2          $egs_fatal(*,'failed to get a free Fortran I/O unit for help file');
               2          ]
               1      open(i_help,file=tmp_string,status='old',err=:no_help_file:);
               1      LOOP [
               2          read(i_help,'(a)',err=:end_of_help:,end=:end_of_help:) line1;
               2          $egs_info('(a)',line1);
               2          ]
               1      :end_of_help:;
               1      $CALL_EXIT(0);
               1      :no_help_file:;
               1      $egs_fatal(*,'Did not find the help_message file!');
               1      ]
               0
               0  " Check for batch option "
               0  $check_argument('-b','--batch',arg);
               0  IF( have_arg ) is_batch = .true.;
               0
               0  " Check for parallel run option"
               0  $check_get_argument('-P','--parallel',arg);
               0  IF( have_arg ) [
               1      read(arg,*,err=:wrong_parallel_arg:) n_parallel;
               1      IF( n_parallel < 0 ) goto :wrong_parallel_arg:;
               1      goto :ok_parallel_arg:;
               1      :wrong_parallel_arg:;
               1      $egs_warning(*,
               1      ' Wrong/missing parallel job number argument, -P option ignored');
               1      n_parallel = 0;
               1      :ok_parallel_arg:;
               1      ]
               0
               0  $check_get_argument('-j','--job',arg);
               0  IF( have_arg ) [
               1      read(arg,*,err=:wrong_job_arg:) i_parallel;
               1      IF( i_parallel < 0 ) goto :wrong_job_arg:;
               1      goto :ok_job_arg:;
               1      :wrong_job_arg:;
               1      $egs_warning(*,' Wrong/missing job argument, -j option ognored');
               1      i_parallel = 0;
               1      :ok_job_arg:;
               1      ]
               0
               0  $check_get_argument('-f','--first-job',arg);
               0  IF( have_arg ) [
               1      read(arg,*,err=:wrong_first_job_arg:) first_parallel;
               1      IF( first_parallel < 1 ) goto :wrong_first_job_arg:;
               1      goto :ok_first_job_arg:;
               1      :wrong_first_job_arg:;
               1      $egs_warning(*,' Wrong/missing first job argument, -f option ognored');
               1      first_parallel = 1;
               1      :ok_first_job_arg:;
               1      ]
               0
               0  IF( n_parallel > 0 | i_parallel > 0 ) [
               1      IF( n_parallel*i_parallel = 0 ) [
               2          $egs_warning(*,'You need to specify number of jobs AND job number ',
               2          '=> will not use parallel run ');
               2          n_parallel = 0; i_parallel = 0;
               2          ]
               1      IF( first_parallel > i_parallel ) [
               2          $egs_warning(*,'i_parallel (',i_parallel,
               2          ') can not be smaller than first_parallel (',first_parallel,')');
               2          first_parallel = i_parallel;
               2          ]
               1      ]
               0
               0  $egs_debug('(a,a)','HEN_HOUSE is ',$cstring(hen_house));
               0
               0  " Check for egs_home "
               0  $check_get_argument('-e','--egs-home',arg);
               0  IF( have_arg ) [
               1      l = lnblnk1(arg); $set_string(egs_home,' ');
               1      IF( l = 0 ) [
               2          $egs_fatal('(a)',' empty argument after -e');
               2          ]
               1      IF( l > 254 ) [
               2          $egs_fatal('(a,i5)',' EGS_HOME argument is too long ',l);
               2          ]
               1      egs_home(:l) = $cstring(arg);
               1      IF( egs_home(l:l) ~= $file_sep ) egs_home(l+1:l+1) = $file_sep;
               1      DO i=1,lnblnk1(egs_home) [
               2          IF( egs_home(i:i) = '/' ) [
               3              egs_home(i:i) = $file_sep;
               3              ]
               2          ]
               1      ]
               0  IF( ~egs_isdir(egs_home) ) [
               1      $egs_fatal(*,' EGS_HOME directory ',$cstring(egs_home),' does not exist.');
               1      ]
               0  $egs_debug('(a,a)','EGS_HOME is ',$cstring(egs_home));
               0
               0  " Get the pegs4 data file "
               0  on_egs_home = .false.;
               0  is_pegsless=.false.;
               0  $check_get_argument('-p','--pegs-file',arg);
               0  IF( ~have_arg ) [
               1      $egs_warning(*,'No pegs4 file name supplied.  Will assume you are running
            '  1      in pegs-less mode with media details specified in input file.');
               1      is_pegsless=.true.;
               1      ]
               0  ELSE[
               1      pegs_file = $cstring(arg);
               1      ]
               0
               0  " Deduct the user code name from the executable name "
               0  call egs_get_usercode(user_code);
               0
               0  " Check for an input file "
               0  $check_get_argument('-i','--input',arg);
               0  IF( have_arg ) [
               1      ex = egs_strip_extension(arg,'.egsinp');
               1      l2 = lnblnk1(arg) + lnblnk1('.egsinp');
               1      IF( l2 > 256 ) [
               2          $egs_fatal(*,'input file name is too long ',l2);
               2          ]
               1      input_file = $cstring(arg);
               1      ]
               0
               0  " Check for an output file option "
               0  $check_get_argument('-o','--output',arg);
               0  IF( have_arg ) [
               1      l = lnblnk1(arg);
               1      IF( l > 256 ) [
               2          $egs_fatal(*,'output file name is too long ',l);
               2          ]
               1      output_file(:l) = $cstring(arg);
               1      ]
               0  ELSE [
               1      IF( lnblnk1(input_file) > 0 ) [
               2          output_file(:lnblnk1(input_file)) = $cstring(input_file);
               2          ]
               1      ELSE [
               2          output_file = 'test';
               2          ]
               1      ]
               0
               0  return; end;
               0
               0  "******************************************************************************
               0  subroutine egs_open_units(flag);
               0  "******************************************************************************
               0  " Open output files.
               0  " Looks for output file definition in user_code.io.
               0  " In addition, if it is a batch run connects a .egslog file to unit 6.
               0  " If flag is .true., open the files in the temporary working directory,
               0  " else open them in the user code directory.
               0  "******************************************************************************
               0  implicit none;
               0  $LOGICAL flag;
               0
               0  ;COMIN/EGS-IO/;
               0
               0  character tmp_string*1024, tmp1_string*1024, tmp2_string*1024, ucode_dir*1024,
               0  input_line*100, arg*20;
               0  integer   i,lnblnk1,u,l,istart,egs_get_unit,i_iofile;
               0  $LOGICAL  ex,is_open;
               0  $declare_write_buffer;
               0
               0  $set_string(tmp_string,' '); $set_string(ucode_dir,' ');
               0  ucode_dir = $cstring(egs_home) // $cstring(user_code) // $file_sep;
               0  IF( flag ) [
               1      tmp_string = $cstring(ucode_dir) // $cstring(work_dir);
               1      ]
               0  ELSE [
               1      tmp_string = $cstring(ucode_dir);
               1      ]
               0
               0  tmp_string = $cstring(tmp_string) // $cstring(output_file);
               0  IF( i_parallel > 0 ) [
               1      tmp_string = $cstring(tmp_string) // '_w';
               1      call egs_itostring(tmp_string,i_parallel,.false.);
               1      ]
               0  $set_string(tmp1_string,' ');
               0  i_log=6;
               0  IF( is_batch ) [
               1      tmp1_string = $cstring(tmp_string) // '.egslog';
               1      $AVAILABLE_UNIT(i_log,tmp1_string);
               1      open(i_log,file=tmp1_string,status='unknown',err=:output_file_error:);
               1      ]
               0  $set_string(tmp2_string,' ');
               0  tmp2_string = $cstring(ucode_dir) // $cstring(user_code) // '.io';
               0  inquire(file=tmp2_string,exist=ex);
               0  n_files = 0;
               0  IF( ex ) [
               1      i_iofile=99;
               1      i_iofile=egs_get_unit(i_iofile);
               1      IF (i_iofile<1)[
               2          $egs_fatal(*,'failed to get a free Fortran I/O unit for .io file');
               2          ]
               1      open(i_iofile,file=tmp2_string,status='old',err=:io_file_error:);
               1      LOOP [
               2          read(i_iofile,'(a)',err=:end_of_iofile:,end=:end_of_iofile:) input_line;
               2          IF( input_line(1:1) = '#' ) NEXT;
               2          "The DEC and SGI compilers fail at the following statement!"
               2          "read(input_line,*,err=:end_of_iofile:,end=:end_of_iofile:) u,arg;"
               2          read(input_line,*,err=:end_of_ioline:,end=:end_of_ioline:) u;
               2          istart = 1;
               2          DO i=lnblnk1(input_line),1,-1 [
               3              IF( input_line(i:i) = ' ' ) [ istart = i+1; EXIT; ]
               3              ]
               2          DO i=1,len(arg) [ arg(i:i) = ' '; ]
               2          DO i=istart,lnblnk1(input_line) [
               3              arg(i+1-istart:i+1-istart) = input_line(i:i);
               3              ]
               2          inquire(unit=u,opened=is_open);
               2          IF( is_open ) [
               3              $egs_warning('(a,i3,a,a,a,/,a,/,a,/)',
               3              'Unit ',u,' which you want to connect to a ',
               3              $cstring(arg),' file ',
               3              'is already in use. Will assume this code is being used as',
               3              'a shared library source and this file will be opened explicitly.');
               3              ]
               2          ELSE[
               3              n_files = n_files + 1;
               3              IF( n_files > $mx_units ) [
               4                  $egs_fatal(*,'Too many units requested in .io.',
               4                  ' Increas $mx_units and retry');
               4                  ]
               3              file_units(n_files) = u;
               3              $set_string(file_extensions(n_files),' ');
               3              l = lnblnk1(arg);
               3              IF( l > $max_extension_length ) [
               4                  $egs_fatal(*,'extension ',$cstring(arg),' is longer than ',
               4                  $max_extension_length,' chars. ',
               4                  'Increase $max_extension_length and retry ');
               4                  ]
               3              file_extensions(n_files) = $cstring(arg);
               3              tmp1_string = $cstring(tmp_string) // $cstring(arg);
               3              open(u,file=tmp1_string,status='unknown');
               3              $egs_debug('(a,a,a,i3)','connected ',$cstring(tmp1_string),
               3              ' to unit ',u);
               3              ]
               2          :end_of_ioline:
               2          ]
               1      :end_of_iofile:
               1      close(i_iofile);
               1      ]
               0  return;
               0
               0  :output_file_error:
               0  $egs_fatal(*,'failed to open output file ',$cstring(tmp1_string));
               0
               0  :io_file_error:
               0  $egs_fatal(*,'failed to open existing .io file',$cstring(tmp2_string));
               0  return; end;
               0
               0
               0  "******************************************************************************
               0  subroutine egs_finish;
               0  "******************************************************************************
               0  " This subroutine becomes the last step in every EGSnrc user code.
               0  " It's purpose is to move the all output files from the temporary working
               0  " directory to the user code directory and to remove the working dir.
               0  " This was previously done by the egs_run script.
               0  " This routine also prints a summary to standard output.
               0  "******************************************************************************
               0  implicit none;
               0  ;COMIN/EGS-IO,my_times/;
               0  character line*80,base*512,base1*512,tmp_string*512,junk_file*128,fname*512;
               0  character dattim*24;
               0  integer  i,l,lnblnk1,istat,egs_system,n_open,unlink,i_junk,egs_get_unit;
               0  $LOGICAL is_open,egs_isdir;
               0  $REAL    t1,t2,tt_cpu;
               0  $declare_write_buffer;
               0
               0  $set_string(line,'=');
               0  IF( n_parallel = 0 | i_parallel > 0 ) [
               1      "i.e. we want that info if this is not a parallel run (n_parallel = 0)"
               1      "or if it is parallel but it is not the final egs_finish (after combining"
               1      "results from parallel runs)"
               1      t_elapsed = egs_tot_time(1); tt_cpu = egs_etime() - t_cpu;
               1      t1 = t_elapsed; t2 = t1/3600;
               1      $egs_info('(//a,/,a,/)',line,'Finished simulation');
               1      $egs_info('(2x,a,t30,f9.1,a,f7.3,a)','Elapsed time: ',t1,' s (',t2,' h)');
               1      t1 = tt_cpu; t2 = t1/3600;
               1      $egs_info('(2x,a,t30,f9.1,a,f7.3,a)','CPU time:',t1,' s (',t2,' h)');
               1      $egs_info('(2x,a,t30,f10.3)','Ratio:',t_elapsed/tt_cpu);
               1      ]
               0  call egs_get_fdate(dattim);
               0  $egs_info('(//a,t56,a,/,a)','End of run ',dattim,line);
               0
               0  " Close all I/O units "
               0  n_open=0;
               0  $set_string(base,' ');
               0  base = $cstring(egs_home) // $cstring(user_code);
               0  DO i=1,$max_unit [
               1      IF( is_batch | i ~= i_log ) [
               2          inquire(i,opened=is_open);
               2          IF( is_open ) [
               3              inquire(i,name=fname);
               3              IF(index($cstring(fname),$cstring(base))>0)[
               4                  close(i); n_open = n_open+1; ]
               3              ]
               2          ]
               1      ]
               0
               0  "If work_dir is empty, this is a second call to egs_finish for the last"
               0  "job in a parallel run. This implies that the temporary working "
               0  "directory has been already removed => just return"
               0
               0  IF( lnblnk1(work_dir) = 0 ) [ return; ]
               0
               0  " Now generate a junk file in the working directory so that the move "
               0  " command does not fail in case there are no files "
               0  $set_string(base,' ');
               0  base = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  $cstring(work_dir);
               0  DO i=1,lnblnk1(base) [
               1      IF( base(i:i) = '/' ) [
               2          base(i:i) = $file_sep;
               2          ]
               1      ]
               0  IF( egs_isdir(base) ) [
               1      $set_string(tmp_string,' '); $set_string(junk_file,' ');
               1      junk_file = $cstring(work_dir);
               1      l = lnblnk1(junk_file); junk_file(l:l) = ' ';
               1      junk_file = $cstring(junk_file) // '_junk';
               1      tmp_string = $cstring(base) // $cstring(junk_file);
               1      i_junk=99;
               1      i_junk=egs_get_unit(i_junk);
               1      IF(i_junk<0)[
               2          $egs_fatal(*,'failed to get a free Fortran I/O unit for junk file');
               2          ]
               1      open(i_junk,file=tmp_string,status='unknown');
               1      write(i_junk,*) 'junk';
               1      close(i_junk);
               1
               1      " Move all files from the working directory to the user code directory "
               1      $set_string(base1,' ');
               1      base = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               1      $cstring(work_dir);
               1      base1 = $cstring(egs_home) // $cstring(user_code);
               1      $set_string(tmp_string,' ');
               1      tmp_string = $move_file // $cstring(base) // '*  ' // $cstring(base1);
               1      l = lnblnk1(tmp_string)+1;
               1      tmp_string(l:l) = char(0);
               1      istat = egs_system(tmp_string);
               1      IF( istat ~= 0 ) [
               2          $egs_warning(*,'Moving files from working directory failed ?');
               2          $warning(*,'=> will not remove working directory');
               2          ]
               1      ELSE [
               2          " Remove the working directory "
               2          $set_string(tmp_string,' ');
               2          tmp_string = $remove_directory // $cstring(base);
               2          l = lnblnk1(tmp_string)+1; tmp_string(l:l) = char(0);
               2          istat = egs_system(tmp_string);
               2          IF( istat ~= 0 ) [
               3              $egs_warning(*,'Failed to remove working directory ',
               3              $cstring(work_dir));
               3              ]
               2          " Remove the junk file "
               2          $set_string(tmp_string,' ');
               2          tmp_string = $cstring(base1) // $file_sep // $cstring(junk_file);
               2          l = lnblnk1(tmp_string)+1; tmp_string(l:l) = char(0);
               2          istat = unlink(tmp_string);
               2          ]
               1      ]
               0
               0  " Now set work_dir to blank so that all I/O stuff after egs_finish ends up"
               0  " in the user code directory "
               0  $set_string(work_dir,' ');
               0
               0  return; end;
               0
               0  "******************************************************************************
               0  subroutine egs_set_defaults;
               0  "******************************************************************************
               0  " Replaces BLOCK DATA "
               0  implicit none;
               0  $COMIN-SET-DEFAULTS;
               0
               0  integer  i,j,lnblnk1;
               0  $TYPE MEDIA1(24); EQUIVALENCE(MEDIA1(1),MEDIA(1,1));
               0  character fool_dec;
               0  data MEDIA1/$S'NAI                     '/;
               0  data fool_dec/'/'/;
               0  data fool_intel_optimizer/.false./;
               0
               0  vacdst = 1e8;
               0  $set-region-by-region-defaults;
               0
               0  eii_flag = 0; "No EII by default. "
               0  eii_xfile = 'Off';
               0  eii_L_factor = 1.0; "No L-shell EII xsection scaling by default"
               0  "========================================="
               0  "See egsnrc.macros for defaults used below"
               0  "========================================="
               0  xsec_out = $XSEC-DEFAULT;
               0  photon_xsections = $XDATA-DEFAULT;"default photon xsection"
               0  comp_xsections = $COMP-XDATA-DEFAULT;
               0  eadl_relax = $EADL-RELAX-DEFAULT;
               0  mcdf_pe_xsections = $MCDF-PE-DEFAULT;
               0  "Ali:photonuc, 2 lines"
               0  photonuc_xsections = $PHOTONUC-XDATA-DEFAULT;
               0  "EMH:emf"
               0  ExIN=$ExDEF;EyIN=$EyDEF;EzIN=$EzDEF;
               0  " Initially set to input values, could change with regions"
               0  " by converting it to an array over all regions. This is  "
               0  " currently implemented ONLY for the C++ applications     "
               0  BxIN=$BxDEF;ByIN=$ByDEF;BzIN=$BzDEF; EMLMTIN=$EMLMTDEF;
               0  Bx=BxIN;    By=ByIN;    Bz=BzIN;
               0  Bx_new=Bx;  By_new=By;  Bz_new=Bz;
               0
               0  DO i=1,$MXMED [
               1      iraylm(i) = 0; "Rayleigh data available?"
               1      DO j=1,len(iray_ff_file(i)) [ iray_ff_file(i)(j:j) = ' ';]
               1      DO j=1,len(iray_ff_media(i)) [ iray_ff_media(i)(j:j) = ' ';]
               1      " set all thresholds to zero "
               1      /ae(i),ap(i),ue(i),up(i),te(i),thmoll(i)/=0;
               1      ]
               0  DO i=1,$MXSHXSEC [
               1      DO j=1,$MXELEMENT [ binding_energies(i,j) = 0; ]
               1      ]
               0  ibrdst = $IBRDST-DEFAULT;      " brems angular sampling"
               0  ibr_nist = $IBR-NIST-DEFAULT;  " flag for brems from NIST data base "
               0  pair_nrc = $PAIR-NRC-DEFAULT;  " flag for pair from the NRC data base "
               0  itriplet = $TRIPLET-DEFAULT;   " flag for triplet production "
               0  iprdst = $IPRDST-DEFAULT;      " pair angular sampling "
               0  rhof = 1;
               0  DO i=1,5 [ iausfl(i) = 1; ]
               0  "Ali:photonuc, line below already includes iarg=29,30"
               0  DO i=6,$MXAUS [ iausfl(i) = 0; ]
               0  ximax = $EXACT-BCA-XIMAX; estepe = $MAX-ELOSS;
               0  skindepth_for_bca = $SKIN-DEPTH-FOR-BCA;
               0  transport_algorithm = $TRANSPORT-ALGORITHM-DEFAULT;
               0  bca_algorithm = $BCA-ALGORITHM-DEFAULT;
               0  exact_bca = $EXACT-BCA-DEFAULT;
               0  spin_effects = $SPIN-EFFECTS-DEFAULT;
               0  count_pII_steps = 0; count_all_steps = 0;
               0  radc_flag = 0;
               0  nmed = $default_nmed;
               0  kmpi = 12; kmpo = 8; dunit = 1;
               0  rng_seed = 999999;
               0  latchi = 0;
               0
               0  rmt2 = 2*rm; rmsq = rm*rm;
               0
               0  pi = 4*datan(1d0); twopi = 2*pi; pi5d2 = 2.5*pi;
               0  nbr_split = 1;
               0  i_play_RR = 0; i_survived_RR = 0; prob_RR = -1; n_RR_warning = 0;
               0
               0  $set_string(hen_house,' ');
               0  i = lnblnk1($HEN_HOUSE);
               0  hen_house(:i) = $HEN_HOUSE;
               0  IF( $file_sep ~= fool_dec ) [
               1      DO j=1,i [
               2          IF( hen_house(j:j) = '/' ) hen_house(j:j) = $file_sep;
               2          ]
               1      ]
               0  IF( hen_house(i:i) ~= $file_sep ) hen_house(i+1:i+1) = $file_sep;
               0
               0  n_files = 0;
               0  $set_egs_home;
               0  i = lnblnk1(egs_home);
               0  IF( $file_sep ~= fool_dec ) [
               1      DO j=1,i [
               2          IF( egs_home(j:j) = '/' ) egs_home(j:j) = $file_sep;
               2          ]
               1      ]
               0  IF( i > 0 & egs_home(i:i) ~= $file_sep ) egs_home(i+1:i+1) = $file_sep;
               0  $set_string(input_file,' ');
               0  $set_string(output_file,' ');
               0  $set_string(work_dir,' ');
               0  $set_string(pegs_file,' ');
               0  $set_string(host_name,' ');
               0  n_parallel = 0; i_parallel = 0; n_chunk = 0; is_batch = .false.;
               0  first_parallel = 1;
               0  return; end;
               0
               0  "*****************************************************************************
               0  subroutine egs_combine_runs(combine_routine,extension);
               0  "*****************************************************************************
               0  " This subroutine loops over job number i from 1 to $max_unit,
               0  " checks if the file output_file_wi.extension exists, and if yes,
               0  " calls the external subroutine combine_routine with that file name.
               0  "*****************************************************************************
               0  implicit none;
               0  external combine_routine;
               0  character*(*) extension;
               0  ;COMIN/EGS-IO/;
               0  character*1024 tmp_string,base,command,outfile,parfile_name,base1,
               0  text_string;
               0  integer  lnblnk1,istat,ipar,egs_system,egs_open_file;
               0  $INTEGER i,k,j,numparfiles,textindex;
               0  $LOGICAL ex,iwin;
               0
               0  iwin=.false.; "start off assuming a non-Windows system"
               0
               0  $set_string(base,' ');
               0  base = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  $cstring(output_file) // '_w';
               0
               0  "the following is to count the number of output files from"
               0  "a parallel run"
               0  $set_string(base1,' ');
               0  base1 = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  $cstring(output_file) // '_w*' // $cstring(extension);
               0  $set_string(outfile,' ');
               0  outfile = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  'parfiles_tmp';
               0  "try Unix/Linux first"
               0  $set_string(command,' ');
               0  command = 'ls ' // $cstring(base1) // ' | wc -l > ' // $cstring(outfile);
               0  istat = egs_system($cstring(command));
               0  IF(istat~=0)["now assume a Windows system"
               1      command = 'dir ' // $cstring(base1) // ' | find "File(s)" > ' //
               1      $cstring(outfile);
               1      istat = egs_system($cstring(command));
               1      IF(istat~=0)[
               2          $egs_fatal(*,' Failed to write number of output files from parallel runs.');
               2          ]
               1      ELSE [
               2          iwin=.true.;
               2          ]
               1      ]
               0
               0  "now open parfiles_tmp and read the number of files"
               0  ipar=1;
               0  ipar=egs_open_file(ipar,0,1,$cstring(outfile));
               0  IF(iwin)[
               1      "need to do a bit of manipulation of a text string to get the number of files
               1      read(ipar,'(a)',err=:end_of_parfile:,end=:end_of_parfile:) text_string;
               1      text_string = $cstring(text_string);
               1      textindex = index(text_string,'File(s)');
               1      text_string = text_string(:textindex-1);
               1      read(text_string,'(i256)',err=:end_of_parfile:) numparfiles;
               1      ]
               0  ELSE[
               1      read(ipar,'(i256)',err=:end_of_parfile:,end=:end_of_parfile:) numparfiles;
               1      ]
               0  close(ipar);
               0
               0  "now remove parfiles_tmp"
               0  $set_string(command,' ');
               0
               0  IF(iwin)[
               1      command = 'del /Q ' // $cstring(outfile);
               1      ]
               0  ELSE[
               1      command = 'rm -f ' // $cstring(outfile);
               1      ]
               0  istat = egs_system($cstring(command));
               0  IF(istat~=0)[
               1      $egs_warning(*,' Failed to delete list of output files from parallel runs.');
               1      ]
               0
               0  k=1;
               0  j=1;
               0  WHILE(j<=numparfiles) [
               1      $set_string(tmp_string,' ');
               1      tmp_string = $cstring(base);
               1      call egs_itostring(tmp_string,k,.false.);
               1      tmp_string = $cstring(tmp_string) // $cstring(extension);
               1      inquire(file=tmp_string,exist=ex);
               1      IF( ex ) [
               2          call combine_routine(tmp_string);
               2          j=j+1;
               2          ]
               1      k=k+1;
               1      ]
               0  return;
               0
               0  :end_of_parfile:
               0  $egs_fatal(*,' Failed to read number of output files from parallel runs.');
               0  end;
               0
               0  "******************************************************************************
               0  $LOGICAL function egs_strip_extension(filen,fext);
               0  "******************************************************************************
               0  " Check if the string pointed to by filen ends with the string pointed to by
               0  " fext and if yes, replace with blanks and return .true., otherwise return
               0  " false.
               0  "******************************************************************************
               0  implicit none;
               0  character*(*) filen,fext;
               0  integer  l1,l2,lnblnk1,i;
               0
               0  l1 = lnblnk1(filen); l2 = lnblnk1(fext);
               0  IF( l1 >= l2 & filen(l1-l2+1:l1) = fext(:l2) ) [
               1      egs_strip_extension = .true.;
               1      DO i=l1-l2+1,len(filen) [ filen(i:i) = ' '; ]
               1      ]
               0  ELSE [ egs_strip_extension = .false.; ]
               0  return; end;
               0
               0  "******************************************************************************
               0  $LOGICAL function egs_is_absolute_path(fn);
               0  "******************************************************************************
               0  " Returns .true., if the string pointed to by fn is an absolute file name,
               0  " .fale. otherwise.
               0  "******************************************************************************
               0  implicit none;
               0  character*(*) fn;
               0  integer  i,lnblnk1;
               0  DO i=1,lnblnk1(fn) [
               1      IF( fn(i:i) = $file_sep ) [ egs_is_absolute_path = .true.; return; ]
               1      ]
               0  egs_is_absolute_path = .false.; return; end;
               0
               0  "******************************************************************************
               0  integer  function egs_get_unit(iunit);
               0  "******************************************************************************
               0  " Returns iunit, if the Fortran I/O unit iunit is not currently in use.
               0  " Otherwise return the first free I/O unit found or -1 if none is available.
               0  "******************************************************************************
               0  implicit none;
               0  $INTEGER iunit, i;
               0  $LOGICAL is_open;
               0
               0  IF( iunit > 0 ) [
               1      inquire(iunit,opened=is_open);
               1      IF( ~is_open ) [ egs_get_unit = iunit; return; ]
               1      ]
               0  DO i=1,$max_unit [
               1      inquire(i,opened=is_open);
               1      IF( ~is_open ) [ egs_get_unit = i; return; ]
               1      ]
               0  egs_get_unit = -1; return; end;
               0
               0  "******************************************************************************
               0  integer function egs_open_file(iunit,rl,action,extension);
               0  "******************************************************************************
               0  " Open a file trying to connect to Fortran I/O unit iunit.
               0  " If iunit is already in use, connect to the first free I/O unit found.
               0  " If no free I/O unit is found, then
               0  "   - if action = 0, return -1.
               0  "   - if action ~= 0, call the $egs_fatal macro.
               0  " If extension is an absolute file name (including path), use extension
               0  " as a file name, otherwise use output_file.extension in the temporary
               0  " working directory as name. In both cases use status='unknown' to open the
               0  " file. If rl = 0, open the file for formatted sequential access, otherwise
               0  " open for unformatted direct access with record length = rl.
               0  "******************************************************************************
               0  implicit none;
               0  $INTEGER iunit, rl, action;
               0  character*(*) extension;
               0  ;COMIN/EGS-IO/;
               0  $LOGICAL egs_is_absolute_path,is_open;
               0  integer  egs_get_unit;
               0  integer  i,lnblnk1;
               0  character*1024 tmp_string,error_string;
               0  $INTEGER the_unit;
               0  $declare_write_buffer;
               0
               0  egs_open_file = -1; "so that the DEC compiler does not complain that"
               0  "the function has an undefined values in some of"
               0  "the excution paths (where exit(1) is called."
               0  the_unit = egs_get_unit(iunit);
               0  IF( the_unit < 0 ) [
               1      IF( action = 0 ) [ egs_open_file = -1; return; ]
               1      $egs_fatal(*,'No free Fortran I/O units left');
               1      ]
               0
               0  IF( egs_is_absolute_path(extension) ) [
               1      inquire(file=extension,opened=is_open);
               1      IF(is_open)[
               2          inquire(file=extension,number=the_unit);
               2          $egs_warning('(a,a,/,a,i3,/,a,/,a)',
               2          'File ',$cstring(extension),
               2          ' is already opened and connected to unit ',the_unit,
               2          ' Will not try to re-open this file, assuming it has been opened',
               2          ' by the .io file.');
               2          ]
               1      ELSE IF( rl = 0 ) [
               2          open(the_unit,file=extension,status='unknown');
               2          ]
               1      ELSE [
               2          open(the_unit,file=extension,status='unknown',form='unformatted',
               2          access='direct', recl=rl);
               2          ]
               1      egs_open_file = the_unit; return;
               1      ]
               0
               0  $set_string(tmp_string,' ');
               0  tmp_string = $cstring(egs_home) // $cstring(user_code) // $file_sep //
               0  $cstring(work_dir) // $cstring(output_file);
               0  IF( i_parallel > 0 ) [
               1      tmp_string = $cstring(tmp_string) // '_w';
               1      call egs_itostring(tmp_string,i_parallel,.false.);
               1      ]
               0  tmp_string = $cstring(tmp_string) // $cstring(extension);
               0
               0  inquire(file=tmp_string,opened=is_open);
               0  IF(is_open)[
               1      inquire(file=tmp_string,number=the_unit);
               1      $egs_warning('(a,a,/,a,i3,/,a,/,a,/)',
               1      'File ',$cstring(tmp_string),
               1      ' is already opened and connected to unit ',the_unit,
               1      ' Will not try to re-open this file, assuming it has been opened',
               1      ' by specifying it in the .io file.');
               1      ]
               0  ELSE IF( rl = 0 ) [
               1      open(the_unit,file=tmp_string,status='unknown',err=:open_error:);
               1      ]
               0  ELSE [
               1      open(the_unit,file=tmp_string,status='unknown',form='unformatted',
               1      access='direct', recl=rl,err=:open_error:);
               1      ]
               0  egs_open_file = the_unit; return;
               0
               0  :open_error:
               0  error_string = 'In egs_open_file: failed to open file ' // $cstring(tmp_string)
               0  // char(10) // 'iunit = ';
               0  call egs_itostring(error_string,iunit,.false.);
               0  error_string = $cstring(error_string) // ' the_unit = ';
               0  call egs_itostring(error_string,the_unit,.false.);
               0  $egs_fatal('(a)',$cstring(error_string));
               0  end;
               0
               0
               0  "******************************************************************************
               0  integer  function egs_open_datfile(iunit,rl,action,extension);
               0  "******************************************************************************
               0  "
               0  " Open an existing 'data' file.
               0  " First try to connect the file to Fortran unit iunit, but if iunit is
               0  " already in use, use the first free unit instead.
               0  " extension is the datafile extension (e.g. '.egsdat') .
               0  " The algorithm for searching for the file is as follows:
               0  "  1. If extension is an absolute file name (including path),
               0  "     try opening this file, else
               0  "  2. Try output_file.extension in the user code directory.
               0  "  3. Try input_file.extension in the user code directory (if input_file is
               0  "     different from output_file).
               0  " If the file is found, open it using status='old' for
               0  "   a) formatted sequential access, if rl=0
               0  "   b) unformatted direct access with record length = rl, if rl > 0.
               0  "
               0  " Return value:
               0  "   - if all is OK, return the opened unit number
               0  "   - if something fails, then
               0  "       * if action = 0, return error code less than 0.
               0  "       * if action != 0, call the $egs_fatal macro with an error message.
               0  "
               0  "******************************************************************************
               0  implicit none;
               0  $INTEGER iunit,rl,action;
               0  character*(*) extension;
               0
               0  ;COMIN/EGS-IO/;
               0
               0  integer  i,the_unit,lnblnk1,egs_get_unit;
               0  $LOGICAL egs_is_absolute_path;
               0  character base*1024, fn*1024;
               0  $declare_write_buffer;
               0
               0  egs_open_datfile = -1; "so that the DEC compiler does not complain that"
               0  "the function has an undefined values in some of"
               0  "the excution paths (where exit(1) is called."
               0  the_unit = egs_get_unit(iunit);
               0  IF( the_unit < 0 ) [
               1      IF( action = 0 ) [ egs_open_datfile = -1; return; ]
               1      $egs_fatal(*,'No free Fortran I/O units left');
               1      ]
               0
               0  IF( egs_is_absolute_path(extension) ) [
               1      IF( rl = 0 ) [
               2          open(the_unit,file=extension,status='old',err=:no_datfile_0:);
               2          ]
               1      ELSE [
               2          open(the_unit,file=extension,status='old',form='unformatted',
               2          access='direct',recl=rl,err=:no_datfile_0:);
               2          ]
               1      egs_open_datfile = the_unit; return;
               1
               1      :no_datfile_0:;
               1      IF( action = 0 ) [ egs_open_datfile = -2; return; ]
               1      $egs_fatal(*,'Failed to open file ',$cstring(extension));
               1      ]
               0
               0  $set_string(base,' '); $set_string(fn,' ');
               0  base = $cstring(egs_home) // $cstring(user_code) // $file_sep;
               0  "fn = $cstring(base) // $cstring(output_file) // $cstring(extension);"
               0  IF( i_parallel > 0 ) [
               1      fn = $cstring(base) // $cstring(output_file) // '_w';
               1      call egs_itostring(fn,i_parallel,.false.);
               1      fn = $cstring(fn) // $cstring(extension);
               1      ]
               0  ELSE [
               1      fn = $cstring(base) // $cstring(output_file) // $cstring(extension);
               1      ]
               0  IF( rl = 0 ) [
               1      open(the_unit,file=fn,status='old',err=:no_datfile_1:);
               1      ]
               0  ELSE [
               1      open(the_unit,file=fn,status='old',form='unformatted',access='direct',
               1      recl=rl,err=:no_datfile_1:);
               1      ]
               0  egs_open_datfile = the_unit; return;
               0
               0  :no_datfile_1:;
               0  $egs_warning('(a,a)','Failed to open ',$cstring(fn));
               0  $set_string(fn,' ');
               0  "fn = $cstring(base) // $cstring(input_file) // $cstring(extension);"
               0  IF( i_parallel > 0 ) [
               1      fn = $cstring(base) // $cstring(input_file) // '_w';
               1      call egs_itostring(fn,i_parallel,.false.);
               1      fn = $cstring(fn) // $cstring(extension);
               1      ]
               0  ELSE [
               1      fn = $cstring(base) // $cstring(input_file) // $cstring(extension);
               1      ]
               0  IF( rl = 0 ) [
               1      open(the_unit,file=fn,status='old',err=:no_datfile_2:);
               1      ]
               0  ELSE [
               1      open(the_unit,file=fn,status='old',form='unformatted',access='direct',
               1      recl=rl,err=:no_datfile_2:);
               1      ]
               0  egs_open_datfile = the_unit; return;
               0
               0  :no_datfile_2:;
               0  $egs_fatal(*,'Failed to open data file');
               0  end;
               0
               0  "******************************************************************************
               0  integer  function egs_open_file_junk(iunit,do_it_anyway,filen);
               0  "******************************************************************************
               0  " Open the file filen for sequential formatted I/O and return the unit
               0  " number it was connected to.
               0  " If iunit ~= 0, try to connect to unit |iuniti|, otherwise
               0  " use the first unconnected unit found.
               0  " If iunit > 0
               0  "    open the unit even if it was already open, if do_it_anyway is .true.,
               0  "    otherwise return -4.
               0  " If iunit < 0
               0  "    if the unit |iunit| is already in use and do_it_anyway is .true.,
               0  "    search for the first available unit, otherwise return -4.
               0  " Return values:
               0  "   unit number, if the file was succesfully opened.
               0  "   -1, if there was no free unit numer to connect to.
               0  "   -2, if the file does not exist.
               0  "   -3, if the file exist, but could not be opened.
               0  "   -4, if |iunit|>0 & do_it_anyway=.false. and |iunit| is already in use.
               0  "******************************************************************************
               0  implicit none;
               0  $INTEGER iunit;
               0  $LOGICAL do_it_anyway;
               0  character*(*) filen;
               0
               0  $LOGICAL aux;
               0  $INTEGER the_unit,i;
               0
               0  inquire(file=filen,exist=aux);
               0  IF( ~aux ) [ egs_open_file_junk = -2; return; ]
               0  IF( iunit < 0 ) [ the_unit = -iunit; ] ELSE [ the_unit = iunit; ]
               0  IF( the_unit ~= 0 ) [
               1      inquire(unit=the_unit,opened=aux);
               1      IF( aux ) [
               2          IF( ~do_it_anyway ) [ egs_open_file_junk = -4; return; ]
               2          IF( iunit < 0 ) the_unit = 0;
               2          ]
               1      ]
               0  IF( the_unit = 0 ) [
               1      DO i=1,$max_unit [
               2          inquire(unit=i,opened=aux);
               2          IF( ~aux ) [ the_unit = i; EXIT; ]
               2          ]
               1      IF( the_unit = 0 ) [ egs_open_file_junk = -1; return; ]
               1      ]
               0  open(the_unit,file=filen,status='old',err=:failed_to_open:);
               0  egs_open_file_junk = the_unit; return;
               0  :failed_to_open:
               0  egs_open_file_junk = -3; return; end;
               0
               0  "==============================================================================
               0  subroutine egs_strip_path(fname);
               0  "==============================================================================
               0  " Strip the path name from fname (if any)
               0  implicit none;
               0  character*(*) fname;
               0  integer  i,l,l1,lnblnk1,j;
               0  character slash;
               0  slash = '/';
               0  l = lnblnk1(fname);
               0  DO i=1,l [
               1      IF( fname(i:i) = slash ) [ fname(i:i) = $file_sep; ]
               1      ]
               0  DO i=l,1,-1 [
               1      IF( fname(i:i) = $file_sep | fname(i:i) = slash ) [
               2          l1 = l-i;
               2          fname(:l1) = fname(i+1:l);
               2          DO j=l1+1,len(fname) [ fname(j:j) = ' '; ]
               2          return;
               2          ]
               1      ]
               0  return; end;
               0
               0  "==============================================================================
               0  subroutine replace_env(fname);
               0  "==============================================================================
               0  "subroutine to replace environment variables (beginning with $) with their"
               0  "full names or ~ with the full name of $HOME"
               0  "Assumes environment variable or ~ appears only at the beginning of the"
               0  "file name"
               0
               0  ;COMIN/EGS-IO/;
               0
               0  character*(*) fname;
               0  character*256 dirname;
               0  integer indsep,ind1,ind2;
               0
               0  indsep = index(fname,$file_sep);
               0  IF(indsep <= 0) return;
               0  "hope that the user has just supplied the file name"
               0  "and it is in the current directory"
               0
               0  ind1=index(fname,'$');
               0  ind2=index(fname,'~');
               0
               0  "examine first character of name"
               0  IF(ind1=1)[
               1      "get the environment variable"
               1      call getenv(fname(2:indsep-1),dirname);
               1      IF(dirname=' ')[
               2          $egs_fatal('(a,a/,a)',' Error in file name: ',$cstring(fname),
               2          ' First element in name does not specify a defined environment variable.');
               2          ]
               1      fname=$cstring(dirname)//fname(indsep:);
               1      $egs_info('(//a,a/)',' Retrieving file: ',$cstring(fname));
               1      ]
               0  ELSEIF(ind2=1)[
               1      call getenv('HOME',dirname);
               1      IF(dirname=' ')[
               2          $egs_fatal('(a,a/,a)',' Error in file name: ',$cstring(fname),
               2          ' HOME is undefined.');
               2          ]
               1      fname=$cstring(dirname)//fname(indsep:);
               1      $egs_info('(//a,a/)',' Retrieving file: ',$cstring(fname));
               1      ]
               0  return;
               0  end;
               0
               0  "=============================================================================
               0  subroutine egs_get_usercode(ucode);
               0  "=============================================================================
               0  " Deduct the user code name from the executable name
               0  " The algorithm assumes that the executable is called
               0  "   xxx[_debug|noopt][.exe]
               0  " and it will fail if this is not the case.
               0  "=============================================================================
               0  implicit none;
               0  COMIN/EGS-IO/;
               0  character*(*) ucode;
               0  character*512 arg;
               0  integer  l,l1,lnblnk1,i;
               0  $declare_write_buffer;
               0
               0  call getarg(0,arg); call egs_strip_path(arg);
               0  l = lnblnk1(arg);
               0  IF( arg(l-3:l) = '.exe' ) [
               1      arg(l-3:l) = ' '; l = l - 4;
               1      ]
               0  IF( arg(l-5:l) = '_debug' ) [
               1      arg(l-5:l) = ' '; l = l-5;
               1      ]
               0  IF( arg(l-5:l) = '_noopt' ) [
               1      arg(l-5:l) = ' '; l = l-5;
               1      ]
               0  l1 = len(ucode);
               0  IF( l > l1 ) [
               1      $egs_fatal(*,' user code name is too long (',l,' chars)');
               1      ]
               0  $set_string(ucode,' '); ucode(:l) = arg(:l);
               0  return; end;
               0
               0  subroutine egs_itostring(string,i,leave_space);
               0  implicit none;
               0  character*(*) string;
               0  $INTEGER i;
               0  integer  l,lnblnk1,idiv,itmp,iaux;
               0  $LOGICAL first,leave_space;
               0  l = lnblnk1(string)+1; IF( l > 1 & leave_space ) l=l+1;
               0  idiv = 1000000000; itmp = i; first = .false.;
               0  do while(idiv.gt.0) ;
               0  iaux = itmp/idiv;
               0  IF( (iaux > 0 | first ) & l <= len(string) ) [
               1      string(l:l) = char(iaux+48); first = .true.; l = l+1;
               1      ]
               0  itmp = itmp - iaux*idiv; idiv = idiv/10;
               0  end do;
               0  return; end;
               0
               0  "=============================================================================
               0  $REAL function egs_rndm();
               0  "=============================================================================
               0  implicit none;
               0  ;COMIN/RANDOM/;
               0  $RANDOMSET egs_rndm;
               0  return; end;
               0
               0  "=============================================================================
               0  integer  function egs_add_medium(medname);
               0  implicit none;
               0  character*(*) medname;
               0  $declare_max_medium;
               0  ;COMIN/MEDIA,EGS-IO/;
               0  $INTEGER i,l,imed,medname_len;
               0  character c;
               0  $LOGICAL  same;
               0  $declare_write_buffer;
               0
               0  l = min(len(medname),24); medname_len = l;
               0  DO i=1,l [
               1      c = medname(i:i);
               1      IF( ichar(c) = 0 ) [ medname_len = i-1; EXIT; ]
               1      ]
               0  DO imed=1,nmed [
               1      l = 24;
               1      DO i=1,24 [
               2          IF( media(i,imed)(1:1) = ' ' ) [ l = i-1; EXIT; ]
               2          ]
               1      IF( l = medname_len ) [
               2          same = .true.;
               2          DO i=1,l [
               3              c = medname(i:i);
               3              IF( c ~= media(i,imed)(1:1) ) [ same = .false.; EXIT; ]
               3              ]
               2          IF( same ) [
               3              egs_add_medium = imed; return;
               3              ]
               2          ]
               1      ]
               0  nmed = nmed + 1;
               0  IF( nmed > $MXMED ) [
               1      $egs_fatal('(a,/,a,i3,a)',
               1      'In egs_add_medium: maximum number of media exceeded ',
               1      'Increase the macro $MXMED (currently ',$MXMED,') and retry');
               1      ]
               0  l = min(len(medname),24);
               0  DO i=1,l [
               1      c = medname(i:i);
               1      IF( ichar(c) = 0 ) [ l = i-1; EXIT; ]
               1      media(i,nmed) = ' ';
               1      media(i,nmed)(1:1) = c;
               1      ]
               0  IF( l < 24 ) [
               1      DO i=l+1,24 [ media(i,nmed) = ' '; ]
               1      ]
               0  egs_add_medium = nmed;
               0  return; end;
               0
               0  subroutine egs_get_medium_name(imed,medname);
               0  implicit none;
               0  character*(*) medname;
               0  $declare_max_medium;
               0  ;COMIN/MEDIA,EGS-IO/;
               0  $INTEGER i,l,imed;
               0  DO i=1,len(medname) [ medname(i:i) = ' '; ]
               0  IF( imed < 1 | imed > nmed ) [ return; ]
               0  l = 24;
               0  DO l=24,1,-1 [
               1      IF( media(l,imed)(1:1) ~= ' ' ) EXIT;
               1      ]
               0  l = min(l,len(medname));
               0  DO i=1,l [ medname(i:i) = media(i,imed)(1:1); ]
               0  return; end;
               0  ;
               0
               0  "============================================================================"
               0  "  Pass pointers to the cross section interpolation coefficients to          "
               0  "  an external subroutine                                                    "
               0  "============================================================================"
               0  subroutine egs_get_electron_data(func,imed,which);
               0  implicit none;
               0  $INTEGER imed,which;
               0  external func;
               0  $declare_max_medium;
               0  ;COMIN/ELECIN,MEDIA,EGS-IO/;
               0  $REAL    lemin,lemax;
               0
               0  lemin = (1 - eke0(imed))/eke1(imed);
               0  lemax = (meke(imed) - eke0(imed))/eke1(imed);
               0  IF( which = 1 ) [
               1      call func(meke(imed),lemin,lemax,esig0(1,imed),esig1(1,imed));
               1      ] ELSE IF( which = 2 ) [
               1      call func(meke(imed),lemin,lemax,psig0(1,imed),psig1(1,imed));
               1      ] ELSE IF( which = 3 ) [
               1      call func(meke(imed),lemin,lemax,ededx0(1,imed),ededx1(1,imed));
               1      ] ELSE IF( which = 4 ) [
               1      call func(meke(imed),lemin,lemax,pdedx0(1,imed),pdedx1(1,imed));
               1      ] ELSE IF( which = 5 ) [
               1      call func(meke(imed),lemin,lemax,ebr10(1,imed),ebr11(1,imed));
               1      ] ELSE IF( which = 6 ) [
               1      call func(meke(imed),lemin,lemax,pbr10(1,imed),pbr11(1,imed));
               1      ] ELSE IF( which = 7 ) [
               1      call func(meke(imed),lemin,lemax,pbr20(1,imed),pbr21(1,imed));
               1      ] ELSE IF( which = 8 ) [
               1      call func(meke(imed),lemin,lemax,tmxs0(1,imed),tmxs1(1,imed));
               1      ] ELSE IF( which = 9 ) [
               1      call func(meke(imed),lemin,lemax,range_ep(0,1,imed),range_ep(1,1,imed));
               1      ] ELSE [
               1      $egs_fatal(*,'Unknown electron data type ',which);
               1      ]
               0  return; end;
               0
               0  subroutine egs_get_photon_data(func,imed,which);
               0  implicit none;
               0  $INTEGER imed,which;
               0  external func;
               0  $declare_max_medium;
               0  ;COMIN/PHOTIN,MEDIA,EGS-IO/;
               0  $REAL    lemin,lemax;
               0
               0  lemin = (1 - ge0(imed))/ge1(imed);
               0  lemax = (mge(imed) - ge0(imed))/ge1(imed);
               0  IF( which = 1 ) [
               1      call func(mge(imed),lemin,lemax,gmfp0(1,imed),gmfp1(1,imed));
               1      ] ELSE IF( which = 2 ) [
               1      call func(mge(imed),lemin,lemax,gbr10(1,imed),gbr11(1,imed));
               1      ] ELSE IF( which = 3 ) [
               1      call func(mge(imed),lemin,lemax,gbr20(1,imed),gbr21(1,imed));
               1      ] ELSE IF( which = 4 ) [
               1      call func(mge(imed),lemin,lemax,cohe0(1,imed),cohe1(1,imed));
               1      ] ELSE IF( which = 5 ) [
               1      call func(mge(imed),lemin,lemax,PHOTONUC0(1,imed),PHOTONUC1(1,imed));
               1      ] ELSE [
               1      $egs_fatal(*,'Unknown photon data type ',which);
               1      ]
               0  return; end;
               0
               0
               0
               0
               0
               0
               0
               0
               0  subroutine egs_print_binding_energies;
               0  implicit none;
               0  $declare_max_medium;
               0  ;COMIN/EDGE,MEDIA,EGS-IO/;
               0  $INTEGER    i,j;
               0  integer*4   lnblnk1;
               0  character*3 labels(16);
               0  data labels/'  K',' L1',' L2',' L3',
               0  ' M1',' M2',' M3',' M4',' M5',
               0  ' N1',' N2',' N3',' N4',' N5',' N6',' N7'/;
               0
               0  $egs_info('(a,a,a)',
               0  'Binding energies from ',$cstring(photon_xsections),
               0  ' photon cross section library');
               0  DO j = 1,$MXELEMENT [
               1      DO i = 1,$MXPESHELL [
               2          IF ( binding_energies(i,j) > 0 ) [
               3              $egs_info('(a,i3,a,a,a,1pe12.4,a)',
               3              ' Eb(',j,',',labels(i),') = ',binding_energies(i,j),' MeV');
               3              ]
               2          ]
               1      ]
               0
               0  return;end;
               0
               0
               0  "============================================================================="
               0  "  scale elastic scattering strength by a given factor                        "
               0  "============================================================================="
               0  subroutine egs_scale_xcc(imed,factor);
               0  implicit none;
               0  $INTEGER imed;
               0  $REAL    factor;
               0  $declare_max_medium;
               0  ;COMIN/ELECIN,MEDIA/;
               0  IF( imed > 0 & imed <= nmed ) [ xcc(imed) = xcc(imed)*factor; ]
               0  return; end;
               0
               0
               0  "============================================================================"
               0  subroutine egs_write_string(ounit,string);
               0  implicit none;
               0  $INTEGER ounit;
               0  character*(*) string;
               0  write(ounit,'(a,$)') string;
               0  $FLUSH_UNIT(ounit);
               0  return; end;
               0
               0
               0  "============================================================================"
               0  subroutine egs_swap_2(c);
               0  "============================================================================"
               0  " Convert a 2 byte object from little endian to big endian byte order        "
               0  " or vice versa                                                              "
               0  character  c(2),tmp;
               0  tmp=c(2); c(2)=c(1); c(1)=tmp;
               0  return; end;
               0
               0  "============================================================================"
               0  subroutine egs_swap_4(c);
               0  "============================================================================"
               0  " Convert a 2 byte object from little endian to big endian byte order        "
               0  " or vice versa                                                              "
               0  character  c(4),tmp;
               0  tmp=c(4); c(4)=c(1); c(1)=tmp;
               0  tmp=c(3); c(3)=c(2); c(2)=tmp;
               0  return; end;
               0
               0
               0  "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
               0  " Utility subroutines and functions previously in egsnrc.mortran
               0  "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
               0
1              0  %E
               0  subroutine set_spline(x,f,a,b,c,d,n);
               0  "======================================================================"
               0  "
               0  " Sets cubic spline interpolation coefficients for the data contained  "
               0  " in the array f(n) at the abscissas x(n)                              "
               0  "                                                                      "
               0  " I.Kawrakow, NRC                                                      "
               0  "======================================================================"
               0
               0  implicit none;
               0
               0  $INTEGER n;
               0  $REAL    x(n),f(n),a(n),b(n),c(n),d(n);
               0
               0  $INTEGER m1,m2,m,mr;
               0  $REAL    s,r;
               0
               0  m1 = 2; m2 = n-1; s = 0;
               0  DO m=1,m2 [
               1      d(m) = x(m+1) - x(m); r = (f(m+1) - f(m))/d(m);
               1      c(m) = r - s; s = r;
               1      ]
               0  /s,r,c(1),c(n)/=0;
               0  DO m=m1,m2 [
               1      c(m) = c(m) + r*c(m-1);
               1      b(m) = 2*(x(m-1) - x(m+1)) - r*s;
               1      s = d(m); r = s/b(m);
               1      ]
               0  mr = m2;
               0  DO m=m1,m2 [
               1      c(mr) = (d(mr)*c(mr+1) - c(mr))/b(mr);
               1      mr = mr - 1;
               1      ]
               0  DO m=1,m2 [
               1      s = d(m); r = c(m+1) - c(m); d(m) = r/s;
               1      c(m) = 3*c(m);
               1      b(m) = (f(m+1)-f(m))/s - (c(m)+r)*s;
               1      a(m) = f(m);
               1      ]
               0  return; end;
               0  ;
               0
               0  $REAL function spline(s,x,a,b,c,d,n);
               0  "======================================================================"
               0  "                                                                      "
               0  " Returns the value of the function at s using the spline coefficients "
               0  " a,b,c,d, which must have been set using set_spline                   "
               0  "                                                                      "
               0  " I.Kawrakow, NRC                                                      "
               0  "======================================================================"
               0
               0  implicit none;
               0
               0  $INTEGER n;
               0  $REAL    s,x(n),a(n),b(n),c(n),d(n);
               0
               0  integer  m_lower,m_upper,direction,m,ml,mu,mav;
               0  $REAL    q;
               0
               0  IF( x(1) > x(n) ) [ direction = 1; m_lower = n; m_upper = 0; ]
               0  ELSE              [ direction = 0; m_lower = 0; m_upper = n; ]
               0  IF ( s >= x(m_upper + direction) ) [
               1      m = m_upper + 2*direction - 1;
               1      ]
               0  ELSE IF( s <= x(m_lower+1-direction) ) [
               1      m = m_lower - 2*direction + 1;
               1      ]
               0  ELSE [   " Perform a binary search to find the interval s is in "
               1      ml = m_lower; mu = m_upper;
               1      WHILE ( iabs(mu-ml) > 1 ) [
               2          mav = (ml+mu)/2;
               2          IF( s < x(mav) ) [ mu = mav; ]
               2          ELSE             [ ml = mav; ]
               2          ]
               1      m = mu + direction - 1;
               1      ]
               0  q = s - x(m);
               0  spline = a(m) + q*(b(m) + q*(c(m) + q*d(m)));
               0  return; end;
               0  ;
               0
1              0  %E "start of prepare_alias_table subroutine"
               0  "****************************************************************************
               0
               0  subroutine prepare_alias_table(nsbin,xs_array,fs_array,ws_array,ibin_array);
               0
               0  " Prepare an alias sampling table, given the histogram probabilities
               0  " xs_array,fs_array.
               0  "*****************************************************************************
               0  implicit none;
               0
               0  integer   nsbin;
               0  $INTEGER  ibin_array(nsbin);
               0  $REAL     xs_array(0:nsbin),fs_array(0:nsbin),ws_array(nsbin);
               0
               0  $INTEGER  i,j_l,j_h;
               0  $REAL     sum,aux;
               0
               0  sum = 0;
               0  DO i=1,nsbin [
               1      aux = 0.5*(fs_array(i)+fs_array(i-1))*(xs_array(i)-xs_array(i-1));
               1      IF( aux < 1e-30 ) aux = 1e-30;
               1      ws_array(i) = -aux; ibin_array(i) = 1;
               1      sum = sum + aux;
               1      ]
               0  sum = sum/nsbin;
               0
               0  DO i=1,nsbin-1 [
               1
               1      DO j_h = 1,nsbin [
               2          IF( ws_array(j_h) < 0 ) [
               3              IF( abs(ws_array(j_h)) > sum ) GOTO :AT_EXIT_1:;
               3              ]
               2          ]
               1      j_h = nsbin;
               1      :AT_EXIT_1:
               1
               1      DO j_l = 1,nsbin [
               2          IF( ws_array(j_l) < 0 ) [
               3              IF( abs(ws_array(j_l)) < sum ) GOTO :AT_EXIT_2:;
               3              ]
               2          ]
               1      j_l = nsbin;
               1      :AT_EXIT_2:
               1
               1      aux = sum - abs(ws_array(j_l));
               1      ws_array(j_h) = ws_array(j_h) + aux;
               1      ws_array(j_l) = -ws_array(j_l)/sum;
               1      ibin_array(j_l) = j_h;
               1      IF( i = nsbin-1 ) ws_array(j_h) = 1;
               1
               1      ]
               0
               0  return; end;
               0  ;
               0
1              0  %E   " start of alias_sample1 function "
               0  "******************************************************************************
               0
               0  $REAL function alias_sample1(nsbin,xs_array,fs_array,ws_array,ibin_array);
               0
               0  " Sample a random variable from the alias table
               0  "    xs_array,fs_array,ws_array,ibin_array
               0  " which must have been prepared with prepare_alias_table
               0  "
               0  "******************************************************************************
               0  implicit none;
               0
               0  integer   nsbin;
               0  $INTEGER  ibin_array(nsbin);
               0  $REAL     xs_array(0:nsbin),fs_array(0:nsbin),ws_array(nsbin);
               0
               0  ;COMIN/RANDOM/;
               0
               0  $INTEGER j;
               0  $REAL    r1,r2,aj,x,dx,a,rnno1;
               0
               0  $RANDOMSET r1; $RANDOMSET r2;
               0  aj = 1 + r1*nsbin; j = aj; aj = aj - j;
               0  IF( aj > ws_array(j) ) j = ibin_array(j);
               0  x = xs_array(j-1); dx = xs_array(j)-x;
               0  IF( fs_array(j-1) > 0 ) [
               1      a = fs_array(j)/fs_array(j-1)-1;
               1      IF( abs(a) < 0.2 ) [
               2          rnno1 = 0.5*(1-r2)*a;
               2          alias_sample1 = x + r2*dx*(1+rnno1*(1-r2*a));
               2          ]
               1      ELSE [
               2          alias_sample1 = x - dx/a*(1-sqrt(1+r2*a*(2+a)));
               2          ]
               1      ]
               0  ELSE [
               1      alias_sample1 = x + dx*sqrt(r2);
               1      ]
               0  return; end;
               0  ;
               0
1              0  %E   " start of prepare_alias_histogram routine "
               0  subroutine prepare_alias_histogram(nsbin,ws_array,ibin_array);
               0  "*************************************************************
               0  "                                                                           "
               0  " Prepares an alias histogram for the probability array ws_array of         "
               0  " dimension nsbin.                                                          "
               0  " On return, the ws_array is modified and contains the alias weights,       "
               0  " ibin_array holds the alias indices.                                       "
               0  " To be used with the integer function sample_alias_histogram, which        "
               0  " returns a bin index j with probability ws_array(j)                        "
               0  "                                                                           "
               0  " Iwan Kawrakow, November 2001
               0  "***************************************************************************"
               0
               0  implicit none;
               0
               0  $INTEGER  nsbin,ibin_array(nsbin);
               0  $REAL     ws_array(nsbin);
               0
               0  $INTEGER  i,j_l,j_h;
               0  $REAL     sum,aux;
               0
               0  sum = 0;
               0  DO i=1,nsbin [
               1      sum = sum + ws_array(i); ibin_array(i) = -1;
               1      ]
               0  sum = sum/nsbin;
               0
               0  DO i=1,nsbin-1 [
               1
               1      DO j_h = 1,nsbin [
               2          IF( ibin_array(j_h) < 0 & ws_array(j_h) > sum ) EXIT;
               2          ]
               1
               1      DO j_l = 1,nsbin [
               2          IF( ibin_array(j_l) < 0 & ws_array(j_l) < sum ) EXIT;
               2          ]
               1
               1      aux = sum - ws_array(j_l);
               1      ws_array(j_h) = ws_array(j_h) - aux;
               1      ws_array(j_l) = ws_array(j_l)/sum;
               1      ibin_array(j_l) = j_h;
               1
               1      ]
               0
               0  DO i=1,nsbin [
               1      IF( ibin_array(i) < 0 ) [
               2          ibin_array(i) = i; ws_array(i) = 1;
               2          ]
               1      ]
               0
               0  return;
               0  end;
               0
1              0  %E   " start of sample_alias_histogram function "
               0  $INTEGER function sample_alias_histogram(nsbin,ws_array,ibin_array);
               0  "***********************************************************************
               0  "
               0  " This function samples a bin index using the alias sampling technique.
               0  " The arrays ws_array and ibin_array of dimension nsbin must have been
               0  " prepared with the subroutine prepare_alias_histogram.
               0  "
               0  " Iwan Kawrakow, November 2001.
               0  "***********************************************************************
               0
               0  implicit none;
               0
               0  $INTEGER  nsbin,ibin_array(*);
               0  $REAL     ws_array(*);
               0
               0  ;COMIN/RANDOM/;
               0
               0  $REAL    r1,r2;
               0  $INTEGER ibin;
               0
               0  $RANDOMSET r1; $RANDOMSET r2;
               0  ibin = 1 + nsbin*r1;
               0  IF( r2 > ws_array(ibin) ) ibin = ibin_array(ibin);
               0  sample_alias_histogram = ibin;
               0  return;
               0  end;
               0
1              0  %E   " start of gauss_legendre subroutine "
               0  "******************************************************************************
               0
               0  subroutine gauss_legendre(x1,x2,x,w,n);
               0
               0  "     Given the lower and upper limit of integration, x1 and x2,
               0  "     and given n, this routine returns arrays x and w,
               0  "     containing the abscissas and weights of the Gauss-Legendre
               0  "     n - point quadrature formula
               0  "
               0  "******************************************************************************
               0  $IMPLICIT-NONE;
               0
               0  $INTEGER n;
               0  real*8   x1,x2,x(n),w(n);
               0
               0  real*8     eps,Pi;
               0  parameter (eps = 3.D-14, Pi = 3.141592654D0);
               0
               0  $INTEGER i,m,j;
               0  real*8   xm,xl,z,z1,p1,p2,p3,pp;
               0
               0  m = (n + 1)/2;
               0  xm=0.5d0*(x2+x1); xl=0.5d0*(x2-x1);
               0  DO i=1,m [
               1      z=cos(Pi*(i-.25d0)/(n+.5d0));
               1      LOOP [
               2          p1=1.d0; p2=0.d0;
               2          DO j=1,n [
               3              p3 = p2; p2 = p1;
               3              p1=((2.d0*j-1.d0)*z*p2-(j-1.d0)*p3)/j;
               3              ]
               2          pp=n*(z*p1-p2)/(z*z-1.d0);
               2          z1=z; z=z1-p1/pp;
               2          ] UNTIL (abs(z-z1) < eps);
               1      x(i)=xm-xl*z; x(n+1-i)=xm+xl*z;
               1      w(i)=2.d0*xl/((1.d0-z*z)*pp*pp); w(n+1-i)=w(i);
               1      ]
               0  return; end;
               0  ;
               0
1              0  %E   " start of lnblnk1 function"
               0  "******************************************************************************
               0
               0  integer  function lnblnk1(string);
               0
               0  "Function to return index of last non-blank character in a string"
               0  "We use this instead of lnblnk because there are compilers"
               0  "that do not have lnblnk"
               0
               0  "******************************************************************************
               0  character*(*) string;
               0  integer i;
               0  DO i=len(string),1,-1 [
               1      j = ichar(string(i:i));
               1      IF( j = 0 ) [ lnblnk1 = i-1; return; ] "i.e. the same as strlen for "
               1      "0-terminated C-strings"
               1      IF( j ~= 9 & j ~= 10 & j ~= 11 & j ~= 12 & j ~= 13 & j ~= 32 ) [
               2          lnblnk1 = i; return;
               2          ]
               1      ]
               0  lnblnk1 = 0; return; end;
               0
1              0  %E   " start of erf1 function "
               0  "************************************************************************
               0  "       an error function routine which is needed since some of
               0  "       the compiler don't have it as an intrinsic
               0  "
               0  "       Originally came from some library somewhere (Harwell I think)
               0  "       recoded in mortran
               0  "************************************************************************
               0
               0  $REAL FUNCTION ERF1(X);
               0
               0  $IMPLICIT-NONE;
               0
               0  $REAL x;
               0
               0  double precision A(0:22,2);     " Coefficients in expansion for erf(x) if x<3
               0  " (K=1) and for erfc(x) x>3 (K=2)
               0  double precision
               0  CONST,                   " 2/sqrt(pi)
               0  BN,BN1,BN2,              " Recursion coefficients B(n),B(n+1),B(n+2)
               0  Y,FAC;                   " y=x/3 or 3/x and FAC = 2(2y**2-1)
               0  $INTEGER N,                     " recursion index n
               0  K,                     " K=1,2 for x <= 3 or x > 3
               0  NLIM(2);               " Maximum value of n in sum for K=1,2
               0
               0  DATA A/  1.0954712997776232 , -0.2891754011269890 ,  0.1104563986337951 ,
               0  -0.0412531882278565 ,  0.0140828380706516 , -0.0043292954474314 ,
               0  0.0011982719015923 , -0.0002999729623532 ,  0.0000683258603789 ,
               0  -0.0000142469884549 ,  0.0000027354087728 , -0.0000004861912872 ,
               0  0.0000000803872762 , -0.0000000124184183 ,  0.0000000017995326 ,
               0  -0.0000000002454795 ,  0.0000000000316251 , -0.0000000000038590 ,
               0  0.0000000000004472 , -0.0000000000000493 ,  0.0000000000000052 ,
               0  -0.0000000000000005 ,  0.0000000000000001 ,
               0  0.9750834237085559 , -0.0240493938504146 ,  0.0008204522408804 ,
               0  -0.0000434293081303 ,  0.0000030184470340 , -0.0000002544733193 ,
               0  0.0000000248583530 , -0.0000000027317201 ,  0.0000000003308472 ,
               0  0.0000000000001464 , -0.0000000000000244 ,  0.0000000000000042 ,
               0  -0.0000000000000008 ,  0.0000000000000001 ,  9*0.0              /;
               0
               0  DATA NLIM/ 22,16 /;
               0  DATA CONST/ 1.128379167095513 /;
               0
               0  IF( x > 3 ) [ y = 3/x; k = 2; ]
               0  ELSE        [ y = x/3; k = 1; ]
               0
               0  " Calculate sum of Chebyshev polynomials by backwards recursion
               0  "
               0  "       sum { A(n)*T(2n+1;y) : n=0,N } = y * ( B(0) - B(1) )
               0  "       sum { A(n)*T(2n;y)   : n=0,N } = ( B(0) - (2*y**2-1) * B(1) ) / 2
               0  "                                      = ( B(0) - B(2) + A(0) ) / 2
               0  "
               0  "       where B(N+2) = B(N+1) = 0
               0  "       and B(n) = 2*(2*y**2-1)*B(n+1) - B(n+2) + A(n) for n=N,(N-1),...,1,0
               0  "
               0  FAC = 2.0 * ( 2.0 * Y*Y - 1.0 );
               0  BN1 = 0.0;                       " Initialise B(N+2) = 0
               0  BN  = 0.0;                       " Initialise B(N+1) = 0
               0
               0  DO n = NLIM(K),0,-1 [
               1      BN2 = BN1; BN1 = BN;
               1      BN = FAC * BN1 - BN2 + A(N,K)
               1      ]
               0
               0  IF ( k = 1 ) [ erf1 = CONST * Y * ( BN - BN1 ); ]
               0  ELSE       [ erf1 = 1 - CONST * EXP(-X**2) * ( BN - BN2 + A(0,K) )/(4.0 * X); ]
               0
               0  RETURN;
               0  end;
               0
1              0  %E   " start of zero function "
               0  "********************************************************"
               0  "   Finds minimum non-zero value which can be used for   "
               0  "   evaluating logarithms without getting a NAN.         "
               0  "                                                        "
               0  " Starting with 10^-20 and decreasing it by 5 orders of  "
               0  " magnitud at a time, a check is made until the compiler "
               0  " recognizes the number as zero and the previous number  "
               0  " used. The same procedure is applied to this number but "
               0  " decreasing it by one order of magnitud. Finally it is  "
               0  " divided by 2..10 until the zero-check is successful.   "
               0  "********************************************************"
               0  $REAL FUNCTION ZERO();
               0  $IMPLICIT-NONE;
               0
               0  $INTEGER i;
               0  $REAL    x, xtemp;
               0
               0  x = 1.E-20;
               0  "jump over 5 orders of magnitude"
               0  DO i=1,100[
               1      IF (x = 0.0) [EXIT;]
               1      ELSE[xtemp = x;]
               1      x = x/1.E5;
               1      ]
               0  x = xtemp;
               0  "jump over 1 order of magnitude"
               0  DO i=1,5[
               1      IF (x ~= 0.0)[xtemp = x;]
               1      ELSE[EXIT;]
               1      x = x/10;
               1      ]
               0  x = xtemp;
               0  "divide it up by 2...10"
               0  DO i=2,10[
               1      IF (x ~= 0.0)[xtemp = x;]
               1      ELSE[EXIT;]
               1      x = x/i;
               1      ]
               0  zero = xtemp;
               0  return;end;
               0  ;
               0
1              0  %E   " start of toUpper function "
               0  "**************************************"
               0  "
               0  "   Converts a string to upper case.   "
               0  "                                      "
               0  "**************************************"
               0  character*512 function toUpper(a_string);
               0  character*(*) a_string;
               0  character*512 the_string;
               0  $INTEGER cursor, i, lnblnk1;
               0  toUpper = a_string; the_string = a_string;
               0  DO i=1, lnblnk1(the_string) [
               1      cursor=ICHAR(the_string(i:i));
               1      IF ((cursor.GE.97).AND.(cursor.LE.122)) [
               2          cursor=cursor-32;toUpper(i:i)=CHAR(cursor);
               2          ]
               1      ]
               0  return; end;
               0  ;
               0
               0
               0
               0
               0
               0
               0
               0
               0  "================================================================="
               0  integer*1 function egs_read_byte(iunit, jrec);
               0  "================================================================="
               0  " Reads one byte from a C/C++ binary file at jrec position        "
               0  implicit none;
               0  integer iunit, jrec, i, j, ierr;
               0  integer*1 i_1;
               0  character c_1;
               0  equivalence (i_1,c_1);
               0  ;COMIN/EGS-IO/;
               0  read(iunit,rec=jrec,IOSTAT=ierr) c_1;
               0  IF (ierr.ne.0) [
               1      $egs_warning(*,' *** egs_read_byte: ERROR READING A byte *** ');
               1      $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
               1      egs_read_byte = -1; return;
               1      ]
               0  jrec = jrec + 1; egs_read_byte = i_1;
               0  return; end;
               0
               0  "================================================================="
               0  integer*2 function egs_read_short(iunit, jrec);
               0  "================================================================="
               0  " Reads short int from a C/C++ binary file at jrec position        "
               0  implicit none;
               0  integer iunit, jrec, i, j, ierr;
               0  integer*2 i_2;
               0  character c_2(2);
               0  equivalence (i_2,c_2);
               0  ;COMIN/EGS-IO/;
               0  j = 0;
               0  DO i=jrec,jrec+1[
               1      j = j + 1;
               1      read(iunit,rec=i,IOSTAT=ierr) c_2(j);
               1      IF (ierr.ne.0) [
               2          $egs_warning(*,' *** egs_read_short: ERROR READING short integer *** ');
               2          $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
               2          egs_read_short = -1; return;
               2          ]
               1      ]
               0  jrec = jrec + 2; egs_read_short = i_2;
               0  return; end;
               0
               0  "================================================================="
               0  integer*4 function egs_read_int(iunit, jrec);
               0  "================================================================="
               0  " Reads integer from a C/C++ binary file at jrec position        "
               0  implicit none;
               0  integer iunit, jrec, i, j, ierr;
               0  integer*4 i_4;
               0  character c_4(4);
               0  equivalence (i_4,c_4);
               0  ;COMIN/EGS-IO/;
               0  j = 0;
               0  DO i=jrec,jrec+3[
               1      j = j + 1;
               1      read(iunit,rec=i,IOSTAT=ierr) c_4(j);
               1      IF (ierr.ne.0) [
               2          $egs_warning(*,' *** egs_read_int: ERROR READING integer *** ');
               2          $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
               2          egs_read_int = -1; return;
               2          ]
               1      ]
               0  jrec = jrec + 4; egs_read_int = i_4;
               0  return; end;
               0
               0
               0  "================================================================="
               0  real*4 function egs_read_real(iunit, jrec);
               0  "================================================================="
               0  " Reads float from a C/C++ binary file at jrec position        "
               0  implicit none;
               0  integer iunit, jrec, i, j, ierr;
               0  real*4 r_4;
               0  character c_4(4);
               0  equivalence (r_4,c_4);
               0  ;COMIN/EGS-IO/;
               0  j = 0;
               0  DO i=jrec,jrec+3[
               1      j = j + 1;
               1      read(iunit,rec=i,IOSTAT=ierr) c_4(j);
               1      IF (ierr.ne.0) [
               2          $egs_warning(*,' *** egs_read_real: ERROR READING float *** ');
               2          $egs_info(*,' From unit ',iunit,' position ',jrec,' bytes');
               2          egs_read_real = -1; return;
               2          ]
               1      ]
               0  jrec = jrec + 4; egs_read_real = r_4;
               0  return; end;
               0
               0  "****************************************************************
               0  "*                                                              *
               0  "*                 Function ibsearch(a, nsh, b)                 *
               0  "*                                                              *
               0  "*       binary search for an element l of array b such that    *
               0  "*   b[l] =< a < b[l+1], array must be monotonically increasing *
               0  "*                                                              *
               0  "****************************************************************
               0  $INTEGER function ibsearch(a, nsh, b);
               0  implicit none;
               0  $REAL a, b(*);
               0  $INTEGER min,max,help,nsh;
               0  $REAL x;
               0  min = 1; max = nsh; x = a;
               0  WHILE ( min < max-1 )[
               1      help = (max+min)/2;
               1      IF ( b(help).le.x)[min = help;]
               1      ELSE[max = help;]
               1      ]
               0  ibsearch = min;
               0  return;end;
               0
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc subroutines for the C++ interface                                   "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Iwan Kawrakow, 2005                                       "
               0  "                                                                             "
               0  "  Contributors:                                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0
               0  subroutine egs_get_rng_pointers(np,ip);
               0  implicit none;
               0  $INTEGER ip,np;
               0  COMIN/RANDOM/;
               0  np = $NRANDOM; ip = rng_seed;
               0  return; end;
               0
               0
               0  subroutine egs_get_rng_array(array);
               0  implicit none;
               0  $REAL array(*);
               0  COMIN/RANDOM/;
               0  $INTEGER i;
               0  DO i=1,$NRANDOM [ array(i) = rng_array(i); ]
               0  return; end;
               0
               0
               0  subroutine egs_set_rng_state(ip,array);
               0  implicit none;
               0  $INTEGER ip,i;
               0  $REAL    array(*);
               0  COMIN/RANDOM/;
               0  DO i=1,$NRANDOM [ rng_array(i) = array(i); ]
               0  rng_seed = ip;
               0  return; end;
               0
               0
               0  subroutine egs_get_steps(ch_steps,all_steps);
               0  implicit none;
               0  real*8   ch_steps,all_steps;
               0  COMIN/CH-Steps/;
               0  ch_steps = count_pII_steps; all_steps = count_all_steps;
               0  return; end;
               0
               0
               0  subroutine egs_set_steps(ch_steps,all_steps);
               0  implicit none;
               0  real*8   ch_steps,all_steps;
               0  COMIN/CH-Steps/;
               0  count_pII_steps = ch_steps; count_all_steps = all_steps;
               0  return; end;
               0  ;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc transport parameter macros                                          "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Author:          Iwan Kawrakow, 2003                                       "
               0  "                                                                             "
               0  "  Contributors:    Blake Walters                                             "
               0  "                   Ernesto Mainegra-Hing                                     "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  These macros are used in conjunction with the get_inputs.mortran routines  "
               0  "  to read in EGSnrc transport physics parameters. Specifically with          "
               0  "  subroutine get_transport_parameter.                                        "
               0  "                                                                             "
               0  "  The following are definitions of code words (values sought) for the        "
               0  "  various transport parameters that can be set. I hope they are              "
               0  "  self-explanatory. If you don't like them:                                  "
               0  "                                                                             "
               0  "  - include this file via the configuration file BEFORE your user code.      "
               0  "                                                                             "
               0  "  - Replace the macros in your user code with code words that you prefer.    "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  REPLACE {$GLOBAL_ELECTRON_CUTOFF} WITH {'Global ECUT'}
               0  REPLACE {$GLOBAL_PHOTON_CUTOFF}   WITH {'Global PCUT'}
               0  REPLACE {$GLOBAL_SMAX}            WITH {'Global SMAX'}
               0  REPLACE {$INCOHERENT_SCATTERING}  WITH {'Bound Compton scattering'}
               0  REPLACE {$RADC_COMPTON}           WITH {'Radiative Compton corrections'}
               0  REPLACE {$COHERENT_SCATTERING}    WITH {'Rayleigh scattering'}
               0  REPLACE {$ATOMIC_RELAXATIONS}     WITH {'Atomic relaxations'}
               0  REPLACE {$PE_ANGULAR_SAMPLING}    WITH {'Photoelectron angular sampling'}
               0  REPLACE {$BREMS_ANGULAR_SAMPLING} WITH {'Brems angular sampling'}
               0  REPLACE {$BREMS_CROSS_SECTIONS}   WITH {'Brems cross sections'}
               0  REPLACE {$PAIR_ANGULAR_SAMPLING}  WITH {'Pair angular sampling'}
               0  REPLACE {$PAIR_CROSS_SECTIONS}    WITH {'Pair cross sections'}
               0  REPLACE {$TRIPLET_PRODUCTION}     WITH {'Triplet production'}
               0  REPLACE {$ELECTRON_IMPACT_IONI}   WITH {'Electron Impact Ionization'}
               0  REPLACE {$SPIN_EFFECTS}           WITH {'Spin effects'}
               0  REPLACE {$MAXIMUM_ESTEPE}         WITH {'ESTEPE'}
               0  REPLACE {$MAXIMUM_XIMAX}          WITH {'XImax'}
               0  REPLACE {$SKIN_FOR_BCA}           WITH {'Skin depth for BCA'}
               0  REPLACE {$BOUNDARY_ALGORITHM}     WITH {'Boundary crossing algorithm'}
               0  REPLACE {$ELECTRON_STEP_ALG}      WITH {'Electron-step algorithm'}
               0  REPLACE {$ON_IN_REGIONS}          WITH {'On in Regions'}
               0  REPLACE {$OFF_IN_REGIONS}         WITH {'Off in Regions'}
               0  REPLACE {$IN_REGIONS}             WITH {'Regions'}
               0  REPLACE {$THE_DELIMETER}          WITH {'MC TRANSPORT PARAMETER'}
               0  REPLACE {$PHOTON_XSECTIONS}       WITH {'Photon cross sections'}
               0  REPLACE {$COMPTON_XSECTIONS}      WITH {'Compton cross sections'}
               0  REPLACE {$PHOTON_XSECTIONS_OUT}   WITH {'Photon cross-sections output'}
               0  REPLACE {$SCALE_L_EII_XSECTIONS}  WITH {'scale L EII cross-sections'}
               0  "Ali:photonuc, 2 lines"
               0  "Cannot use $PHOTONUC; it clashes with other variables"
               0  REPLACE {$PHOTO_NUCLEAR}          WITH {'Photonuclear attenuation'}
               0  REPLACE {$PHOTONUC_XSECTIONS}     WITH {'Photonuclear cross sections'}
               0  REPLACE {$B_FIELD} WITH {'Magnetic Field'}
               0  REPLACE {$E_FIELD} WITH {'Electric Field'}
               0  REPLACE {$EM_LMT} WITH {'EM ESTEPE'}
               0  ;
               0
               0  REPLACE {$TURN-ON/OFF-IN-REGIONS(#,#,#,#);} WITH
               0  {;
            {  0  aux_inregions = .false.;
            {  0  IF( error_flags({P1}) = 0 ) [
            {  0  write(i_log,*) {P2};
            {  0  itmp = value({P1},1);
            {  0  IF( itmp = 2 | itmp = 3 ) [
            {  0  ival                = ival + 1;
            {  0  values_sought(ival) = {P2};
            {  0  nvalue(ival)        = 0;
            {  0  type(ival)          = 0;
            {  0  value_min(ival)     = 1;
            {  0  value_max(ival)     = $MXREG;
            {  0  default(ival)       = 1;
            {  0  ival                = ival + 1;
            {  0  values_sought(ival) = {P3};
            {  0  nvalue(ival)        = 0;
            {  0  type(ival)          = 0;
            {  0  value_min(ival)     = 1;
            {  0  value_max(ival)     = $MXREG;
            {  0  default(ival)       = 1;
            {  0  Nmin = ival-1; Nmax = ival;
            {  0  CALL GET_INPUT;
            {  0  IF( error_flags(ival-1) = 0 & error_flags(ival) = 0 ) [
            {  0  IF( nvalue(ival) = nvalue(ival-1) ) [
            {  0  iitmp = itmp-2;
            {  0  DO j=1,$MXREG [ {P4}(j) = iitmp; ]
            {  0  "i.e. set everywhere to 0 (if turn on) or 1 (if turn off)"
            {  0  iitmp = 1 - iitmp;
            {  0  "and then re-set in the specified regions"
            {  0  DO k=1,nvalue(ival) [
            {  0  istart = value(ival-1,k);
            {  0  iend = value(ival,k);
            {  0  "Ali:photonuc, 2 lines to crudely print start/stop regions"
            {  0  write(i_log,*) {P2},istart;
            {  0  write(i_log,*) {P3},iend;
            {  0  IF( istart <= iend ) [
            {  0  DO j=istart,iend [ {P4}(j) = iitmp; ]
            {  0  aux_inregions = .true.;
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ELSE [ value({P1},1) = {P4}(1); ]
            {  0  ]
            {  0  ELSE [ value({P1},1) = {P4}(1); ]
            {  0  ]
            {  0  ELSE [
            {  0  IF( itmp > 3 ) itmp = itmp-2;
            {  0  write(i_log,*) ' Setting all to ',itmp;
            {  0  DO j=1,$MXREG [ {P4}(j) = itmp; ]
            {  0  ]
            {  0  ]
            {  0  ELSE ["Use default value"
            {  0  "Check if default is other than ON or Off"
            {  0  "and shift as no input by regions requested"
            {  0  IF({P4}(1) = 2 | {P4}(1) = 3)[
            {  0  value({P1},1) = {P4}(1)+2;
            {  0  ]
            {  0  ELSE[
            {  0  value({P1},1) = {P4}(1);
            {  0  ]
            {  0  ]
            {  0
            {  0  };
               0
               0  REPLACE{$SET # IN REGIONS(#,#,#,#,#,#,#);} WITH
               0  {;
            {  0
            {  0  aux_inregions = .false.;
            {  0  ival                = ival + 1;
            {  0  {P2}                = ival;
            {  0  values_sought(ival) = {P6};
            {  0  nvalue(ival)        = 0;
            {  0  type(ival)          = 1;
            {  0  value_min(ival)     = {P3};
            {  0  value_max(ival)     = {P4};
            {  0  default(ival)       = {P5};
            {  0
            {  0  ival                = ival + 1;
            {  0  values_sought(ival) = {P7};
            {  0  nvalue(ival)        = 0;
            {  0  type(ival)          = 0;
            {  0  value_min(ival)     = 1;
            {  0  value_max(ival)     = $MXREG;
            {  0  default(ival)       = 1;
            {  0
            {  0  ival                = ival + 1;
            {  0  values_sought(ival) = {P8};
            {  0  nvalue(ival)        = 0;
            {  0  type(ival)          = 0;
            {  0  value_min(ival)     = 1;
            {  0  value_max(ival)     = $MXREG;
            {  0  default(ival)       = 1;
            {  0
            {  0  Nmin = {P2}; Nmax = {P2}+2; error_flag = 0;
            {  0  CALL GET_INPUT;
            {  0
            {  0  IF( error_flag = 0 ) [
            {  0  IF( nvalue({P2}) = nvalue(ival) & nvalue(ival-1) = nvalue(ival) ) [
            {  0  DO k=1,nvalue(ival) [
            {  0  istart = value(ival-1,k);
            {  0  iend = value(ival,k);
            {  0  IF( istart <= iend ) [
            {  0  DO j=istart,iend [ {P1}(j) = value({P2},k); ]
            {  0  aux_inregions = .true.;
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  ]
            {  0  };
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc parameter input functions                                           "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Aaron Merovitz, 1998                                      "
               0  "                   Dave Rogers, 1998                                         "
               0  "                   Iwan Kawrakow, 1998                                       "
               0  "                                                                             "
               0  "  Contributors:    Ernesto Mainegra-Hing                                     "
               0  "                   Blake Walters                                             "
               0  "                   Frederic Tessier                                          "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Iwan Kawrakow, 1998, version 2.0, major rework:                            "
               0  "                                                                             "
               0  "  - Input values taken only if between specified delimiters (prior this      "
               0  "    change, the first VALUES_SOUGHT found was taken, even if it was not      "
               0  "    between the specified delimiters).                                       "
               0  "                                                                             "
               0  "  - Changed argument list to a common block GetInput defined in egs4.macros  "
               0  "    to avoid memory use explosion.                                           "
               0  "                                                                             "
               0  "  - Eliminated initial loop checking for presence of values sought as it is  "
               0  "    not necessary.                                                           "
               0  "                                                                             "
               0  "  - Introduced macros for handling strings (skipping blanks and comments,    "
               0  "    changing to upper case, etc.)                                            "
               0  "                                                                             "
               0  "  - Eliminated string input bug: strings were always converted to upper case "
               0  "                                                                             "
               0  "  - Changed definition of strings to character*$MACRO where $MACRO has a     "
               0  "    certain value that can be be defined in the user code if longer strings  "
               0  "    are required.                                                            "
               0  "                                                                             "
               0  "                                                                             "
               0  "  Iwan Kawrakow, 1999, version 2.1, major rework:                            "
               0  "                                                                             "
               0  "  - Missing or misspelled end delimiter together with a missing value sought  "
               0  "    caused the routine to terminate. It now prints an error message and      "
               0  "    continues to look for additional input.                                  "
               0  "                                                                             "
               0  "  - Introduced an array ERROR_FLAGS where the input status of each of the    "
               0  "    attempted inputs is stored.                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  SUBROUTINE GET_INPUT;
               0  "                                                                           "
               0  "                                                                           "
               0  " FUNCTION: Extracts the requested values_sought from input file and        "
               0  "           returns it to the caller.                                       "
               0  "                                                                           "
               0  " USAGE   :      Inputs must have the general form:                         "
               0  "              ***************************************                      "
               0  "              * Value_sought=  Value(s)             *                      "
               0  "              ***************************************                      "
               0  "         e.g.:        MEDNUM= 0, 1, 2                                      "
               0  "                      MEDIA= AIR700ICRU                                    "
               0  "                      RAYLEIGH SCATTERING= on                              "
               0  "                                                                           "
               0  "***************************************************************************"
               0  "           >>>>>>>>>>>     BASIC RULES AND FEATURES    <<<<<<<<<<<         "
               0  "***************************************************************************"
               0  "
               0  "   Inputs are all in the format: name of value_sought= value
               0  "   where the name of value_sought must match that expected by the
               0  "   program and the = sign must have no blanks between it and value_sought.
               0  "
               0  "   The value_sought must be the first thing on a line but blanks are
               0  "     allowed before it.
               0  "
               0  "   Various inputs are only sought between certain delimeter strings
               0  "     which are defined below (eg :start I/O control: :stop I/O control:)
               0  "     If not specified, the whole file is searched for a requested value_sought.
               0  "     Delimeter strings are enclosed by colons.
               0  "     Note that within delimeter strings, order of inputs does not matter.
               0  "
               0  "   If a requested quantity is not found, this is noted in $input.errors
               0  "     and this file is printed at the end of the log file.
               0  "
               0  "   A semi-colon implies the end of input for this quantity but is
               0  "     not mandatory.  However, this means they cannot be used in titles.
               0  "   A # sign indicated everything else on the line is a comment (and
               0  "     cannot be used in titles.
               0  "   Case is not important in the names of the quantites.
               0  "
               0  "   Commas separate multiple values for a given quantity and a comma
               0  "     at the end of a line implies there is more input on the next line.
               0  "   Values can extend over as many lines as needed. Use commas to imply
               0  "     there are more values on the next line.
               0  "
               0  "   Blank lines and blanks in general are ignored.
               0  "
               0  "   The maximum record length is 256 characters.
               0  "
               0  "
               0  "*******************************************************************************
               0  "* (1)  *  Integers between parentheses show the value of the internal         *
               0  "*      *  variable corresponding to this input. These are for reference only. *
               0  "*      *                                                                      *
               0  "* (M)  *  The 'M' indicates that the variable at hand has multiple            *
               0  "*      *  input capability.  One may assign an arbitrary number of            *
               0  "*      *  values to that input.                                               *
               0  "*      *  E.g.:  NSLAB= 2, 10, 2, 16...                                       *
               0  "*      *                                                                      *
               0  "* (M2) *  The 'M' with an integer beside it means that the variable           *
               0  "*      *  has that number of inputs.                                          *
               0  "*      *  E.g.:  RANDOM NUMBER SEEDS= 97, 33                                  *
               0  "*      *                                                                      *
               0  "* (I)  *  Regular (one number) integer input value.                           *
               0  "*      *  E.g.:  SOURCE NUMBER= 0                                             *
               0  "*      *                                                                      *
               0  "* (R)  *  Regular (one number) real input value.                              *
               0  "*      *  E.g.:  Z OF FRONT FACE= -1000.0                                     *
               0  "*      *                                                                      *
               0  "* (C)  *  Regular (one string) character input value(no ; or #).              *
               0  "*      *  E.g.:  TITLE= NRCC EGS4 simulation                                  *
               0  "*      *                                                                      *
               0  "*******************************************************************************
               0  "                                                                           "
               0  "                                                                           "
               0  " FEATURES: If the amount of values needed for a particular values_sought   "
               0  "           is known and passed throught NVALUE(I), the subroutine will     "
               0  "           check that the number of inputs correspond.  Otherwise,         "
               0  "           NVALUE(I) will return the # of inputs found.                    "
               0  "                                                                           "
               0  "           For any integer or real (TYPE=0 or 1), get_inputs will check    "
               0  "           that the numerical value input is between VALUE_MIN and         "
               0  "           VALUE_MAX.  If not, it sets this value to the DEFAULT.          "
               0  "                                                                           "
               0  "           Writing in the input file can be upper case or lower case.      "
               0  "           However, all FORTRAN >MUST< be programmed in upper case.        "
               0  "              Changed the above: Can now be upper or lower case            "
               0  "                                 IK, Dec. 1998                             "
               0  "                                                                           "
               0  "           For clarity, inputs can be terminated with a semicolon(;).      "
               0  "           This is by no means necessary.                                  "
               0  "                                                                           "
               0  "***************************************************************************"
               0  "          >>>>>>>>>>> IMPLEMENTING INTO NEW USER CODES <<<<<<<<<<<         "
               0  "***************************************************************************"
               0  "                                                                           "
               0  "                   **** DECLARE YOUR INPUTS ****                           "
               0  "                                                                           "
               0  "    REALS AND INTEGERS (TYPE 0 AND 1)                                      "
               0  "                                                                           "
               0  "  I=I+1;                              <--index counter                     "
               0  "  NUM_DRMIN=I;                        <--named pointer to the index num.   "
               0  "  VALUES_SOUGHT(I)='DOSE RBOUND MIN'; <--name of variable                  "
               0  "  NVALUE(I)=1;                        <--# of inputs(left out if not known)"
               0  "  TYPE(I)=0;                          <--Type (0-3)                        "
               0  "  VALUE_MIN(I)=0;                     <--Minimum value                     "
               0  "  VALUE_MAX(I)=$MAXRADII-1;           <--Maximum value                     "
               0  "  DEFAULT(I)=0;                       <--Default value                     "
               0  "                                                                           "
               0  "    CHARACTER INPUTS (TYPE 2)                                              "
               0  "                                                                           "
               0  "  I=I+1;
               0  "  NUM_TITLE=I;
               0  "  VALUES_SOUGHT(I)='TITLE';
               0  "  TYPE(I)=2;
               0  "  NVALUE(I)=1;                        <--left out if not known
               0  "
               0  "    ALLOWED INPTUS (TYPE 3)
               0  "
               0  "  I=I+1;
               0  "  NUM_IWATCH=I;
               0  "  VALUES_SOUGHT(I)='IWATCH';
               0  "  NVALUE(I)=1;                        <--left out if not known
               0  "  TYPE(I)=3;
               0  "  ALLOWED_INPUTS(I,0)='OFF';
               0  "  ALLOWED_INPUTS(I,1)='INTERACTIONS';
               0  "  ALLOWED_INPUTS(I,2)='STEPS';
               0  "  ALLOWED_INPUTS(I,3)='DEPOSITED';
               0  "  ALLOWED_INPUTS(I,4)='GRAPH';
               0  "                                                                           "
               0  "                      **** STATE THE DELIMETER ****                        "
               0  "                                                                           "
               0  "            DELIMETER='TRANSPORT CONTROL'                                  "
               0  "     OR     DELIMETER='NONE';                                              "
               0  "                                                                           "
               0  "  **** CALL THE SUBROUTINE WITH THE APPROPRIATE INDEX NUMBER OF THE ****   "
               0  "                **** VALUES_SOUGHT(use NMIN and NMAX) ****                 "
               0  "                                                                           "
               0  "   The inputs are returned through CHAR_VALUE for character inputs         "
               0  "   or VALUE for integers, reals and allowed inputs                         "
               0  "                                                                           "
               0  "---------------------------------------------------------------------------"
               0
               0
               0  ;IMPLICIT NONE;
               0
               0  COMIN/GetInput,EGS-IO/;
               0
               0  "***************************************************************************"
               0  "*                   Variables used by the subroutine                      *"
               0  "***************************************************************************"
               0  CHARACTER*$STRING256 TEXT;      "Used to read in each line of the input file   "
               0  CHARACTER*$STRING256 KEEPTEXT;  "Used to keep an old line of TEXT              "
               0  CHARACTER*$STRING256 ORIGTEXT;  "The text without conversion to upper case     "
               0  CHARACTER*$STRING80  TEXTPIECE; "Used to read a piece of TEXT                  "
               0  CHARACTER*$STRING40  DELIM_START;"Start of the delimeter                       "
               0  CHARACTER*$STRING40  DELIM_END;  "End of the delimeter                         "
               0  CHARACTER*$STRING32  VNAME;      "The name of the variable being extracted.    "
               0  CHARACTER*$STRING32  VNAME1;     "The name of the variable being extracted.    "
               0  $INTEGER       CURSOR;          "Used to read one of the TEXT letters          "
               0  $INTEGER       IINDEX;          "Integer index for clipping string excess.     "
               0  $INTEGER       iVNAME;          "Length of variable name string.               "
               0  $INTEGER       IVAL;            "Value number of the value_sought              "
               0  $INTEGER       UNITNUM;         "Unit number of the input file                 "
               0  $INTEGER       ERR;             "Unit number of the error file                 "
               0  $INTEGER       I,J,K,CHECK;     "Counters and checkers                         "
               0  $INTEGER       LINE;            "Counts the eumber of lines                    "
               0  $INTEGER       INT_VALUE;       "For printing integers                         "
               0  $INTEGER       INT_VALUE_MIN;   "For printing integers                         "
               0  $INTEGER       INT_VALUE_MAX;   "For printing integers                         "
               0  $LOGICAL       ALLOWED;         "For evaluating an allowed_input               "
               0  $LOGICAL       START_FOUND;     "Start of delimeter switch                     "
               0  $INTEGER       ifound,length,lll,Kconvert;
               0  $INTEGER       lnblnk1;"in house lnblnk function becuase not all compilers     "
               0  "support this"
               0  logical IDEBUG;
               0  character*1 blank;
               0  $INTEGER    error_level;
               0  $INTEGER    the_level;
               0  data blank/' '/;
               0  data        error_level/1/;
               0  save        error_level;
               0  "---------------------------------------------------------------------------"
               0
               0  "Macro changing text string to upper case"
               0  "REPLACE {$CONVERT-STRING-TO-UPPER-CASE(#);} WITH"
               0  REPLACE {$CONVERT # TO UPPER CASE;} WITH
               0  {;
            {  0  DO Kconvert=1, lnblnk1({P1}) [
            {  0  CURSOR=ICHAR({P1}(Kconvert:Kconvert));
            {  0  IF ((CURSOR.GE.97).AND.(CURSOR.LE.122)) [
            {  0  CURSOR=CURSOR-32;
            {  0  {P1}(Kconvert:Kconvert)=CHAR(CURSOR);
            {  0  ]
            {  0  ]
            {  0  }
               0  ;
               0
               0  "Macro to skip leading blanks "
               0  REPLACE {$SKIP LEADING BLANKS IN #;} WITH
               0  {;
            {  0  length = len({P1});
            {  0  WHILE ( index({P1},blank) = 1 ) [
            {  0  IF( length >= 2 ) [ {P1}={P1}(2:); ] ELSE [ EXIT; ]
            {  0  length = length - 1;
            {  0  ]
            {  0  }
               0
               0  "Macro that removes everything after comments "
               0  REPLACE {$REMOVE EVERYTHING AFTER # IN #;} WITH
               0  {
            {  0  ifound = INDEX({P2},{P1});
            {  0  IF( ifound > 1 ) [ {P2} = {P2}(1:ifound-1); ]
            {  0  ELSE [ IF( ifound = 1 ) [ {P2} = blank; ] ]
            {  0  }
               0
               0  REPLACE {$STRING-OUTPUT(#);} WITH
               0  {;
            {  0  length = lnblnk1({P1});
            {  0  IF( length > 0 ) [
            {  0  DO lll=1,length [ write(i_log,'(a1,$)') {P1}(lll:lll); ]
            {  0  write(i_log,*); "For a new line"
            {  0  ]
            {  0  }
               0
               0  IDEBUG = .false.;   "set to .true. for debug outputs"
               0  ERROR_FLAG = 0;
               0  IF(IDEBUG) [OUTPUT NMIN,NMAX, $NMAX;(' Entering get_inputs seeking values',
               1      I5,' to', I5, '  with a max allowed of',I5);
               1      ]
               0  IF (NMAX < NMIN | NMAX > $NMAX)[
               1      OUTPUT NMAX, NMIN, $NMAX;
               1      (//' Error entering get_inputs: Asked for values from',I5,' to',I5,
               1      '    with a max of',I5//' This implies a bug in the calling routine'/
               1      ' Fix it up and try again.  Stopping now.');
               1      STOP;
               1      ]
               0  ERR=i_errors;    "inputfile.errors"
               0  UNITNUM=i_input; "inputfile.egs4inp"
               0  DELIM_START=':START '//DELIMETER(:lnblnk1(DELIMETER))//':';
               0  DELIM_END=':STOP '//DELIMETER(:lnblnk1(DELIMETER))//':';
               0  $CONVERT DELIM_START TO UPPER CASE; "This allows use of lower case letters"
               0  $CONVERT DELIM_END TO UPPER CASE; "This allows use of lower case letters"
               0
               0  IF(IDEBUG) [OUTPUT DELIM_START,DELIM_END;(' start and stop delimeters are:'/
               1      A/A/);
               1      ]
               0  "===================check that each value_sought is there===================="
               0
               0  DO I = NMIN, NMAX  [ "for each value_sought"
               1      REWIND (UNITNUM);   "Rewind the input file"
               1      LINE=0;             "reset line counter"
               1      CHECK=0;            "reset error checker"
               1      ERROR_FLAGS(I)=0;
               1      " Set to default for the case the input is not found "
               1      IF(TYPE(I) = 0 | TYPE(I) = 1) [ VALUE(I,1) = DEFAULT(I); ]
               1      IF(TYPE(I) = 3) [ VALUE(I,1) = 0; ]
               1      VNAME=VALUES_SOUGHT(I);
               1      iVNAME=lnblnk1(VNAME);
               1      IF( ivname < 1 )
               1      [
               2          IF( error_level > 0 ) [
               3              write(ERR,*) ' ======================= Warning ===================== ';
               3              write(ERR,*) '    Empty VALUES_SOUGHT passt to Get_Inputs()!         ';
               3              write(ERR,*) ' ===================================================== ';
               3              ]
               2          ERROR_FLAG=1;
               2          ERROR_FLAGS(I)=1;
               2          goto :END-NMIN-NMAX-LOOP:;
               2          ]
               1
               1      $CONVERT vname TO UPPER CASE; "This allows use of lower case letters"
               1      iindex = 0;
               1      IF (DELIMETER = 'NONE') [ start_found = .true.; ]
               1      ELSE                    [ start_found = .false.; ]
               1      WHILE ( iindex = 0 )  "Until the value sought is found"
               1      [
               2          :GI25:
               2          CONTINUE;
               2          LINE=LINE+1;
               2          IF( start_found ) [
               3              READ(UNITNUM,END=:GI1003:,ERR=:GI1001:,FMT='(A256)') TEXT;
               3              ]
               2          ELSE [
               3              READ(UNITNUM,END=:GI1004:,ERR=:GI1001:,FMT='(A256)') TEXT;
               3              ]
               2          "READ(UNITNUM,END=:GI1004:,ERR=:GI1001:,FMT='(A256)') TEXT;"
               2          $SKIP LEADING BLANKS IN text;
               2          $REMOVE EVERYTHING AFTER '#' IN text;
               2          $REMOVE EVERYTHING AFTER ';' IN text;
               2          length = lnblnk1(TEXT);
               2          TEXT=TEXT(:length);
               2          origtext = text(:length);
               2          $CONVERT text TO UPPER CASE;
               2          IF( ~start_found ) [
               3              IF (INDEX(TEXT,DELIM_START) ~= 0 ) [ start_found = .true.; ]
               3              goto :GI25:;
               3              ]
               2
               2          iindex=INDEX(TEXT,VNAME(:iVNAME));
               2
               2          " Check for end delimeter "
               2          IF( DELIMETER~='NONE' )
               2          [
               3              IF (INDEX(TEXT,DELIM_END)~=0)
               3              [
               4                  IF( error_level > 0 ) [
               5                      WRITE (ERR,*) '***************ERROR***************';
               5                      WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
               5                      '<<',' NOT FOUND';
               5                      WRITE (ERR,*) 'END OF DELIMETER: ',DELIMETER(:lnblnk1(DELIMETER));
               5                      ]
               4                  ERROR_FLAG=1;
               4                  ERROR_FLAGS(I)=1;
               4                  GOTO :END-NMIN-NMAX-LOOP:;
               4                  ]
               3              ]
               2          ] "end while loop. If we pass this loop, we have the values_sought string "
               1      "in text"
               1
               1      CHECK=0; "reset error checker"
               1      IF( idebug ) [
               2          write(i_log,*) ' ******* Found: ';
               2          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               2          write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
               2          ]
               1
               1      " Set string pointer to position after vname string and/or "
               1      " leadinf equals                                           "
               1      IINDEX=IINDEX+iVNAME;
               1      TEXT=TEXT(IINDEX:); origtext=origtext(iindex:);
               1      IF( idebug ) [
               2          write(i_log,*) ' After removing vname: ';
               2          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               2          write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
               2          ]
               1      IINDEX=INDEX(TEXT,'=');
               1      IF (IINDEX.NE.0) [
               2          TEXT=TEXT(IINDEX+1:); origtext=origtext(iindex+1:);
               2          ]
               1      ELSE [
               2          IINDEX=INDEX(TEXT,':');
               2          IF (IINDEX.NE.0) [
               3              TEXT=TEXT(IINDEX+1:); origtext=origtext(iindex+1:);
               3              ]
               2          ]
               1      IF( idebug ) [
               2          write(i_log,*) ' After removing leading equals: ';
               2          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               2          write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
               2          ]
               1
               1      "===============read the value(i)======================="
               1      IF ( (lnblnk1(TEXT)=0) | (lnblnk1(TEXT)=1) )
               1      [
               2          IF (vname(:ivname)='TITLE')
               2          [
               3              READ (UNITNUM,FMT='(A80)') TEXTPIECE;
               3              IF (lnblnk1(TEXTPIECE)~=0) [
               4                  TEXT=TEXTPIECE(:lnblnk1(TEXTPIECE));
               4                  $SKIP LEADING BLANKS IN text;
               4                  $SKIP LEADING BLANKS IN origtext;
               4                  GOTO :TITLE-THERE:;
               4                  ]
               3              ]
               2          IF( error_level > 0 ) [
               3              WRITE (ERR,*) '*************ERROR*************';
               3              WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               3              WRITE (ERR,*) 'VALUE NOT THERE!!';
               3              ]
               2          ERROR_FLAG=1;
               2          ERROR_FLAGS(I)=1;
               2          RETURN;
               2          ]
               1      :TITLE-THERE:
               1      CONTINUE;
               1
               1      " Always check for default. The following sets the value to "
               1      " default(i) for a numeric input (type=1 or 2) and to 0 for "
               1      " an 'allowed input' => use only if one input is expected!  "
               1      iindex = index(text,'DEFAULT');
               1      IF( iindex ~= 0 )
               1      [                  "User requested a default value"
               2          IF( type(i) ~= 2 )
               2          [
               3              IF( type(i) ~= 3 ) [ VALUE(I,1)=DEFAULT(I); ]
               3              ELSE               [ VALUE(I,1)=0;          ]
               3              goto :END-NMIN-NMAX-LOOP:;
               3              ]
               2          ]
               1
               1      IF ((TYPE(I) = 0)|(TYPE(I) = 1))
               1      [                                 "Read the number"
               2          IVAL=1;  "nvalue counter"
               2          IF( idebug )[write(i_log,*) ' *** Reading an integer or a real value! ';]
               3              LOOP
               2          [
               3              IF( idebug ) [write(i_log,*) ' In LOOP, ival = ',ival;]
               3              IF (lnblnk1(TEXT)=0) [
               4                  IF( error_level > 0 ) [
               5                      WRITE(ERR,*) '*************ERROR*************';
               5                      WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               5                      WRITE (ERR,*) 'VALUE NOT THERE!!';
               5                      ]
               4                  ERROR_FLAG=1;
               4                  ERROR_FLAGS(I)=1;
               4                  RETURN;
               4                  ]
               3              READ(TEXT,END=:GI1010:,ERR=:GI1007:,FMT=*) VALUE(I,IVAL);
               3              IF( idebug ) [write(i_log,*) ' Read value: ',ival,VALUE(I,IVAL);]
               3              "==========================================================================="
               3              "=================================Defaults=================================="
               3
               3              IF ((VALUE(I,IVAL)>VALUE_MAX(I))|(VALUE(I,IVAL)<VALUE_MIN(I)))
               3              [
               4                  IF (TYPE(I)=0)
               4                  [
               5                      INT_VALUE=DEFAULT(I);
               5                      IF( error_level > 0 ) [
               6                          WRITE(ERR,*) '************WARNING************';
               6                          WRITE(ERR,:FMTA:) INT_VALUE,
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I)));
               6                          ]
               5                      :FMTA: FORMAT ( 'Default= ',I9,' used for: ', A );
               5                      INT_VALUE=VALUE(I,IVAL);
               5                      INT_VALUE_MIN=VALUE_MIN(I);
               5                      INT_VALUE_MAX=VALUE_MAX(I);
               5                      IF( error_level > 0 ) [
               6                          WRITE(ERR,:FMTB:)
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
               6                          INT_VALUE, INT_VALUE_MIN,INT_VALUE_MAX;
               6                          ]
               5                      :FMTB: FORMAT (A,'=', I9,' should be between ',
               5                      I9,' and ', I9);
               5                      ]
               4                  IF (TYPE(I)=1)
               4                  [
               5                      IF( error_level > 0 ) [
               6                          WRITE(ERR,*) '************WARNING************';
               6                          WRITE(ERR,:FMTC:) DEFAULT(I),
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I)));
               6                          :FMTC: FORMAT ( 'Default= ',F12.6,' used for: ', A );
               6                          WRITE(ERR,:FMTD:)
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
               6                          VALUE(I,IVAL), VALUE_MIN(I),VALUE_MAX(I);
               6                          :FMTD: FORMAT (A,'=', F12.6,' should be between ',
               6                          G14.6,' and ', G14.6);
               6                          ]
               5                      ]
               4                  VALUE(I,IVAL)=DEFAULT(I);
               4                  ] "end IF default"
               3
               3              IF ( IVAL = NVALUE(I) ) EXIT; "Required inputs found"
               3              "==========================================================================="
               3              "=======================Move to next value, else exit======================="
               3
               3              IF ((INDEX(TEXT,',')~=0)|(lnblnk1(TEXT)=0))
               3              [
               4                  IF ( idebug ) [
               5                      write(i_log,*) ' A comma or a blank text found -> ';
               5                      write(i_log,*) ' searching for further input';
               5                      ]
               4                  TEXT=TEXT(INDEX(TEXT,',')+1:);
               4                  WHILE (lnblnk1(TEXT)=0)
               4                  [
               5                      IF ( idebug ) [
               6                          write(i_log,*) ' Empty text -> reading next line! ';
               6                          ]
               5                      LINE=LINE+1;
               5                      READ (UNITNUM,END=:GI1010:,ERR=:GI1007:,FMT='(A256)') TEXT;
               5                      $SKIP LEADING BLANKS IN text;
               5                      $REMOVE EVERYTHING AFTER '#' IN text;
               5                      $REMOVE EVERYTHING AFTER ';' IN text;
               5                      length = lnblnk1(TEXT);
               5                      TEXT=TEXT(:length);
               5                      origtext = text(:length);
               5                      $CONVERT text TO UPPER CASE;
               5
               5                      "Check whether this line containes one of the strings sought"
               5                      DO K = 1 , NMAX
               5                      [
               6                          vname1 = VALUES_SOUGHT(K);
               6                          length = lnblnk1(vname1);
               6                          IF( length > 0 )
               6                          [
               7                              $SKIP LEADING BLANKS IN vname1;
               7                              $CONVERT vname1 TO UPPER CASE;
               7                              IF (INDEX(TEXT,vname1(:length))~=0)
               7                              [
               8                                  IF( error_level > 0 ) [
               9                                      WRITE(ERR,*) '************ERROR************';
               9                                      WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               9                                      WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
               9                                      '<--COMMA INDICATES ANOTHER INPUT';
               9                                      WRITE(ERR,*) 'SEARCHED NEXT LINE: ',
               9                                      TEXT(:lnblnk1(TEXT));
               9                                      WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED';
               9                                      ]
               8                                  ERROR_FLAG=1;
               8                                  ERROR_FLAGS(I)=1;
               8                                  ]
               7                              ]
               6                          ]
               5                      IF( idebug ) [
               6                          write(i_log,*) ' Next line: ';
               6                          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               6                          write(i_log,'(a,$)') ' origtext: ';
               6                          $STRING-OUTPUT(origtext);
               6                          ]
               5                      ]
               4                  ] "end if ~=0"
               3              ELSE [EXIT;]
               3              IVAL=IVAL+1;
               3              ] "end loop"
               2          IF ((NVALUE(I)~=0)&(NVALUE(I)~=IVAL)) [
               3              IF( error_level > 0 ) [
               4                  WRITE (ERR,*) '**************ERROR**************';
               4                  WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I);
               4                  WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' NUMERICAL INPUT(S)';
               4                  WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED';
               4                  ]
               3              ERROR_FLAG=1;
               3              ERROR_FLAGS(I)=1;
               3              ]
               2          ELSE [NVALUE(I)=IVAL;]
               2          :GI1010:
               2          CONTINUE;
               2          ] "end IF TYPE"
               1
               1      "============================read the char_value(i)========================="
               1
               1      IF ((TYPE(I) = 2) | (TYPE(I) = 3))
               1      [                                   "Read the string"
               2          IVAL=1;     "nvalue counter"
               2          IF( idebug ) [write(i_log,*) ' Trying to read a string! ';]
               2          LOOP
               2          [
               3              IF( idebug ) [write(i_log,*) ' In LOOP, ival = ',ival;]
               3              IF (lnblnk1(TEXT)=0) [
               4                  IF( error_level > 0 ) [
               5                      WRITE(ERR,*) '*************ERROR*************';
               5                      WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               5                      WRITE (ERR,*) 'VALUE NOT THERE!!';
               5                      ]
               4                  ERROR_FLAG=1;
               4                  ERROR_FLAGS(I)=1;
               4                  RETURN;
               4                  ]
               3              IF (vname(:ivname)='TITLE') [
               4                  TEXTPIECE=origtext;
               4                  GOTO :READ-IT:
               4                  ]
               3              iindex = INDEX(origtext,',');
               3              IF ( iindex ~= 0 ) [ TEXTPIECE=origtext(:iindex-1); ]
               3              ELSE               [ TEXTPIECE=origtext;            ]
               3              "The above is to avoid conversion to upper case"
               3              "for e.g. media names                          "
               3              :READ-IT:
               3              CONTINUE;
               3              READ(TEXTPIECE,ERR=:GI1008:,FMT='(A80)') CHAR_VALUE(I,IVAL);
               3              $SKIP LEADING BLANKS IN CHAR_VALUE(I,IVAL);
               3              IF( idebug ) [
               4                  write(i_log,*) ' Read the following char string: ';
               4                  $STRING-OUTPUT(CHAR_VALUE(I,IVAL));
               4                  ]
               3              "===============================Allowed inputs=============================="
               3              IF (TYPE(I) = 3)
               3              [
               4                  $CONVERT CHAR_VALUE(I,IVAL) TO UPPER CASE;
               4                  ALLOWED=.FALSE.;
               4                  DO K=0, $MXALINP [
               5                      vname1 = ALLOWED_INPUTS(I,K);
               5                      $SKIP LEADING BLANKS IN ALLOWED_INPUTS(I,K);
               5                      $CONVERT ALLOWED_INPUTS(I,K) TO UPPER CASE;
               5                      IF (ALLOWED_INPUTS(I,K)=CHAR_VALUE(I,IVAL)) [
               6                          ALLOWED=.TRUE.;
               6                          VALUE(I,IVAL)=K;
               6                          IF( idebug ) [
               7                              write(i_log,*) ' Found a allowed_value match ',k;
               7                              ]
               6                          ]
               5                      ]
               4                  IF (.NOT.ALLOWED) [
               5                      WRITE(ERR,*) '*************ERROR*************';
               5                      IF (IVAL~=1) [
               6                          WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               6                          WRITE (ERR,*) 'SHOULD HAVE ONE INPUT ONLY';
               6                          WRITE (ERR,*) 'APPARENT STATE: COMMA INDICATING SECOND VALUE';
               6                          ]
               5                      ELSE [
               6                          WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               6                          WRITE(ERR,*) 'INPUT-->',
               6                          CHAR_VALUE(I,IVAL)(:lnblnk1(CHAR_VALUE(I,IVAL))),
               6                          '<--NOT ALLOWED';
               6                          WRITE(ERR,*) 'OPTIONS ARE:';
               6                          WRITE(ERR,:FMT:)
               6                          (ALLOWED_INPUTS(I,K)(:lnblnk1(ALLOWED_INPUTS(I,K))),
               6                          K=0,$MXALINP);
               6                          ]
               5                      :FMT: FORMAT(A40);
               5                      ERROR_FLAG=1;
               5                      ERROR_FLAGS(I)=1;
               5                      ]
               4                  ]
               3              "=======================Move to next value, else exit======================="
               3
               3              IF (vname(:ivname)='TITLE') [ EXIT; ]
               3              DO K=1,LEN(KEEPTEXT) [KEEPTEXT(K:K)=' ';]  "erase previous KEEPTEXT"
               3              KEEPTEXT(:lnblnk1(TEXT))=TEXT;
               3              iindex = INDEX(TEXT,',');
               3              IF ( iindex ~= 0 | lnblnk1(TEXT)=0 )
               3              [
               4                  TEXT=TEXT(INDEX(TEXT,',')+1:);
               4                  origtext=origtext(iindex+1:);
               4                  WHILE (lnblnk1(TEXT)=0)
               4                  [
               5                      LINE=LINE+1;
               5                      READ (UNITNUM,ERR=:GI1008:,FMT='(A256)') TEXT;
               5                      $SKIP LEADING BLANKS IN text;
               5                      $REMOVE EVERYTHING AFTER '#' IN text;
               5                      $REMOVE EVERYTHING AFTER ';' IN text;
               5                      length = lnblnk1(TEXT);
               5                      TEXT=TEXT(:length);
               5                      origtext = text(:length);
               5                      $CONVERT text TO UPPER CASE;
               5
               5                      "Check whether this line containes one of the strings sought"
               5                      DO K = 1 , NMAX
               5                      [
               6                          vname1 = VALUES_SOUGHT(K);
               6                          length = lnblnk1(vname1);
               6                          IF( length > 0 )
               6                          [
               7                              $SKIP LEADING BLANKS IN vname1;
               7                              $CONVERT vname1 TO UPPER CASE;
               7                              IF (INDEX(TEXT,vname1(:length))~=0)
               7                              [
               8                                  WRITE(ERR,*) '************ERROR************';
               8                                  WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               8                                  WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
               8                                  '<--COMMA INDICATES ANOTHER INPUT';
               8                                  WRITE(ERR,*) 'SEARCHED NEXT LINE: ',
               8                                  TEXT(:lnblnk1(TEXT));
               8                                  WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED';
               8                                  ERROR_FLAG=1;
               8                                  ERROR_FLAGS(I)=1;
               8                                  ]
               7                              ]
               6                          ]
               5                      ]
               4                  ] "end if ~=0"
               3              ELSE [EXIT;]
               3              IVAL=IVAL+1;
               3              ] "end loop"
               2          IF ((NVALUE(I)~=0)&(NVALUE(I)~=IVAL)) [
               3              IF( error_level > 0 ) [
               4                  WRITE (ERR,*) '*******************ERROR*******************';
               4                  WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I);
               4                  WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' INPUT(S)';
               4                  WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED';
               4                  ]
               3              ERROR_FLAG=1;
               3              ERROR_FLAGS(I)=1;
               3              ]
               2          ELSE [NVALUE(I)=IVAL;]
               2          ]
               1      "==========================================================================="
               1      "==========================================================================="
               1      goto :END-NMIN-NMAX-LOOP:;
               1
               1      :GI1003:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '******************ERROR***********************';
               2          WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND';
               2          WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED END DELIMETER';
               2          WRITE (ERR,*) 'VALUE SOUGHT: >>',
               2          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),'<<';
               2          WRITE (ERR,*) 'END DELIMETER: >>',
               2          DELIM_END(:lnblnk1(DELIM_END)),'<<';
               2          ]
               1      ERROR_FLAG=1;
               1      ERROR_FLAGS(I)=1;
               1      goto :END-NMIN-NMAX-LOOP:;
               1
               1      :GI1004:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '******************ERROR***********************';
               2          WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND';
               2          WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED START DELIMETER';
               2          WRITE (ERR,*) 'VALUE SOUGHT: >>',
               2          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),'<<';
               2          WRITE (ERR,*) 'START DELIMETER: >>',
               2          DELIM_START(:lnblnk1(DELIM_START)),'<<';
               2          ]
               1      ERROR_FLAG=1;
               1      ERROR_FLAGS(I)=1;
               1      goto :END-NMIN-NMAX-LOOP:;
               1
               1      :GI1007:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '***************ERROR***************';
               2          IF (IVAL>1) [J=IVAL;] ELSE [J=1;]
               2          WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I);
               2          WRITE (ERR,*) 'LINE #',LINE;
               2          WRITE (ERR,*) 'COULD NOT READ THE VALUE!!';
               2          WRITE (ERR,*) 'SHOULD BE AN INTEGER OR A REAL...';
               2          WRITE (ERR,*) 'IS THERE AN EXTRA COMMA AT THE END OF YOUR INPUT?';
               2          ]
               1      ERROR_FLAG=1; "turn on the error flag"
               1      ERROR_FLAGS(I)=1; "turn on the error flag"
               1      GOTO :END-NMIN-NMAX-LOOP:;
               1      :GI1008:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '***************ERROR***************';
               2          WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I);
               2          WRITE (ERR,*) 'LINE #',LINE;
               2          WRITE (ERR,*) 'COULD NOT READ THE STRING !!';
               2          ]
               1      ERROR_FLAG=1; "turn on the error flag"
               1      ERROR_FLAGS(I)=1; "turn on the error flag"
               1
               1      :END-NMIN-NMAX-LOOP:
               1      CONTINUE;
               1      ] "end do NMAX loop"
               0  RETURN;
               0
               0  "**************if any errors**************"
               0  :GI1001:
               0  WRITE (ERR,*) '***************ERROR***************';
               0  WRITE (ERR,*) 'ERROR READING TEXT ', TEXT,' ON LINE ',LINE;
               0  goto :GI1009:;
               0  "the following is no longer used so comment it out"
               0  ":GI1002:
               0  "      WRITE (ERR,*) '***************ERROR***************';
               0  "      IF (CHECK=100) [
               0  "         WRITE (ERR,*) 'DELIMETER: ',DELIMETER(:lnblnk1(DELIMETER));
               0  "         WRITE (ERR,*) 'WAS NOT FOUND';
               0  "      ]
               0  "      ELSE [
               0  "         WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
               0  "                       '<<',' NOT FOUND';
               0  "      ]
               0  "      WRITE (ERR,*) 'END OF FILE REACHED';
               0  :GI1009:
               0  CONTINUE;  "exit if there is an error"
               0  ERROR_FLAG=1; "turn on the error flag"
               0  ERROR_FLAGS(I)=1; "turn on the error flag"
               0  RETURN;
               0
               0  entry get_input_set_error_level(the_level);
               0  error_level = the_level;
               0  return;
               0  END;
               0
               0
               0
1              0  %E   "get_inputs.mortran"
               0  "*****************************************************************************
               0  "
               0  subroutine get_transport_parameter(ounit);
               0  "
               0  " is provided for use with the EGSnrc system. It reads all physics
               0  " related parameters from the input file using the get_input routine.
               0  " For a description for the format/conventions used in get_input,
               0  " see the description at the beginning of this file.
               0  " In order to use this routine, include transportp.macros BEFORE
               0  " get_inputs.mortran via the configuration file.
               0  " If the routine is called with ounit > 0, the transport parameter
               0  " settings will be printid on unit ounit.
               0  "
               0  " Version 0.1           Iwan Kawrakow, January 1999
               0  "
               0  "******************************************************************************
               0  "*******************************************************************************
               0  "
               0  "                         MC TRANSPORT PARAMETER
               0  "                         **********************
               0  "
               0  "  All input associated with selection of various transport parameter
               0  "  is not crucial for the execution as there are default values set.
               0  "  Therefore, if some of the input options in this section are
               0  "  missing/misspelled, this will be ignored and defualt parameter assumed
               0  "  As the transport parameter input routine uses get_inputs, a lot
               0  "  of error/warning messages may be produced on UNIT 15, though.
               0  "  If you don't have the intention of changing default settings,
               0  "  simply ignore the error messages.
               0  "
               0  "  The delimeters are
               0  "
               0  "               :start mc transport parameter:
               0  "               :stop mc transport parameter:
               0  "
               0  "  You can change this by including the statement
               0  "
               0  "  REPLACE {$THE_DELIMETER} WITH {'WHATEVER-YOU-LIKE-THE-DELIMETER-TO-BE'}
               0  "
               0  "  in your input file.
               0  "
               0  "  Currently, the following options are available (case does not matter and
               0  "             the internal variables are shown in [ ] brackets):
               0  "
               0  "       Global ECUT=     Global (in all regions) electron transport cut
               0  "                        off energy (in MeV). If this imput is missing,
               0  "                        AE(medium) will be used.
               0  "                        [ ECUT ]
               0  "       Global PCUT=     Global (in all regions) photon transport cut
               0  "                        off energy (in MeV). If this imput is missing,
               0  "                        AP(medium) will be used.
               0  "                        [ PCUT ]
               0  "       Global SMAX=     Global (in all regions) maximum step-size
               0  "                        restriction for electron transport (in cm).
               0  "                        If missing, no geometrical step-size restrictions
               0  "                        will be employed. Note that if you use the default
               0  "                        EGSnrc electron-step algorithm, no SMAX-restriction
               0  "                        is necessary. Option is useful for transport in low
               0  "                        density materials (air) when PRESTA behaviour is
               0  "                        turned on (see below)
               0  "                        [ SMAXIR ]
               0  "       ESTEPE=          Maximum fractional energy loss per step.
               0  "                        Note that this is a global option only, no
               0  "                        region-by-region setting is possible. If missing,
               0  "                        the defualt is 0.25 (25%).
               0  "                        [ ESTEPE ]
               0  "       XImax=           Maximum first elastic scattering moment per step.
               0  "                        Default is 0.5, NEVER use value greater than 1 as
               0  "                        this is beyond the range of MS data available.
               0  "                        [ XIMAX ]
               0  "       Boundary crossing algorithm=
               0  "                        There are two selections possible: EXACT, means
               0  "                        the algorithm will cross boundaries in a single
               0  "                        scattering (SS) mode, the distance from a boundary
               0  "                        at which the transition to SS mode is made is
               0  "                        determined by 'Skin depth for BCA' (see below).
               0  "                        The second option is PRESTA-I, if selected boundaries
               0  "                        will be crossed a la PRESTA, i.e. with lateral
               0  "                        correlations turned off and MS forced at boundaries.
               0  "                        Default is EXACT.
               0  "                        [ bca_algorithm, exact_bca ]
               0  "       Skin depth for BCA=
               0  "                        Determines the distance from a boundary (in elastic
               0  "                        MFP) at which the algorithm will go into single
               0  "                        scattering mode (if EXACT boundary crossing) or
               0  "                        swith off lateral correlations (if PRESTA-I boundary
               0  "                        crossing). Default value is 3 for EXACT or
               0  "                        exp(BLCMIN)/BLCMIN for PRESTA-I (see the PRESTA paper
               0  "                        for a definition of BLCMIN). Note that if you choose
               0  "                        EXACT boundary crossing and set Skin depth for BCA
               0  "                        to a very large number (e.g. 1e10), the entire
               0  "                        calculation will be in SS mode. If you choose
               0  "                        PRESTA-I boundary crossing and make Skin depth for BCA
               0  "                        large, you will get default EGS4 behavious (no PRESTA)
               0  "                        [ skindepth_for_bca ]
               0  "       Electron-step algorithm=
               0  "                        PRESTA-II (the default), the name is
               0  "                        used for historical reasons
               0  "                        or PRESTA-I
               0  "                        Determines the algorithm used to take into account
               0  "                        lateral and longitudinal correlations in a
               0  "                        condensed history step.
               0  "                        [ transport_algorithm ]
               0  "       Spin effects=    Off, On, default is On
               0  "                        Turns off/on spin effects for electron elastic
               0  "                        scattering. Spin On is ABSOLUTELY necessary for
               0  "                        good backscattering calculations. Will make a
               0  "                        difference even in `well conditioned' situations
               0  "                        (e.g. depth dose curves for RTP energy range
               0  "                        electrons).
               0  "                        [ spin_effects ]
               0  "       Brems angular sampling= Simple, KM, default is KM
               0  "                        If Simple, use only the leading term of the Koch-Motz
               0  "                        distribution to determine the emission angle of
               0  "                        bremsstrahlung photons. If On, complete
               0  "                        modified Koch-Motz 2BS is used (modifications
               0  "                        concern proper handling of kinematics at low energies,
               0  "                        makes 2BS almost the same as 2BN at low energies).
               0  "                        [ IBRDST ]
               0  "       Brems cross sections= BH, NIST, NRC default is BH
               0  "                        If BH is selected, the Bethe-Heitler bremsstrahlung
               0  "                        cross sections (Coulomb corrected above 50 MeV)
               0  "                        will be used. If NIST is selected, the NIST brems
               0  "                        cross section data base (which is the basis for
               0  "                        the ICRU radiative stopping powers) will be employed.
               0  "                        Differences are negligible for E > ,say, 10 MeV,
               0  "                        but significant in the keV energy range. If NRC is
               0  "                        selected, the NRC brems cross-section data base will
               0  "                        be used, which is a version of the NIST data base
               0  "                        with corrected electron-electron brems contributions
               0  "                        (corrections to the NIST data is typically only
               0  "                        significant for low values of the atomic number Z
               0  "                        and for k/T < 0.005).
               0  "       Triplet production= On or Off (default).  Turns on/off simulation
               0  "                        of triplet production.  If On, then Borsellino's
               0  "                        first Born approximation is used to sample triplet
               0  "                        events based on the triplet cross-section data.
               0  "                        [ itriplet ]
               0  "       Bound Compton scattering=  On, Off, Simple or norej (default)
               0  "                        If Off, Compton scattering will be treated with
               0  "                        Klein-Nishina, with On Compton scattering is
               0  "                        treated in the Impulse approximation.
               0  "                        With Simple, the impulse approximation incoherent
               0  "                        scattering function will be used (i.e., no Doppler
               0  "                        broadenning). With norej the actual total bound
               0  "                        Compton cross section is used and there are no
               0  "                        rejections at run time.
               0  "                        Make sure to turn on for low energy applications,
               0  "                        not necessary above, say, 1 MeV.
               0  "                        [ IBCMP ]
               0  "       Radiative Compton corrections= On or Off (default). If on, then
               0  "                        include radiative corrections for Compton scattering.
               0  "                        Equations are based on original Brown & Feynman
               0  "                        equations (Phys. Rev. 85, p 231--1952).  Requires
               0  "                        a change to the user codes Makefile to include
               0  "                        $(EGS_SOURCEDIR)rad_compton1.mortran in the
               0  "                        SOURCES (just before
               0  "                        $(EGS_SOURCEDIR)get_inputs.mortran).
               0  "                        [ radc_flag ]
               0  "       Electron Impact Ionization= Off (default), On, casnati, kolbenstvedt,
               0  "                        gryzinski, penelope.  If set to On or ik, then use
               0  "                        Kawrakow's theory to derive EII cross-sections.
               0  "                        If set to casnati, then
               0  "                        use the cross-sections of Casnati (contained in the
               0  "                        file ($HEN_HOUSE/data/eii_casnati.data).  Similar for
               0  "                        kolbenstvedt, gryzinski and penelope. This is only of
               0  "                        interest in kV X-ray calculations.
               0  "                        Case-sensitive except for Off, On or ik options.
               0  "                        [ eii_flag ]
               0  "       Pair angular sampling= Off, Simple, KM.
               0  "                        If off, pairs are set in motion at an angle m/E
               0  "                        relative to the photon direction (m is electron rest
               0  "                        energy, E the photon energy). Simple turns on
               0  "                        the leading term of the angular distribution
               0  "                        (this is sufficient for most applications),
               0  "                        KM (comes from Koch and Motz) turns on using 2BS
               0  "                        from the article by Koch and Motz.  Uniform
               0  "                        Default is Simple, make sure you always use
               0  "                        Simple or KM
               0  "                        [ IPRDST ]
               0  "       Pair cross sections= BH (default) or NRC.  If set to BH, then use
               0  "                        Bethe-Heitler pair production cross-sections.  If set
               0  "                        to NRC, then use NRC pair production cross-sections
               0  "                        (in file $HEN_HOUSE/data/pair_nrc1.data).  Only
               0  "                        of interest at low energies, where the NRC cross-
               0  "                        sections take into account the assymmetry in the
               0  "                        positron-electron energy distribution.
               0  "                        [ pair_nrc ]
               0  "       Photon cross sections= Photon cross-section data.  Current options are
               0  "                        si (Storm-Israel--the default), epdl (Evaluated Photon
               0  "                        Data Library), xcom and pegs4.  Allows the use of
               0  "                        photon cross-sections other than from the PEGS4 file
               0  "                        unless the pegs4 option is specified.
               0  "                        Note that the user can supply their own cross-section
               0  "                        data as well. The requirement is that the files
               0  "                        photon_xsections_photo.data,
               0  "                        photon_xsections_pair.data,
               0  "                        photon_xsections_triplet.data, and
               0  "                        photon_xsections_rayleigh.data exist in the
               0  "                        $HEN_HOUSE/data directory, where photon_xsections
               0  "                        is the name specified.
               0  "                        Hence this entry is case-sensitive.
               0  "                        [ photon_xsections ]
               0  "       Photon cross-sections output= Off (default) or On.  If On, then
               0  "                        a file $EGS_HOME/user_code/inputfile.xsections is
               0  "                        output containing photon cross-section data used.
               0  "                        [ xsec_out ]
               0  "       Compton cross sections= Bound Compton cross-section data.  User-
               0  "                        supplied bound Compton cross-sections in the file
               0  "                        $HEN_HOUSE/data/comp_xsections_compton.data, where
               0  "                        comp_xsections is the name supplied for this input.
               0  "                        This is only used if Bound Compton scattering= Simple
               0  "                        and is not available on a region-by-region basis
               0  "                        (see below).  The default file (ie in the absence
               0  "                        of any user-supplied data) is compton_sigma.data.
               0  "                        [ comp_xsections ]
               0  "       Rayleigh scattering= Off, On, custom
               0  "                        If On, turned on coherent (Rayleigh) scattering.
               0  "                        Default is Off. Should be turned on for low energy
               0  "                        applications. Not set to On by default for historical
               0  "                        reasons since a PEGS4 data set is not required anymore.
               0  "                        If custom, user must provide media names and form
               0  "                        factor files for each desired medium. For the rest
               0  "                        of the media, default atomic FF are used.
               0  "                        [ IRAYLR ]
               0  "       ff media names = A list of media names (must match media found in
               0  "                        PEGS4 data file) for which the user is going to
               0  "                        provide custom Rayleigh form factor data.
               0  "                        [ iray_ff_media($MXMED) ]
               0  "       ff file names = A list of names of files containing the Rayleigh
               0  "                       form factor data for the media specified by
               0  "                       the ff media names = input above.  Full directory
               0  "                       paths must be given for all files, and for each medium
               0  "                       specified, iray_ff_media(i), there must be a
               0  "                       corresponding file name, iray_ff_file(i).  For
               0  "                       example files, see the directory
               0  "                       $HEN_HOUSE/data/molecular_form_factors.
               0  "                       [ iray_ff_file($MXMED) ]
               0  "Ali:photonuc, 2 blocks of comments"
               0  "       Photonuclear attenuation= Off (default) or On
               0  "                        If On, models the photonuclear effect. Current
               0  "                        implementation is crude. Available on a
               0  "                        region-by-region basis (see below)
               0  "                        [ IPHOTONUCR ]
               0  "       Photonuclear cross sections= Total photonuclear cross sections. User-
               0  "                        supplied total photonuclear cross-sections in
               0  "                        $HEN_HOUSE/data/photonuc_xsections_photonuc.data,
               0  "                        where photonuc_xsections is the name supplied for
               0  "                        this input (case sensitive). In the absence of
               0  "                        any user-supplied data, or if photonuc_xsections
               0  "                        is set to 'default', the default file is
               0  "                        iaea_photonuc.data.
               0  "                        [ photonuc_xsections ]
               0  "       Photoelectron angular sampling= Off or On
               0  "                        If Off, photo-electrons get the direction of the
               0  "                        `mother' photon, with On, Sauter's furmula is
               0  "                        used (which is, striktly speaking, valid only for
               0  "                        K-shell photo-absorption).
               0  "                        If the user has a better approach, replace the macro
               0  "                            $SELECT-PHOTOELECTRON-DIRECTION;
               0  "                        The only application that
               0  "                        I encountered until now where this option made a
               0  "                        small difference was a big ion chamber (cavity size
               0  "                        comparable with electron range) with high-Z walls
               0  "                        in a low energy photon beam.
               0  "                        Default is On
               0  "                        [ IPHTER ]
               0  "       Atomic relaxations= Off, On
               0  "                        Default is On. The effect of using On is twofold:
               0  "                        - In photo-electric absorption events, the element
               0  "                          (if material is mixture) and the shell the photon
               0  "                          is interacting with are sampled from the appropriate
               0  "                          cross seections
               0  "                        - Shell vacancies created in photo-absorption events
               0  "                          are relaxed via emission of fluorescent X-Rays,
               0  "                          Auger and Koster-Cronig electrons.
               0  "                         Make sure to turn this option on for low energy
               0  "                         applications.
               0  "                         [ IEDGFL ]
               0  "
               0  "       Atomic relaxations, Rayleigh scattering,
               0  "       Photoelectron angular sampling and Bound Compton scattering
               0  "       and photonuclear effect(Ali:photonuc)
               0  "       can also be turned On/Off on a region-by-region
               0  "       basis. To do so, put e.g.
               0  "
               0  "       Atomic relaxations= On in Regions   or
               0  "       Atomic relaxations= Off in regions
               0  "
               0  "                         in your input file. Then use
               0  "
               0  "       Bound Compton start region=
               0  "       Bound Compton stop region=
               0  "                or
               0  "       Rayleigh start region=
               0  "       Rayleigh stop region=
               0  "                or
               0  "       Relaxations start region=
               0  "       Relaxations stop region=
               0  "                or
               0  "       PE sampling start region=
               0  "       PE sampling stop region=
               0  "                or                  Ali:photonuc
               0  "       Photonuclear start region=
               0  "       Photonuclear stop region=
               0  "
               0  "                         each followed by a lost of of one or more
               0  "                         start and stop regions separated by commas.
               0  "                         Example:
               0  "        Atomic relaxations= On in Regions
               0  "        Relaxations start region=  1, 40
               0  "        Relaxations stop region=  10, 99
               0  "                         will first turn off relaxations everywhere and
               0  "                         then turn on in regions 1-10 and 40-99.
               0  "                         Note that input is checked against min. and max.
               0  "                         region number and ignored if
               0  "                         start region < 1 or stop_region > $MXREG or
               0  "                         start region > stop region.
               0  "
               0  "                         ECUT, PCUT and SMAX can also be set on a
               0  "                         region-by-region basis. To do so, iclude
               0  "                         in your input file
               0  "
               0  "         Set XXXX=              f_value1, f_value2, ...
               0  "         Set XXXX start region= i_value1, i_value2, ...
               0  "         Set XXXX stop region=  j_value1, j_value2, ...
               0  "
               0  "                         where XXXX is ECUT, PCUT or SMAX ,
               0  "                         f_value1, f_value2,... are the desired values for XXXX
               0  "                         and i_value_i and j_value_i are the start and
               0  "                         stop regions.
               0  "
               0  "*******************************************************************************
               0
               0  implicit none;  "Hard coded to catch possible user replacements of the "
               0  "following common blocks"
               0
               0  character*80 line;
               0  character*512 toUpper;
               0
               0  $INTEGER ounit;
               0  $declare_max_medium;
               0
               0  $COMIN-GET-TRANSPORTP;
               0
               0  $INTEGER  ival,num_ecut,num_pcut,num_smax,num_incoh,num_radc,num_coh,num_relax,
               0  num_pe_ang,num_brems_ang,num_brems_cs,num_pair_cs,
               0  num_ffmed,num_ffiles,
               0  num_pair_ang,num_eii,num_eii_L,num_estepe,num_ximax,num_triplet,
               0  num_pxsec,num_pxsec_out, num_cxsec,
               0  num_photonuc, num_photonuc_xsec,"Ali:photonuc, 1 line"
               0  num_efield, num_bfield, num_emlmt,"EMH: EM fields"
               0  num_spin,num_bca,num_alg,num_skin,itmp,iitmp,i,j,k,istart,iend,
               0  egs_open_file,lnblnk1;
               0
               0  $LOGICAL  ecut_inregions,pcut_inregions,smax_inregions,
               0  incoh_inregions,coh_inregions,relax_inregions,
               0  pe_inregions,aux_inregions,photonuc_inregions;"Ali:photonuc"
               0
               0  character*15 output_strings(14);"Ali:photonuc, increased by 1"
               0  character*16 p_xsections;
               0  save         output_strings,line, p_xsections;
               0  save         ecut_inregions,pcut_inregions,smax_inregions,
               0  incoh_inregions,coh_inregions,relax_inregions,
               0  pe_inregions,aux_inregions,photonuc_inregions,
               0  num_photonuc;"Ali:photonuc"
               0
               0
               0  DO k=1,80 [ line(k:k) = '='; ]
               0  delimeter = $THE_DELIMETER;
               0  ival = 0;
               0
               0  ;
               0  /ecut_inregions,pcut_inregions,smax_inregions,
               0  incoh_inregions,coh_inregions,relax_inregions,
               0  pe_inregions,aux_inregions,
               0  "Ali:photonuc, 1 line"
               0  photonuc_inregions/ = .false.;
               0
               0  "open a .errors file exclusively for output from this subroutine"
               0  i_errors=15;
               0  i_errors=egs_open_file(i_errors,0,1,'.errors');
               0
               0  write(i_errors,*)
               0  ' If you are not trying to reset transport parameters, ';
               0  write(i_errors,*)
               0  ' ignore all the output until the message ';
               0  write(i_errors,*)
               0  ' ******************** end input transport parameter *********************** ';
               0  write(i_errors,*);
               0
               0  " ECUT "
               0  ival                = ival + 1;
               0  num_ecut            = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $GLOBAL_ELECTRON_CUTOFF;  "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 0;                        "Define the allowed range"
               0  value_max(ival)     = 1e15;
               0  default(ival)       = $GLOBAL-ECUT;
               0
               0  " PCUT "
               0  ival                = ival + 1;
               0  num_pcut            = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $GLOBAL_PHOTON_CUTOFF;    "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 0;                        "Define the allowed range"
               0  value_max(ival)     = 1e15;
               0  default(ival)       = $GLOBAL-PCUT;
               0
               0  " SMAX "
               0  ival                = ival + 1;
               0  num_smax            = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $GLOBAL_SMAX;             "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 0;                        "Define the allowed range"
               0  value_max(ival)     = 1e15;
               0  default(ival)       = $MAX-SMAX;
               0
               0  " Incoherent (Compton) scattering "
               0  ival                = ival + 1;
               0  num_incoh           = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $INCOHERENT_SCATTERING;   "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0  allowed_inputs(ival,2) = $ON_IN_REGIONS;
               0  allowed_inputs(ival,3) = $OFF_IN_REGIONS;
               0  allowed_inputs(ival,4) = 'Simple';
               0  allowed_inputs(ival,5) = 'norej';
               0
               0  " Radiative corrections for Compton scattering "
               0  ival                = ival + 1;
               0  num_radc            = ival;
               0  values_sought(ival) = $RADC_COMPTON;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 3;
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0
               0  " Coherent (Rayleigh) scattering "
               0  ival                = ival + 1;
               0  num_coh             = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $COHERENT_SCATTERING;     "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0  allowed_inputs(ival,2) = $ON_IN_REGIONS;
               0  allowed_inputs(ival,3) = $OFF_IN_REGIONS;
               0  allowed_inputs(ival,4) = 'custom';
               0
               0  " Atomic Relaxations "
               0  ival                = ival + 1;
               0  num_relax           = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $ATOMIC_RELAXATIONS;      "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0  allowed_inputs(ival,2) = $ON_IN_REGIONS;
               0  allowed_inputs(ival,3) = $OFF_IN_REGIONS;
               0  allowed_inputs(ival,4) = 'eadl';
               0  allowed_inputs(ival,5) = 'simple';
               0
               0  " Photoelectron angular sampling "
               0  ival                = ival + 1;
               0  num_pe_ang          = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $PE_ANGULAR_SAMPLING;     "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0  allowed_inputs(ival,2) = $ON_IN_REGIONS;
               0  allowed_inputs(ival,3) = $OFF_IN_REGIONS;
               0
               0  " Bremsstrahlung angular sampling "
               0  ival                = ival + 1;
               0  num_brems_ang       = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $BREMS_ANGULAR_SAMPLING;  "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Simple';
               0  allowed_inputs(ival,1) = 'KM';   "means Koch-Motz, Simple turns on just the"
               0  "leading term of the distribution which is"
               0  "probably sufficiently accurate for most"
               0  "applications"
               0
               0  " Bremsstrahlung cross sections "
               0  ival                = ival + 1;
               0  num_brems_cs        = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $BREMS_CROSS_SECTIONS;    "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'BH';
               0  allowed_inputs(ival,1) = 'NIST';                "Only global on/off available"
               0  allowed_inputs(ival,2) = 'NRC';                 "Only global on/off available"
               0
               0
               0  " Pair angular sampling "
               0  ival                = ival + 1;
               0  num_pair_ang        = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $PAIR_ANGULAR_SAMPLING;   "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'Simple';             "Only global on/off available"
               0  allowed_inputs(ival,2) = 'KM';   "means Koch-Motz, Simple turns on just the"
               0  "leading term of the distribution which is"
               0  "probably sufficiently accurate for most"
               0  "applications"
               0  allowed_inputs(ival,3) = 'Uniform';
               0  allowed_inputs(ival,4) = 'Blend';
               0
               0  " Pair cross sections "
               0  ival                = ival + 1;
               0  num_pair_cs         = ival;
               0  values_sought(ival) = $PAIR_CROSS_SECTIONS;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 3;
               0  allowed_inputs(ival,0) = 'BH';
               0  allowed_inputs(ival,1) = 'NRC';
               0
               0  " Triplet production "
               0  ival                = ival + 1;
               0  num_triplet         = ival;
               0  values_sought(ival) = $TRIPLET_PRODUCTION;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 3;
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0
               0  " Spin effects          "
               0  ival                = ival + 1;
               0  num_spin            = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $SPIN_EFFECTS;            "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';                 "Only global on/off available"
               0
               0  " Electron impact ionization "
               0  ival                = ival + 1;
               0  num_eii             = ival;
               0  values_sought(ival) = $ELECTRON_IMPACT_IONI;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 2;
               0  "type(ival)          = 3;"
               0  "allowed_inputs(ival,0) = 'Off';"
               0  "allowed_inputs(ival,1) = 'On';"
               0  "allowed_inputs(ival,2) = 'casnati';"
               0  "allowed_inputs(ival,3) = 'kolbenstvedt';"
               0  "allowed_inputs(ival,4) = 'gryzinski';"
               0
               0  " L-shell EII xsection scaling"
               0  ival                = ival + 1;
               0  num_eii_L= ival;                                "Set the variable pointer"
               0  values_sought(ival) = $SCALE_L_EII_XSECTIONS;   "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 0.0;                      "Define the allowed range"
               0  value_max(ival)     = 1.0e+9;
               0  default(ival)       = 1.0;
               0
               0  " ESTEPE "
               0  ival                = ival + 1;
               0  num_estepe          = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $MAXIMUM_ESTEPE;          "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 1e-5;                     "Define the allowed range"
               0  value_max(ival)     = 1;
               0  default(ival)       = $MAX-ELOSS;
               0
               0  " XIMAX "
               0  ival                = ival + 1;
               0  num_ximax           = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $MAXIMUM_XIMAX;           "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 0;                        "Define the allowed range"
               0  value_max(ival)     = 1;
               0  default(ival)       = $EXACT-BCA-XIMAX;
               0
               0  " BCA "
               0  ival                = ival + 1;
               0  num_bca             = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $BOUNDARY_ALGORITHM;      "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'Exact';
               0  allowed_inputs(ival,1) = 'PRESTA-I';
               0
               0  " Skindepth "
               0  ival                = ival + 1;
               0  num_skin            = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $SKIN_FOR_BCA;            "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = -1;                       "Define the allowed range"
               0  value_max(ival)     = 1e15;
               0  default(ival)       = $SKIN-DEPTH-FOR-BCA;
               0
               0  " Electron-step algorithm "
               0  ival                = ival + 1;
               0  num_alg             = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $ELECTRON_STEP_ALG;       "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 3;                        "An `allowed' input"
               0  allowed_inputs(ival,0) = 'PRESTA-II'; "Better EGSnrc ???"
               0  allowed_inputs(ival,1) = 'PRESTA-I';
               0
               0  " Photon cross sections "
               0  ival                = ival + 1;
               0  num_pxsec           = ival;
               0  values_sought(ival) = $PHOTON_XSECTIONS;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 2;
               0
               0  " Photon cross sections output "
               0  ival                = ival + 1;
               0  num_pxsec_out       = ival;
               0  values_sought(ival) = $PHOTON_XSECTIONS_OUT;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 3;
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0
               0  " Compton cross sections "
               0  ival                = ival + 1;
               0  num_cxsec           = ival;
               0  values_sought(ival) = $COMPTON_XSECTIONS;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 2;
               0
               0  " E-Field "
               0  ival                = ival + 1;
               0  num_efield          = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $E_FIELD;                 "The code word"
               0  nvalue(ival)        = 3;                        "3 inputs"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = -1e15;                    "Define the allowed range"
               0  value_max(ival)     =  1e15;
               0  default(ival)       =  0;
               0
               0  " B-Field "
               0  ival                = ival + 1;
               0  num_bfield          = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $B_FIELD;                 "The code word"
               0  nvalue(ival)        = 3;                        "3 inputs"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = -1e10;                    "Define the allowed range"
               0  value_max(ival)     =  1e10;
               0  default(ival)       =  0;
               0
               0  " EM-field step and eloss restriction "
               0  ival                = ival + 1;
               0  num_emlmt           = ival;                     "Set the variable pointer"
               0  values_sought(ival) = $EM_LMT;                 "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;                        "A real number"
               0  value_min(ival)     = 0.0;                      "Define the allowed range"
               0  value_max(ival)     = 1.0;
               0  default(ival)       = 0.02;
               0
               0  "Ali:photonuc, 2 blocks"
               0  " Photonuclear "
               0  ival                = ival + 1;
               0  num_photonuc        = ival;           "set the variable pointer"
               0  values_sought(ival) = $PHOTO_NUCLEAR; "the code word"
               0  nvalue(ival)        = 1;              "1 input"
               0  type(ival)          = 3;              "an `allowed' input"
               0  allowed_inputs(ival,0) = 'Off';
               0  allowed_inputs(ival,1) = 'On';
               0  allowed_inputs(ival,2) = $ON_IN_REGIONS;
               0  allowed_inputs(ival,3) = $OFF_IN_REGIONS;
               0
               0  " Photonuclear cross sections "
               0  ival                = ival + 1;
               0  num_photonuc_xsec   = ival;
               0  values_sought(ival) = $PHOTONUC_XSECTIONS;
               0  nvalue(ival)        = 1;
               0  type(ival)          = 2;
               0
               0  "Ali:photonuc, 1 line"
               0  Nmin = num_ecut; Nmax = num_photonuc_xsec;
               0  "Nmin = num_ecut; Nmax = num_cxsec;"
               0
               0  CALL GET_INPUT;
               0
               0  IF( error_flags(num_ecut) = 0 ) [
               1      DO j=1,$MXREG [ ecut(j) = value(num_ecut,1); ]
               1      ]
               0  IF( error_flags(num_pcut) = 0 ) [
               1      DO j=1,$MXREG [ pcut(j) = value(num_pcut,1); ]
               1      ]
               0  IF( error_flags(num_smax) = 0 ) [
               1      DO j=1,$MXREG [ smaxir(j) = value(num_smax,1); ]
               1      ]
               0  IF( error_flags(num_brems_ang) = 0 ) [
               1      ibrdst = value(num_brems_ang,1);
               1      ]
               0  IF( error_flags(num_brems_cs) = 0 ) [
               1      ibr_nist = value(num_brems_cs,1);
               1      ]
               0  IF( error_flags(num_radc) = 0 ) [
               1      radc_flag = value(num_radc,1);
               1      ]
               0  IF( error_flags(num_pair_ang) = 0 ) [
               1      iprdst = value(num_pair_ang,1);
               1      ]
               0  IF( error_flags(num_pair_cs) = 0 ) [
               1      pair_nrc = value(num_pair_cs,1);
               1      ]
               0  IF( error_flags(num_triplet) = 0 ) [
               1      itriplet = value(num_triplet,1);
               1      ]
               0  IF( error_flags(num_eii_L) = 0 ) [ eii_L_factor = value(num_eii_L,1); ]
               0  IF( error_flags(num_estepe) = 0 ) [ estepe = value(num_estepe,1); ]
               0  IF( error_flags(num_ximax) = 0 ) [ ximax = value(num_ximax,1); ]
               0  IF( error_flags(num_bca) = 0 ) [
               1      bca_algorithm = value(num_bca,1);
               1      IF( bca_algorithm = 0 ) [ exact_bca = .true.; ]
               1      ]
               0  IF( error_flags(num_alg) = 0 ) [ transport_algorithm = value(num_alg,1); ]
               0  IF( error_flags(num_skin) = 0 ) [ skindepth_for_bca = value(num_skin,1); ]
               0  IF( error_flags(num_spin) = 0 ) [
               1      itmp = value(num_spin,1);
               1      IF( itmp = 1 ) [ spin_effects = .true.; ]
               1      ELSE           [ spin_effects = .false.; ]
               1      ]
               0
               0
               0
               0
               0
               0  IF( error_flags(num_eii) = 0 ) [
               1      eii_xfile = char_value(num_eii,1);eii_flag=1;
               1      IF (toUpper($cstring(eii_xfile)).eq.'ON' |
               1      toUpper($cstring(eii_xfile)).eq.'IK' )[
               2          eii_xfile = 'ik';
               2          $egs_info(*,'==> Using default EII data compilation ',
               2          $cstring(eii_xfile));
               2          ]
               1      ELSEIF (toUpper(eii_xfile(:lnblnk1(eii_xfile))).eq.'OFF')[
               2          eii_xfile='Off';eii_flag=0;
               2          ]
               1      ELSE["Using non-default EII data compilation"
               2          $egs_warning(*,'==> Using non-default EII data compilation ',
               2          $cstring(eii_xfile));
               2          ]
               1      ]
               0
               0
               0
               0
               0
               0  IF( error_flags(num_pxsec) = 0 ) [
               1      p_xsections = char_value(num_pxsec,1);
               1      IF ( toUpper( $cstring(p_xsections) ) = 'MCDF-XCOM' )[
               2          mcdf_pe_xsections = .true.; photon_xsections = 'xcom';
               2          ]
               1      ELSEIF ( toUpper( $cstring(p_xsections) ) = 'MCDF-EPDL' )[
               2          mcdf_pe_xsections = .true.; photon_xsections = 'epdl';
               2          ]
               1      ELSE[
               2          mcdf_pe_xsections = .false.;
               2          ]
               1      ]
               0
               0  IF( error_flags(num_pxsec_out) = 0 ) [
               1      xsec_out = value(num_pxsec_out,1);
               1      ]
               0  IF( error_flags(num_cxsec) = 0 ) [
               1      comp_xsections = char_value(num_cxsec,1);
               1      ]
               0  "Ali:photonuc, 3 lines"
               0  IF( error_flags(num_photonuc_xsec) = 0 ) [
               1      photonuc_xsections = char_value(num_photonuc_xsec,1);
               1      ]
               0  IF( error_flags(num_efield) = 0 ) [
               1      ExIN = value(num_efield,1);
               1      EyIN = value(num_efield,2);
               1      EzIN = value(num_efield,3);
               1      IF( error_flags(num_emlmt) = 0 )[
               2          EMLMTIN=value(num_emlmt,1);
               2          ]
               1      ]
               0  " Initially set to input values, could change with regions"
               0  " by converting it to an array over all regions. This is  "
               0  " currently implemented only for the C++ applications     "
               0  IF( error_flags(num_bfield) = 0 ) [
               1      BxIN = value(num_bfield,1);
               1      ByIN = value(num_bfield,2);
               1      BzIN = value(num_bfield,3);
               1      Bx=BxIN;By=ByIN;Bz=BzIN;
               1      Bx_new=BxIN;By_new=ByIN;Bz_new=BzIN;
               1      IF( error_flags(num_emlmt) = 0 )[
               2          EMLMTIN=value(num_emlmt,1);
               2          ]
               1      ]
               0
               0
               0
               0  IF( error_flags(num_coh) = 0 ) [
               1      IF(value(num_coh,1) = 4)[
               2          write(*,'(/a/)') ' ===> custom ff requested!';
               2          ival                = ival + 1;
               2          num_ffmed           = ival;
               2          values_sought(ival) = 'ff media names';
               2          type(ival)          = 2;  "i.e.  character input"
               2          nvalue(ival)        = 0;
               2          ival                = ival + 1;
               2          num_ffiles          = ival;
               2          values_sought(ival) = 'ff file names';
               2          type(ival)          = 2;  "i.e.  character input"
               2          nvalue(ival)        = 0;
               2          Nmin = num_ffmed; Nmax = num_ffiles;
               2          CALL GET_INPUT;
               2          IF( error_flags(num_ffmed) > 0 ) [
               3              $egs_fatal('(a/,a,I3)','Error reading custom ff! Terminating ...',
               3              ' error_flag = ', error_flags(num_ffmed));
               3              ]
               2          IF( error_flags(num_ffiles) > 0 ) [
               3              $egs_fatal('(a/,a,I3)','Error reading ff file names! Terminating ...',
               3              ' error_flag = ', error_flags(num_ffiles));
               3              ]
               2          IF (nvalue(num_ffmed)>$MXMED)[
               3              $egs_fatal('(a,a,i3,a)',
               3              '***** Number of media with custom ff larger ',
               3              'than maximum number of media $MXMED = ',$MXMED,
               3              ' increase $MXMED and try again!!!');
               3              ]
               2          DO i=1,nvalue(num_ffmed) [
               3              iray_ff_media(i) = char_value(num_ffmed,i);
               3              iray_ff_file(i)  = char_value(num_ffiles,i);
               3              ]
               2          value(num_coh,1) = 1; "reset to 1 since custom info in iray_ff_files"
               2          ]
               1      write(*,'(/)');
               1      ]
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  $TURN-ON/OFF-IN-REGIONS(num_incoh,
               0  'Bound Compton start region',
               0  'Bound Compton stop region',
               0  ibcmp); incoh_inregions = aux_inregions;
               0  $TURN-ON/OFF-IN-REGIONS(num_coh,
               0  'Rayleigh start region',
               0  'Rayleigh stop region',
               0  iraylr); coh_inregions = aux_inregions;
               0  $TURN-ON/OFF-IN-REGIONS(num_relax,
               0  'Relaxations start region',
               0  'Relaxations stop region',
               0  iedgfl); relax_inregions = aux_inregions;
               0  $TURN-ON/OFF-IN-REGIONS(num_pe_ang,
               0  'PE sampling start region',
               0  'PE sampling stop region',
               0  iphter); pe_inregions = aux_inregions;
               0  "Ali:photonuc, 1 block"
               0  $TURN-ON/OFF-IN-REGIONS(num_photonuc,
               0  'Photonuclear start region',
               0  'Photonuclear stop region',
               0  iphotonucr); photonuc_inregions = aux_inregions;
               0  $SET ecut IN REGIONS(num_ecut,0.,1e15,0.,'Set ECUT','Set ECUT start region',
               0  'Set ECUT stop region');
               0  ecut_inregions = aux_inregions;
               0
               0  $SET pcut IN REGIONS(num_pcut,0.,1e15,0.,'Set PCUT','Set PCUT start region',
               0  'Set PCUT stop region');
               0  pcut_inregions = aux_inregions;
               0
               0  $SET smaxir IN REGIONS(num_smax,0.,1e15,0.,'Set SMAX','Set SMAX start region',
               0  'Set SMAX stop region');
               0  smax_inregions = aux_inregions;
               0
               0  write(i_errors,*);
               0  write(i_errors,*)
               0  ' ******************** end input transport parameter *********************** ';
               0  write(i_errors,*);
               0
               0  "Check if EADL relaxation requested. Note that original relaxation"
               0  "algorithm using <M> and <N> is only turned ON for all regions."
               0  "Moved past the $TURN-ON/OFF-IN-REGIONS statement to catch the"
               0  "default case."
               0  IF(value(num_relax,1) > 0 & value(num_relax,1) < 5)[
               1      eadl_relax = .true.;
               1      "Default relaxation is EADL"
               1      IF (value(num_relax,1) = 1)[value(num_relax,1)=4;]
               1      ]
               0  ELSE [
               1      IF (mcdf_pe_xsections & value(num_relax,1) = 5)[
               2          eadl_relax = .true.; value(num_relax,1)=4;
               2          $egs_warning('(a/,a/,a/)',
               2          '    Simplified atomic relaxation not allowed',
               2          '    with shellwise PE cross sections. Resetting',
               2          '    to detailed EADL atomic relaxation!!!');
               2          ]
               1      ELSE [
               2          eadl_relax = .false.;
               2          ]
               1      ]
               0
               0  " we put the information stored in allowed_inputs into "
               0  " output_strings just in case the user over-rides it "
               0  " before printing out the settings "
               0
               0  output_strings(1) = allowed_inputs(num_pair_ang,iprdst);
               0  itmp = value(num_incoh,1);
               0  output_strings(2) = allowed_inputs(num_incoh,itmp);
               0  $RADC_WARNING;
               0  output_strings(12) = allowed_inputs(num_radc,radc_flag);
               0  itmp = value(num_coh,1);
               0  output_strings(3) = allowed_inputs(num_coh,itmp);
               0  itmp = value(num_relax,1);
               0  output_strings(4) = allowed_inputs(num_relax,itmp);
               0  itmp = value(num_pe_ang,1);
               0  output_strings(5) = allowed_inputs(num_pe_ang,itmp);
               0  output_strings(6) = allowed_inputs(num_brems_ang,ibrdst);
               0  output_strings(7) = allowed_inputs(num_bca,bca_algorithm);
               0  output_strings(8) = allowed_inputs(num_alg,transport_algorithm);
               0  output_strings(9) = allowed_inputs(num_brems_cs,ibr_nist);
               0  output_strings(10) = allowed_inputs(num_pair_cs,pair_nrc);
               0  output_strings(11) = allowed_inputs(num_triplet,itriplet);
               0  "output_strings(13) = allowed_inputs(num_eii,eii_flag);"
               0  "Ali:photonuc, 2 lines"
               0  itmp = value(num_photonuc,1);
               0  output_strings(14) = allowed_inputs(num_photonuc,itmp);
               0
               0  entry show_transport_parameter(ounit);
               0
               0  IF ( ounit <= 0 ) return;
               0
               0  write(ounit,*);
               0  write(ounit,'(a)') line;
               0  write(ounit,*);
               0  write(ounit,'(a,/)')
               0  '                   Electron/Photon transport parameter';
               0  write(ounit,'(a,/)') line;
               0
               0
               0  write(ounit,'(a,38x,a)') ' Photon cross sections',
               0  $cstring(p_xsections);
               0  write(ounit,'(a,37x,a)') ' Compton cross sections', $cstring(comp_xsections);
               0
               0  write(ounit,'(a,$)') ' Photon transport cutoff(MeV)';
               0  IF( pcut_inregions ) [ write(ounit,'(32x,a)') 'Set in regions'; ]
               0  ELSE [
               1      IF( pcut(1) > 1e-4 ) [ write(ounit,'(32x,g14.4)') pcut(1); ]
               1      ELSE [ write(ounit,'(32x,a)') 'AP(medium)'; ]
               1      ]
               0  write(ounit,'(a,39x,a3)')  ' Pair angular sampling',output_strings(1);
               0  write(ounit,'(a,41x,a3)')  ' Pair cross sections',output_strings(10);
               0  write(ounit,'(a,42x,a3)')  ' Triplet production',output_strings(11);
               0  write(ounit,'(a,36x,a14)') ' Bound Compton scattering',output_strings(2);
               0  write(ounit,'(a,31x,a14)') ' Radiative Compton corrections',output_strings(12);
               0  write(ounit,'(a,41x,a14)') ' Rayleigh scattering',output_strings(3);
               0  write(ounit,'(a,42x,a14)') ' Atomic relaxations',output_strings(4);
               0  write(ounit,'(a,30x,a14)') ' Photoelectron angular sampling',output_strings(5);
               0  "Ali:photonuc, 3 lines. EMH added IF statement"
               0  IF ( value(num_photonuc,1) > 0 )[
               1      write(ounit,'(a,36x,a14)') ' Photonuclear attenuation',output_strings(14);
               1      write(ounit,'(a,33x,a)') ' Photonuclear cross sections',
               1      $cstring(photonuc_xsections);
               1      ]
               0
               0  write(ounit,*);
               0
               0  write(ounit,'(a,$)') ' Electron transport cutoff(MeV)';
               0  IF( ecut_inregions ) [ write(ounit,'(30x,a)') 'Set in regions'; ]
               0  ELSE [
               1      IF( ecut(1) > 1e-4 ) [ write(ounit,'(30x,f7.4)') ecut(1); ]
               1      ELSE [ write(ounit,'(30x,a)') 'AE(medium)'; ]
               1      ]
               0  write(ounit,'(a,30x,a4)') ' Bremsstrahlung cross sections',output_strings(9);
               0  write(ounit,'(a,29x,a3)') ' Bremsstrahlung angular sampling',output_strings(6);
               0  IF( spin_effects ) [ write(ounit,'(a,48x,a)') ' Spin effects','On'; ]
               0  ELSE [ write(ounit,'(a,48x,a)') ' Spin effects','Off'; ]
               0  write(ounit,'(a,34x,a)') ' Electron Impact Ionization',$cstring(eii_xfile);
               0  IF (eii_L_factor ~= 1.0) [
               1      write(ounit,'(a,25x,f6.4)')
               1      ' L-shell EII xsections scaling factor',eii_L_factor;
               1      ]
               0  write(ounit,'(a,$)') ' Maxium electron step in cm (SMAX)';
               0  IF( smax_inregions ) [ write(ounit,'(27x,a)') 'Set in regions'; ]
               0  ELSE [
               1      IF( smaxir(1) > 1e-4 ) [ write(ounit,'(27x,g14.4)') smaxir(1); ]
               1      ELSE [ write(ounit,'(27x,a)') 'Restriction is off'; ]
               1      ]
               0  write(ounit,'(a,16x,f6.4)')
               0  ' Maximum fractional energy loss/step (ESTEPE)',estepe;
               0  write(ounit,'(a,21x,f6.4)')
               0  ' Maximum 1st elastic moment/step (XIMAX)',ximax;
               0  write(ounit,'(a,33x,a10)')
               0  ' Boundary crossing algorithm',output_strings(7);
               0  write(ounit,'(a,22x,g9.4)')
               0  ' Skin-depth for boundary crossing (MFP)',skindepth_for_bca;
               0  write(ounit,'(a,37x,a10)')
               0  ' Electron-step algorithm',output_strings(8);
               0  IF( ExIN~=0 | EyIN~=0 | EzIN~=0 )[
               1      write(ounit,'(a,38x,3f10.2)') ' Electric Field [V/cm]',
               1      ExIN,EyIN,EzIN;
               1      ]
               0  IF( Bx~=0 | By~=0 | Bz~=0 )[
               1      write(ounit,'(a,41x,3f10.2)') ' Magnetic Field [T]',
               1      Bx,By,Bz;
               1      ]
               0  IF( ExIN~=0 | EyIN~=0 | EzIN~=0 |
               0  Bx~=0 | By~=0 | Bz~=0 )[
               1      write(ounit,'(a,50x,f10.2)') ' EM ESTEPE',EMLMTIN;
               1      ]
               0  write(ounit,*);
               0  write(ounit,'(a)') line;
               0  write(ounit,*);
               0
               0  return;
               0  end;
               0  ;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  subroutine set_elastic_parameter;
               0
               0  implicit none;
               0  $INTEGER ounit;
               0  $declare_max_medium;
               0  ;COMIN/GetInput,ELECIN,MEDIA,EGS-IO/;
               0  $INTEGER imed,ival,lnblnk1,nchanged;
               0  character*24 medname;
               0
               0  ounit = i_log;
               0  ounit = i_log;
               0  delimeter = $THE_DELIMETER;
               0  call get_input_set_error_level(0);
               0  ival = 0;
               0  DO imed=1,nmed [
               1      call egs_get_medium_name(imed,medname);
               1      ival                = ival + 1;
               1      values_sought(ival) = 'scale elastic scattering in '//
               1      medname(:lnblnk1(medname));
               1      nvalue(ival)        = 1;
               1      type(ival)          = 1;
               1      value_min(ival)     = 1e-3;
               1      value_max(ival)     = 1e3;
               1      default(ival)       = 1;
               1      ]
               0  Nmin = 1; Nmax = nmed;
               0  CALL GET_INPUT;
               0  nchanged = 0;
               0  DO imed=1,nmed [
               1      IF( error_flags(imed) = 0 ) nchanged = nchanged + 1;
               1      ]
               0  IF( nchanged > 0 ) [
               1      write(ounit,'(//a)')
               1      '================ Elastic scattering scaled as follows ==================';
               1      DO imed=1,nmed [
               2          IF( error_flags(imed) = 0 ) [
               3              call egs_get_medium_name(imed,medname);
               3              xcc(imed)  = xcc(imed)*value(imed,1);
               3              blcc(imed) = blcc(imed)*value(imed,1);
               3              write(ounit,'(a,t30,f10.6)') medname(:lnblnk1(medname)),
               3              value(imed,1);
               3              ]
               2          ]
               1      write(ounit,'(a//)')
               1      '========================================================================';
               1      ]
               0  return; end;
               0  ;
               0
               0  "==========================end of get_inputs.mortran=================="
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc media input functions                                               "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Blake Walters, 2013                                       "
               0  "                                                                             "
               0  "  Contributors:    Reid Townson                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  SUBROUTINE GET_INPUT_PLUS(UNITNUM,DELIM_START,DELIM_END);
               0  "                                                                           "
               0  " A version of GET_INPUT that allows the user to specify a UNITNUM          "
               0  " other than the .egsinp file and different start and end delimiters.       "
               0  " Note that delimiters are interpreted literally.                           "
               0  " If NONE is supplied as DELIM_END, then EOF is taken as the stop           "
               0  " delimiter.                                                                "
               0  "                                                                           "
               0  "---------------------------------------------------------------------------"
               0  ;IMPLICIT NONE;
               0
               0  COMIN/GetInput,EGS-IO/;
               0
               0  "***************************************************************************"
               0  "*                   Variables used by the subroutine                      *"
               0  "***************************************************************************"
               0  CHARACTER*$STRING256 TEXT;      "Used to read in each line of the input file   "
               0  CHARACTER*$STRING256 KEEPTEXT;  "Used to keep an old line of TEXT              "
               0  CHARACTER*$STRING256 ORIGTEXT;  "The text without conversion to upper case     "
               0  CHARACTER*$STRING80  TEXTPIECE; "Used to read a piece of TEXT                  "
               0  CHARACTER*$STRING40  DELIM_START;"Start of the delimeter                       "
               0  CHARACTER*$STRING40  DELIM_END;  "End of the delimeter                         "
               0  CHARACTER*$STRING40  ENDSTRING;  "string at which to terminate search          "
               0  CHARACTER*$STRING32  VNAME;      "The name of the variable being extracted.    "
               0  CHARACTER*$STRING32  VNAME1;     "The name of the variable being extracted.    "
               0  $INTEGER       CURSOR;          "Used to read one of the TEXT letters          "
               0  $INTEGER       IINDEX;          "Integer index for clipping string excess.     "
               0  $INTEGER       iVNAME;          "Length of variable name string.               "
               0  $INTEGER       IVAL;            "Value number of the value_sought              "
               0  $INTEGER       UNITNUM;         "Unit number of the input file                 "
               0  $INTEGER       ERR;             "Unit number of the error file                 "
               0  $INTEGER       I,J,K,CHECK;     "Counters and checkers                         "
               0  $INTEGER       LINE;            "Counts the eumber of lines                    "
               0  $INTEGER       INT_VALUE;       "For printing integers                         "
               0  $INTEGER       INT_VALUE_MIN;   "For printing integers                         "
               0  $INTEGER       INT_VALUE_MAX;   "For printing integers                         "
               0  $LOGICAL       ALLOWED;         "For evaluating an allowed_input               "
               0  $LOGICAL       START_FOUND;     "Start of delimeter switch                     "
               0  $INTEGER       ifound,length,lll,Kconvert;
               0  $INTEGER       lnblnk1;"in house lnblnk function becuase not all compilers     "
               0  "support this"
               0  logical IDEBUG,end_string;
               0  character*1 blank;
               0  $INTEGER    error_level;
               0  $INTEGER    the_level;
               0  data blank/' '/;
               0  data        error_level/1/;
               0  save        error_level;
               0  "---------------------------------------------------------------------------"
               0
               0  "Macro changing text string to upper case"
               0  "REPLACE {$CONVERT-STRING-TO-UPPER-CASE(#);} WITH"
               0  REPLACE {$CONVERT # TO UPPER CASE;} WITH
               0  {;
            {  0  DO Kconvert=1, lnblnk1({P1}) [
            {  0  CURSOR=ICHAR({P1}(Kconvert:Kconvert));
            {  0  IF ((CURSOR.GE.97).AND.(CURSOR.LE.122)) [
            {  0  CURSOR=CURSOR-32;
            {  0  {P1}(Kconvert:Kconvert)=CHAR(CURSOR);
            {  0  ]
            {  0  ]
            {  0  }
               0  ;
               0
               0  "Macro to skip leading blanks "
               0  REPLACE {$SKIP LEADING BLANKS IN #;} WITH
               0  {;
            {  0  length = len({P1});
            {  0  WHILE ( index({P1},blank) = 1 ) [
            {  0  IF( length >= 2 ) [ {P1}={P1}(2:); ] ELSE [ EXIT; ]
            {  0  length = length - 1;
            {  0  ]
            {  0  }
               0
               0  "Macro that removes everything after comments "
               0  REPLACE {$REMOVE EVERYTHING AFTER # IN #;} WITH
               0  {
            {  0  ifound = INDEX({P2},{P1});
            {  0  IF( ifound > 1 ) [ {P2} = {P2}(1:ifound-1); ]
            {  0  ELSE [ IF( ifound = 1 ) [ {P2} = blank; ] ]
            {  0  }
               0
               0  REPLACE {$STRING-OUTPUT(#);} WITH
               0  {;
            {  0  length = lnblnk1({P1});
            {  0  IF( length > 0 ) [
            {  0  DO lll=1,length [ write(i_log,'(a1,$)') {P1}(lll:lll); ]
            {  0  write(i_log,*); "For a new line"
            {  0  ]
            {  0  }
               0
               0  IDEBUG = .false.;   "set to .true. for debug outputs"
               0  ERROR_FLAG = 0;
               0  IF(IDEBUG) [OUTPUT NMIN,NMAX, $NMAX;(' Entering get_inputs seeking values',
               1      I5,' to', I5, '  with a max allowed of',I5);
               1      ]
               0  IF (NMAX < NMIN | NMAX > $NMAX)[
               1      OUTPUT NMAX, NMIN, $NMAX;
               1      (//' Error entering get_inputs: Asked for values from',I5,' to',I5,
               1      '    with a max of',I5//' This implies a bug in the calling routine'/
               1      ' Fix it up and try again.  Stopping now.');
               1      STOP;
               1      ]
               0  ERR=i_errors;    "inputfile.errors"
               0  DELIM_START=DELIM_START(:lnblnk1(DELIM_START));
               0  DELIM_END=DELIM_END(:lnblnk1(DELIM_END));
               0  $SKIP LEADING BLANKS IN DELIM_START;
               0  $SKIP LEADING BLANKS IN DELIM_END;
               0  $CONVERT DELIM_START TO UPPER CASE; "This allows use of lower case letters"
               0  $CONVERT DELIM_END TO UPPER CASE; "This allows use of lower case letters"
               0  $SKIP LEADING BLANKS IN ENDSTRING;
               0  IF(ENDSTRING=blank)[
               1      end_string=.false.;
               1      ]
               0  ELSE[
               1      $CONVERT ENDSTRING TO UPPER CASE;
               1      end_string=.false.;
               1      ]
               0
               0  IF(IDEBUG) [OUTPUT DELIM_START,DELIM_END;(' start and stop delimeters are:'/
               1      A/A/);
               1      ]
               0  "===================check that each value_sought is there===================="
               0
               0  DO I = NMIN, NMAX  [ "for each value_sought"
               1      REWIND (UNITNUM);
               1      LINE=0;             "reset line counter"
               1      CHECK=0;            "reset error checker"
               1      ERROR_FLAGS(I)=0;
               1      " Set to default for the case the input is not found "
               1      IF(TYPE(I) = 0 | TYPE(I) = 1) [ VALUE(I,1) = DEFAULT(I); ]
               1      IF(TYPE(I) = 3) [ VALUE(I,1) = 0; ]
               1      VNAME=VALUES_SOUGHT(I);
               1      iVNAME=lnblnk1(VNAME);
               1      IF( ivname < 1 )
               1      [
               2          IF( error_level > 0 ) [
               3              write(ERR,*) ' ======================= Warning ===================== ';
               3              write(ERR,*) '    Empty VALUES_SOUGHT passt to Get_Inputs()!         ';
               3              write(ERR,*) ' ===================================================== ';
               3              ]
               2          ERROR_FLAG=1;
               2          ERROR_FLAGS(I)=1;
               2          goto :END-NMIN-NMAX-LOOP:;
               2          ]
               1
               1      $CONVERT vname TO UPPER CASE; "This allows use of lower case letters"
               1      iindex = 0;
               1      IF (DELIM_START = 'NONE') [ start_found = .true.; ]
               1      ELSE                    [ start_found = .false.; ]
               1      WHILE ( iindex = 0 )  "Until the value sought is found"
               1      [
               2          :GI25:
               2          CONTINUE;
               2          LINE=LINE+1;
               2          IF( start_found ) [
               3              READ(UNITNUM,END=:GI1003:,ERR=:GI1001:,FMT='(A256)') TEXT;
               3              ]
               2          ELSE [
               3              READ(UNITNUM,END=:GI1004:,ERR=:GI1001:,FMT='(A256)') TEXT;
               3              ]
               2          "READ(UNITNUM,END=:GI1004:,ERR=:GI1001:,FMT='(A256)') TEXT;"
               2          $SKIP LEADING BLANKS IN text;
               2          $REMOVE EVERYTHING AFTER '#' IN text;
               2          $REMOVE EVERYTHING AFTER ';' IN text;
               2          length = lnblnk1(TEXT);
               2          TEXT=TEXT(:length);
               2          origtext = text(:length);
               2          $CONVERT text TO UPPER CASE;
               2          IF( ~start_found ) [
               3              IF (INDEX(TEXT,DELIM_START) ~= 0 ) [ start_found = .true.; ]
               3              goto :GI25:;
               3              ]
               2
               2          iindex=INDEX(TEXT,VNAME(:iVNAME));
               2
               2          " Check for end delimeter "
               2          IF( DELIM_END~='NONE' )
               2          [
               3              IF (INDEX(TEXT,DELIM_END)~=0)
               3              [
               4                  IF( error_level > 0 ) [
               5                      WRITE (ERR,*) '***************ERROR***************';
               5                      WRITE (ERR,*) '>>',VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
               5                      '<<',' NOT FOUND';
               5                      WRITE (ERR,*) 'END OF DELIMETER: ',DELIM_END;
               5                      ]
               4                  ERROR_FLAG=1;
               4                  ERROR_FLAGS(I)=1;
               4                  GOTO :END-NMIN-NMAX-LOOP:;
               4                  ]
               3              ]
               2          ] "end while loop. If we pass this loop, we have the values_sought string "
               1      "in text"
               1
               1      CHECK=0; "reset error checker"
               1      IF( idebug ) [
               2          write(i_log,*) ' ******* Found: ';
               2          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               2          write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
               2          ]
               1
               1      " Set string pointer to position after vname string and/or "
               1      " leadinf equals                                           "
               1      IINDEX=IINDEX+iVNAME;
               1      TEXT=TEXT(IINDEX:); origtext=origtext(iindex:);
               1      IF( idebug ) [
               2          write(i_log,*) ' After removing vname: ';
               2          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               2          write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
               2          ]
               1      IINDEX=INDEX(TEXT,'=');
               1      IF (IINDEX.NE.0) [
               2          TEXT=TEXT(IINDEX+1:); origtext=origtext(iindex+1:);
               2          ]
               1      ELSE [
               2          IINDEX=INDEX(TEXT,':');
               2          IF (IINDEX.NE.0) [
               3              TEXT=TEXT(IINDEX+1:); origtext=origtext(iindex+1:);
               3              ]
               2          ]
               1      IF( idebug ) [
               2          write(i_log,*) ' After removing leading equals: ';
               2          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               2          write(i_log,'(a,$)') ' origtext: '; $STRING-OUTPUT(origtext);
               2          ]
               1
               1      "===============read the value(i)======================="
               1      IF ( (lnblnk1(TEXT)=0) | (lnblnk1(TEXT)=1) )
               1      [
               2          IF (vname(:ivname)='TITLE')
               2          [
               3              READ (UNITNUM,FMT='(A80)') TEXTPIECE;
               3              IF (lnblnk1(TEXTPIECE)~=0) [
               4                  TEXT=TEXTPIECE(:lnblnk1(TEXTPIECE));
               4                  $SKIP LEADING BLANKS IN text;
               4                  $SKIP LEADING BLANKS IN origtext;
               4                  GOTO :TITLE-THERE:;
               4                  ]
               3              ]
               2          IF( error_level > 0 ) [
               3              WRITE (ERR,*) '*************ERROR*************';
               3              WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               3              WRITE (ERR,*) 'VALUE NOT THERE!!';
               3              ]
               2          ERROR_FLAG=1;
               2          ERROR_FLAGS(I)=1;
               2          RETURN;
               2          ]
               1      :TITLE-THERE:
               1      CONTINUE;
               1
               1      " Always check for default. The following sets the value to "
               1      " default(i) for a numeric input (type=1 or 2) and to 0 for "
               1      " an 'allowed input' => use only if one input is expected!  "
               1      iindex = index(text,'DEFAULT');
               1      IF( iindex ~= 0 )
               1      [                  "User requested a default value"
               2          IF( type(i) ~= 2 )
               2          [
               3              IF( type(i) ~= 3 ) [ VALUE(I,1)=DEFAULT(I); ]
               3              ELSE               [ VALUE(I,1)=0;          ]
               3              goto :END-NMIN-NMAX-LOOP:;
               3              ]
               2          ]
               1
               1      IF ((TYPE(I) = 0)|(TYPE(I) = 1))
               1      [                                 "Read the number"
               2          IVAL=1;  "nvalue counter"
               2          IF( idebug )[write(i_log,*) ' *** Reading an integer or a real value! ';]
               3              LOOP
               2          [
               3              IF( idebug ) [write(i_log,*) ' In LOOP, ival = ',ival;]
               3              IF (lnblnk1(TEXT)=0) [
               4                  IF( error_level > 0 ) [
               5                      WRITE(ERR,*) '*************ERROR*************';
               5                      WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               5                      WRITE (ERR,*) 'VALUE NOT THERE!!';
               5                      ]
               4                  ERROR_FLAG=1;
               4                  ERROR_FLAGS(I)=1;
               4                  RETURN;
               4                  ]
               3              READ(TEXT,END=:GI1010:,ERR=:GI1007:,FMT=*) VALUE(I,IVAL);
               3              IF( idebug ) [write(i_log,*) ' Read value: ',ival,VALUE(I,IVAL);]
               3              "==========================================================================="
               3              "=================================Defaults=================================="
               3
               3              IF ((VALUE(I,IVAL)>VALUE_MAX(I))|(VALUE(I,IVAL)<VALUE_MIN(I)))
               3              [
               4                  IF (TYPE(I)=0)
               4                  [
               5                      INT_VALUE=DEFAULT(I);
               5                      IF( error_level > 0 ) [
               6                          WRITE(ERR,*) '************WARNING************';
               6                          WRITE(ERR,:FMTA:) INT_VALUE,
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I)));
               6                          ]
               5                      :FMTA: FORMAT ( 'Default= ',I9,' used for: ', A );
               5                      INT_VALUE=VALUE(I,IVAL);
               5                      INT_VALUE_MIN=VALUE_MIN(I);
               5                      INT_VALUE_MAX=VALUE_MAX(I);
               5                      IF( error_level > 0 ) [
               6                          WRITE(ERR,:FMTB:)
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
               6                          INT_VALUE, INT_VALUE_MIN,INT_VALUE_MAX;
               6                          ]
               5                      :FMTB: FORMAT (A,'=', I9,' should be between ',
               5                      I9,' and ', I9);
               5                      ]
               4                  IF (TYPE(I)=1)
               4                  [
               5                      IF( error_level > 0 ) [
               6                          WRITE(ERR,*) '************WARNING************';
               6                          WRITE(ERR,:FMTC:) DEFAULT(I),
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I)));
               6                          :FMTC: FORMAT ( 'Default= ',F12.6,' used for: ', A );
               6                          WRITE(ERR,:FMTD:)
               6                          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),
               6                          VALUE(I,IVAL), VALUE_MIN(I),VALUE_MAX(I);
               6                          :FMTD: FORMAT (A,'=', F12.6,' should be between ',
               6                          G14.6,' and ', G14.6);
               6                          ]
               5                      ]
               4                  VALUE(I,IVAL)=DEFAULT(I);
               4                  ] "end IF default"
               3
               3              IF ( IVAL = NVALUE(I) ) EXIT; "Required inputs found"
               3              "==========================================================================="
               3              "=======================Move to next value, else exit======================="
               3
               3              IF ((INDEX(TEXT,',')~=0)|(lnblnk1(TEXT)=0))
               3              [
               4                  IF ( idebug ) [
               5                      write(i_log,*) ' A comma or a blank text found -> ';
               5                      write(i_log,*) ' searching for further input';
               5                      ]
               4                  TEXT=TEXT(INDEX(TEXT,',')+1:);
               4                  WHILE (lnblnk1(TEXT)=0)
               4                  [
               5                      IF ( idebug ) [
               6                          write(i_log,*) ' Empty text -> reading next line! ';
               6                          ]
               5                      LINE=LINE+1;
               5                      READ (UNITNUM,END=:GI1010:,ERR=:GI1007:,FMT='(A256)') TEXT;
               5                      $SKIP LEADING BLANKS IN text;
               5                      $REMOVE EVERYTHING AFTER '#' IN text;
               5                      $REMOVE EVERYTHING AFTER ';' IN text;
               5                      length = lnblnk1(TEXT);
               5                      TEXT=TEXT(:length);
               5                      origtext = text(:length);
               5                      $CONVERT text TO UPPER CASE;
               5
               5                      "Check whether this line containes one of the strings sought"
               5                      DO K = 1 , NMAX
               5                      [
               6                          vname1 = VALUES_SOUGHT(K);
               6                          length = lnblnk1(vname1);
               6                          IF( length > 0 )
               6                          [
               7                              $SKIP LEADING BLANKS IN vname1;
               7                              $CONVERT vname1 TO UPPER CASE;
               7                              IF (INDEX(TEXT,vname1(:length))~=0)
               7                              [
               8                                  IF( error_level > 0 ) [
               9                                      WRITE(ERR,*) '************ERROR************';
               9                                      WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               9                                      WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
               9                                      '<--COMMA INDICATES ANOTHER INPUT';
               9                                      WRITE(ERR,*) 'SEARCHED NEXT LINE: ',
               9                                      TEXT(:lnblnk1(TEXT));
               9                                      WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED';
               9                                      ]
               8                                  ERROR_FLAG=1;
               8                                  ERROR_FLAGS(I)=1;
               8                                  ]
               7                              ]
               6                          ]
               5                      IF( idebug ) [
               6                          write(i_log,*) ' Next line: ';
               6                          write(i_log,'(a,$)') ' text:     '; $STRING-OUTPUT(text);
               6                          write(i_log,'(a,$)') ' origtext: ';
               6                          $STRING-OUTPUT(origtext);
               6                          ]
               5                      ]
               4                  ] "end if ~=0"
               3              ELSE [EXIT;]
               3              IVAL=IVAL+1;
               3              ] "end loop"
               2          IF ((NVALUE(I)~=0)&(NVALUE(I)~=IVAL)) [
               3              IF( error_level > 0 ) [
               4                  WRITE (ERR,*) '**************ERROR**************';
               4                  WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I);
               4                  WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' NUMERICAL INPUT(S)';
               4                  WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED';
               4                  ]
               3              ERROR_FLAG=1;
               3              ERROR_FLAGS(I)=1;
               3              ]
               2          ELSE [NVALUE(I)=IVAL;]
               2          :GI1010:
               2          CONTINUE;
               2          ] "end IF TYPE"
               1
               1      "============================read the char_value(i)========================="
               1
               1      IF ((TYPE(I) = 2) | (TYPE(I) = 3))
               1      [                                   "Read the string"
               2          IVAL=1;     "nvalue counter"
               2          IF( idebug ) [write(i_log,*) ' Trying to read a string! ';]
               2          LOOP
               2          [
               3              IF( idebug ) [write(i_log,*) ' In LOOP, ival = ',ival;]
               3              IF (lnblnk1(TEXT)=0) [
               4                  IF( error_level > 0 ) [
               5                      WRITE(ERR,*) '*************ERROR*************';
               5                      WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               5                      WRITE (ERR,*) 'VALUE NOT THERE!!';
               5                      ]
               4                  ERROR_FLAG=1;
               4                  ERROR_FLAGS(I)=1;
               4                  RETURN;
               4                  ]
               3              IF (vname(:ivname)='TITLE') [
               4                  TEXTPIECE=origtext;
               4                  GOTO :READ-IT:
               4                  ]
               3              iindex = INDEX(origtext,',');
               3              IF ( iindex ~= 0 ) [ TEXTPIECE=origtext(:iindex-1); ]
               3              ELSE               [ TEXTPIECE=origtext;            ]
               3              "The above is to avoid conversion to upper case"
               3              "for e.g. media names                          "
               3              :READ-IT:
               3              CONTINUE;
               3              READ(TEXTPIECE,ERR=:GI1008:,FMT='(A80)') CHAR_VALUE(I,IVAL);
               3              $SKIP LEADING BLANKS IN CHAR_VALUE(I,IVAL);
               3              IF( idebug ) [
               4                  write(i_log,*) ' Read the following char string: ';
               4                  $STRING-OUTPUT(CHAR_VALUE(I,IVAL));
               4                  ]
               3              "===============================Allowed inputs=============================="
               3              IF (TYPE(I) = 3)
               3              [
               4                  $CONVERT CHAR_VALUE(I,IVAL) TO UPPER CASE;
               4                  ALLOWED=.FALSE.;
               4                  DO K=0, $MXALINP [
               5                      vname1 = ALLOWED_INPUTS(I,K);
               5                      $SKIP LEADING BLANKS IN ALLOWED_INPUTS(I,K);
               5                      $CONVERT ALLOWED_INPUTS(I,K) TO UPPER CASE;
               5                      IF (ALLOWED_INPUTS(I,K)=CHAR_VALUE(I,IVAL)) [
               6                          ALLOWED=.TRUE.;
               6                          VALUE(I,IVAL)=K;
               6                          IF( idebug ) [
               7                              write(i_log,*) ' Found a allowed_value match ',k;
               7                              ]
               6                          ]
               5                      ]
               4                  IF (.NOT.ALLOWED) [
               5                      WRITE(ERR,*) '*************ERROR*************';
               5                      IF (IVAL~=1) [
               6                          WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               6                          WRITE (ERR,*) 'SHOULD HAVE ONE INPUT ONLY';
               6                          WRITE (ERR,*) 'APPARENT STATE: COMMA INDICATING SECOND VALUE';
               6                          ]
               5                      ELSE [
               6                          WRITE (ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               6                          WRITE(ERR,*) 'INPUT-->',
               6                          CHAR_VALUE(I,IVAL)(:lnblnk1(CHAR_VALUE(I,IVAL))),
               6                          '<--NOT ALLOWED';
               6                          WRITE(ERR,*) 'OPTIONS ARE:';
               6                          WRITE(ERR,:FMT:)
               6                          (ALLOWED_INPUTS(I,K)(:lnblnk1(ALLOWED_INPUTS(I,K))),
               6                          K=0,$MXALINP);
               6                          ]
               5                      :FMT: FORMAT(A40);
               5                      ERROR_FLAG=1;
               5                      ERROR_FLAGS(I)=1;
               5                      ]
               4                  ]
               3              "=======================Move to next value, else exit======================="
               3
               3              IF (vname(:ivname)='TITLE') [ EXIT; ]
               3              DO K=1,LEN(KEEPTEXT) [KEEPTEXT(K:K)=' ';]  "erase previous KEEPTEXT"
               3              KEEPTEXT(:lnblnk1(TEXT))=TEXT;
               3              iindex = INDEX(TEXT,',');
               3              IF ( iindex ~= 0 | lnblnk1(TEXT)=0 )
               3              [
               4                  TEXT=TEXT(INDEX(TEXT,',')+1:);
               4                  origtext=origtext(iindex+1:);
               4                  WHILE (lnblnk1(TEXT)=0)
               4                  [
               5                      LINE=LINE+1;
               5                      READ (UNITNUM,ERR=:GI1008:,FMT='(A256)') TEXT;
               5                      $SKIP LEADING BLANKS IN text;
               5                      $REMOVE EVERYTHING AFTER '#' IN text;
               5                      $REMOVE EVERYTHING AFTER ';' IN text;
               5                      length = lnblnk1(TEXT);
               5                      TEXT=TEXT(:length);
               5                      origtext = text(:length);
               5                      $CONVERT text TO UPPER CASE;
               5
               5                      "Check whether this line containes one of the strings sought"
               5                      DO K = 1 , NMAX
               5                      [
               6                          vname1 = VALUES_SOUGHT(K);
               6                          length = lnblnk1(vname1);
               6                          IF( length > 0 )
               6                          [
               7                              $SKIP LEADING BLANKS IN vname1;
               7                              $CONVERT vname1 TO UPPER CASE;
               7                              IF (INDEX(TEXT,vname1(:length))~=0)
               7                              [
               8                                  WRITE(ERR,*) '************ERROR************';
               8                                  WRITE(ERR,*) 'VALUE SOUGHT: ',VALUES_SOUGHT(I);
               8                                  WRITE(ERR,*) KEEPTEXT(:lnblnk1(KEEPTEXT)),
               8                                  '<--COMMA INDICATES ANOTHER INPUT';
               8                                  WRITE(ERR,*) 'SEARCHED NEXT LINE: ',
               8                                  TEXT(:lnblnk1(TEXT));
               8                                  WRITE(ERR,*) 'BUT NO OTHER INPUT WAS DETECTED';
               8                                  ERROR_FLAG=1;
               8                                  ERROR_FLAGS(I)=1;
               8                                  ]
               7                              ]
               6                          ]
               5                      ]
               4                  ] "end if ~=0"
               3              ELSE [EXIT;]
               3              IVAL=IVAL+1;
               3              ] "end loop"
               2          IF ((NVALUE(I)~=0)&(NVALUE(I)~=IVAL)) [
               3              IF( error_level > 0 ) [
               4                  WRITE (ERR,*) '*******************ERROR*******************';
               4                  WRITE (ERR,*) 'VALUE SOUGHT: ', VALUES_SOUGHT(I);
               4                  WRITE (ERR,*) 'ASKED FOR', NVALUE(I),' INPUT(S)';
               4                  WRITE (ERR,*) 'HOWEVER,', IVAL, ' WERE DETECTED';
               4                  ]
               3              ERROR_FLAG=1;
               3              ERROR_FLAGS(I)=1;
               3              ]
               2          ELSE [NVALUE(I)=IVAL;]
               2          ]
               1      "==========================================================================="
               1      "==========================================================================="
               1      goto :END-NMIN-NMAX-LOOP:;
               1
               1      :GI1003:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '******************ERROR***********************';
               2          WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND';
               2          WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED END DELIMETER';
               2          WRITE (ERR,*) 'VALUE SOUGHT: >>',
               2          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),'<<';
               2          WRITE (ERR,*) 'END DELIMETER: >>',
               2          DELIM_END(:lnblnk1(DELIM_END)),'<<';
               2          ]
               1      ERROR_FLAG=1;
               1      ERROR_FLAGS(I)=1;
               1      goto :END-NMIN-NMAX-LOOP:;
               1
               1      :GI1004:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '******************ERROR***********************';
               2          WRITE (ERR,*) 'END OF FILE REACHED BUT VALUE SOUGHT NOT FOUND';
               2          WRITE (ERR,*) 'PROBABLY A MISSING/MISSPELLED START DELIMETER';
               2          WRITE (ERR,*) 'VALUE SOUGHT: >>',
               2          VALUES_SOUGHT(I)(:lnblnk1(VALUES_SOUGHT(I))),'<<';
               2          WRITE (ERR,*) 'START DELIMETER: >>',
               2          DELIM_START(:lnblnk1(DELIM_START)),'<<';
               2          ]
               1      ERROR_FLAG=1;
               1      ERROR_FLAGS(I)=1;
               1      goto :END-NMIN-NMAX-LOOP:;
               1
               1      :GI1007:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '***************ERROR***************';
               2          IF (IVAL>1) [J=IVAL;] ELSE [J=1;]
               2          WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I);
               2          WRITE (ERR,*) 'LINE #',LINE;
               2          WRITE (ERR,*) 'COULD NOT READ THE VALUE!!';
               2          WRITE (ERR,*) 'SHOULD BE AN INTEGER OR A REAL...';
               2          WRITE (ERR,*) 'IS THERE AN EXTRA COMMA AT THE END OF YOUR INPUT?';
               2          ]
               1      ERROR_FLAG=1; "turn on the error flag"
               1      ERROR_FLAGS(I)=1; "turn on the error flag"
               1      GOTO :END-NMIN-NMAX-LOOP:;
               1      :GI1008:
               1      IF( error_level > 0 ) [
               2          WRITE (ERR,*) '***************ERROR***************';
               2          WRITE (ERR,*) 'ERROR READING VALUE SOUGHT: ', VALUES_SOUGHT(I);
               2          WRITE (ERR,*) 'LINE #',LINE;
               2          WRITE (ERR,*) 'COULD NOT READ THE STRING !!';
               2          ]
               1      ERROR_FLAG=1; "turn on the error flag"
               1      ERROR_FLAGS(I)=1; "turn on the error flag"
               1
               1      :END-NMIN-NMAX-LOOP:
               1      CONTINUE;
               1      ] "end do NMAX loop"
               0  RETURN;
               0
               0  "**************if any errors**************"
               0  :GI1001:
               0  WRITE (ERR,*) '***************ERROR***************';
               0  WRITE (ERR,*) 'ERROR READING TEXT ', TEXT,' ON LINE ',LINE;
               0  goto :GI1009:;
               0  :GI1009:
               0  CONTINUE;  "exit if there is an error"
               0  ERROR_FLAG=1; "turn on the error flag"
               0  ERROR_FLAGS(I)=1; "turn on the error flag"
               0  RETURN;
               0
               0  entry get_input_plus_set_error_level(the_level);
               0  error_level = the_level;
               0  return;
               0  END;
               0
               0  "*****************************************************************************
               0  "
               0  subroutine get_media_inputs(ounit);
               0  "subroutine to take the media names in the input file and get the material
               0  "data, either from a user-specified material data file, from material data
               0  "specified explicitly in the input file, or from a user-specified density
               0  "correction file.  This subroutine is called in HATCH.  It assumes that
               0  "the subroutine get_transport_parameter has already been called and that
               0  "the media names in the simulation have already been read in.
               0
               0  implicit none;
               0
               0  REPLACE{$MAXPOINTS}WITH{300};
               0
               0  $INTEGER ounit;
               0  $declare_max_medium;
               0
               0  $COMIN-GET-TRANSPORTP;
               0  COMIN/MEDINP,ELECIN,THRESH,ELEMTB,USEFUL/;
               0
               0  $INTEGER  ival,ival_media,ival_medfile,i,j,k,ival_ae,ival_ue,ival_ap,ival_up,
               0  ival_rho,ival_elements,ival_rhoz,ival_iunrst,ival_iaprim,ival_gasp,
               0  ival_pz,ival_sterncid,
               0  ival_densityfile,medfile_error,ival_outfile,
               0  egs_open_file,lnblnk1,i_medfile,egs_get_unit,i_mederr,mindex,eindex,
               0  i_density,i01,length,i_outfile;
               0  $REAL ecut_min, pcut_min;
               0
               0  $LOGICAL  medfile_specified,densityfile_specified,elements_specified,
               0  outfile_specified($MXMED);
               0  $LOGICAL  iunrst_specified,stern_specified,iaprim_specified,
               0  gasp_specified,rho_specified,start_delim_found,end_delim_found,
               0  spec_by_pz,spec_by_rhoz,df_if_elem_mismatch($MXMED),
               0  df_if_rho_mismatch($MXMED);
               0  $LOGICAL  ex;
               0
               0  $INTEGER CURSOR,Kconvert;
               0
               0  "maybe we do not need to keep ZTBL REAL4, since it is only used here"
               0  $REAL4 ZTBL;
               0
               0  "variables for output of cross-section data to file for plotting"
               0  "some names end with O to avoid conflict with global variables"
               0  "in common blocks above"
               0  $REAL EKE,ELKE,TMXSO,DEDXE,DEDXP,EFRACT,SIGE,SIGP,BREME,BREMP,ETAB(16),
               0  EIE,PLOTE($MAXPOINTS),PLOTEM($MAXPOINTS),PLOTEEN($MAXPOINTS),
               0  PLOTEMP($MAXPOINTS), PLOTEMS($MAXPOINTS);
               0  $INTEGER IPLOTE,IFLAG1,IFLAG2,LELKE;
               0  CHARACTER*60 GRAPHTITLE,XAXIS,YAXISPcom,YAXISPmfp,YAXISE,YAXISEmfp,
               0  SUBTITLE,SERIES;
               0  DATA ETAB/1.,1.25,1.5,1.75,2.,2.5,3.,3.5,4.,4.5,5.,5.5,6.,7.,8.,9./;
               0
               0
               0  character*24 medium_name,med_tmp,sterncid_tmp;
               0  character*256 density_file,material_file,tmp_string,
               0  spoutput_file($MXMED);
               0  character*80 text_string, text_save, title;
               0  character*40 delim_start,delim_end;
               0  character*1 blank;
               0  character*512 toUpper;
               0
               0  "temporary variables for storing values before committing them"
               0  "to the media library"
               0  $INTEGER nne_tmp,iaprim_tmp,epstfl_tmp,iunrst_tmp;
               0  $REAL rho_tmp,rhoz_tmp($MXEL),z_tmp($MXEL),pz_tmp($MXEL),ae_tmp,ap_tmp,
               0  ue_tmp,up_tmp,gasp_tmp;
               0  $TYPE asym_tmp($MXEL);
               0
               0  "for stuff read from the density correction file"
               0  $INTEGER nepst_df,nne_df;
               0  $REAL iev_df,rho_df,z_df($MXEL),rhoz_df($MXEL),rhoz_tot;
               0  $TYPE asym_df($MXEL);
               0
               0  data blank/' '/;
               0
               0  save medfile_specified,material_file,df_if_elem_mismatch,df_if_rho_mismatch,
               0  spoutput_file,outfile_specified;
               0
               0  REPLACE {$WRITE_MEDERR(#)} WITH {
            {  0  ;
            {  0  IF(n_parallel=0 | i_parallel=first_parallel)[
            {  0  write(i_mederr,*){P1};
            {  0  ]
            {  0  ;
            {  0  }
               0  ;
               0
               0  call get_input_set_error_level(0);
               0  call get_input_plus_set_error_level(0);
               0
               0  "open a file for output from this routine"
               0  IF(n_parallel=0 | i_parallel=first_parallel)[
               1      i_mederr=17;
               1      i_mederr=egs_open_file(i_mederr,0,1,'.mederr');
               1      ]
               0
               0  "find min. ecut and pcut"
               0  ecut_min=999.;
               0  pcut_min=999.;
               0  DO i=1,$MXREG[
               1      IF(ecut(i)<ecut_min)ecut_min=ecut(i);
               1      IF(pcut(i)<pcut_min)pcut_min=pcut(i);
               1      ]
               0
               0  delimeter = 'MEDIA DEFINITION';
               0  ival = 0;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  "full name of media data file"
               0  ival                = ival + 1;
               0  ival_medfile         = ival;
               0  values_sought(ival) = 'material data file';    "The code word"
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 2;
               0  Nmin = ival_medfile; Nmax = ival_medfile;
               0  CALL GET_INPUT;
               0  IF(error_flags(ival_medfile)=0)[
               1      material_file=char_value(ival_medfile,1);
               1      medfile_specified=.true.;
               1      "try opening it"
               1      i_medfile=17;
               1      i_medfile=egs_get_unit(i_medfile);
               1      IF(i_medfile < 1)[
               2          $egs_fatal('(a)','Error: Failed to get available fortran unit for',
               2          ' medium data file.');
               2          ]
               1      open(i_medfile,file=material_file,status='old',err=:no_media_file:);
               1      medfile_specified=.true.;
               1      ]
               0  ELSE[
               1      $WRITE_MEDERR(' Warning: material data file not supplied.');
               1      $WRITE_MEDERR(' Thus, you must define media explicitly in input file');
               1      $WRITE_MEDERR(' or via density correction file.');
               1      medfile_specified=.false.;
               1      ]
               0
               0  "get AE, UE, AP, UP, if specified"
               0  ival                = ival + 1;
               0  ival_ae = ival;
               0  values_sought(ival) = 'ae';
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;
               0  value_min(ival)     = 0;
               0  value_max(ival)     = 999.;
               0  default(ival)       = ecut_min;
               0
               0  ival                = ival + 1;
               0  ival_ap = ival;
               0  values_sought(ival) = 'ap';
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;
               0  value_min(ival)     = 0;
               0  value_max(ival)     = 999.;
               0  default(ival)       = pcut_min;
               0
               0  ival                = ival + 1;
               0  ival_ue = ival;
               0  values_sought(ival) = 'ue';
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;
               0  value_min(ival)     = 0;
               0  value_max(ival)     = 999.;
               0  default(ival)       = 50 + prm;
               0
               0  ival                = ival + 1;
               0  ival_up = ival;
               0  values_sought(ival) = 'up';
               0  nvalue(ival)        = 1;                        "1 input"
               0  type(ival)          = 1;
               0  value_min(ival)     = 0;
               0  value_max(ival)     = 999.;
               0  default(ival)       = 50.0;
               0
               0  Nmin=ival_ae;Nmax=ival_up;
               0  CALL GET_INPUT;
               0  IF(error_flags(ival_ae)=0)[
               1      ae_tmp=value(ival_ae,1);
               1      ]
               0  ELSE[
               1      $WRITE_MEDERR(' Warning: AE for media not supplied.  Will use min. ECUT.');
               1      ae_tmp=ecut_min;
               1      ]
               0  IF(error_flags(ival_ap)=0)[
               1      ap_tmp=value(ival_ap,1);
               1      ]
               0  ELSE[
               1      $WRITE_MEDERR(' Warning: AP for media not supplied.  Will use min. PCUT.');
               1      ap_tmp=pcut_min;
               1      ]
               0  IF(error_flags(ival_ue)=0)[
               1      ue_tmp=value(ival_ue,1);
               1      ]
               0  ELSE[
               1      $WRITE_MEDERR(' Warning: UE for media not supplied.  Will use
            '  1      50.5109989461 MeV');
               1      ue_tmp=50 + prm;
               1      ]
               0  IF(error_flags(ival_up)=0)[
               1      up_tmp=value(ival_up,1);
               1      ]
               0  ELSE[
               1      $WRITE_MEDERR(' Warning: UP for media not supplied.  Will use 50.0 MeV');
               1      up_tmp=50.;
               1      ]
               0
               0  IF(ue_tmp<=ae_tmp)[
               1      $WRITE_MEDERR(' Error: UE <= AE.  Adjust value(s) and try again.');
               1      $egs_fatal('(a)',' Error: UE <= AE.  Adjust value(s) and try again.');
               1      ]
               0  IF(up_tmp<=ap_tmp)[
               1      $WRITE_MEDERR(' Error: UP <= AP.  Adjust value(s) and try again.');
               1      $egs_fatal('(a)',' Error: UP <= AP.  Adjust value(s) and try again.');
               1      ]
               0
               0  "now check for individual media inputs in file"
               0  "if not there, get data from material data file"
               0
               0  DO i=1,NMED[
               1
               1      "convert medium name to string for ease of"
               1      "implementation"
               1      DO j=1,24[medium_name(j:j)=media(j,i);]
               1
               1      "set up defaults"
               1      elements_specified=.false.;
               1      rho_specified=.false.;
               1      densityfile_specified=.false.;
               1      stern_specified=.false.;
               1      iunrst_specified=.false.;
               1      iaprim_specified=.false.;
               1      gasp_specified=.false.;
               1      spec_by_rhoz=.false.;
               1      spec_by_pz=.false.;
               1      df_if_elem_mismatch(i)=.false.;
               1      df_if_rho_mismatch(i)=.false.;
               1
               1      sterncid_tmp=medium_name;
               1      gasp_tmp=0.0;
               1      iunrst_tmp=0;
               1      iaprim_tmp=0;
               1      epstfl_tmp=0;
               1      density_file=' ';
               1
               1      $WRITE_MEDERR(' ');
               1
               1      $WRITE_MEDERR(' For medium: ',medium_name);
               1
               1      delimeter=$cstring(medium_name);
               1
               1      ival=0;
               1
               1      "see if composition is specified explicitly"
               1      ival=ival+1;
               1      ival_elements=ival;
               1      values_sought(ival) = 'elements';
               1      type(ival)          = 2;  "i.e.  character input"
               1      nvalue(ival)        = 0;
               1      nmin=ival_elements;nmax=ival_elements;
               1      CALL GET_INPUT;
               1      IF(error_flags(ival_elements)=0)[
               2          DO j=1,nvalue(ival_elements)[
               3              $CONVERT char_value(ival_elements,j) TO UPPER CASE;
               3              ]
               2          "now get fraction of each element"
               2          ival=ival+1;
               2          ival_pz=ival;
               2          nne_tmp=nvalue(ival_elements);
               2          values_sought(ival)='number of atoms';
               2          type(ival)=0;
               2          nvalue(ival)=nne_tmp;
               2          nmin=ival_pz;nmax=ival_pz;
               2          CALL GET_INPUT;
               2          IF(nne_tmp>1 & error_flags(ival_pz)=0)[
               3              "got em.  Use em.  But not if this is an element"
               3              DO j=1,nne_tmp[
               4                  asym_tmp(j)=char_value(ival_elements,j);
               4                  pz_tmp(j)=value(ival_pz,j);
               4                  ]
               3              elements_specified=.true.;
               3              spec_by_pz=.true.;
               3              ]
               2          ELSE[
               3              "check to see if fractional wts specified"
               3              ival=ival+1;
               3              ival_rhoz=ival;
               3              values_sought(ival)='mass fractions';
               3              type(ival)=1;
               3              nvalue(ival)=nne_tmp;
               3              nmin=ival_rhoz;nmax=ival_rhoz;
               3              IF(nne_tmp=1)[
               4                  "set max, min and default values"
               4                  value_min(ival)=0.0;
               4                  value_max(ival)=1.e15;
               4                  default(ival)=1.;
               4                  ]
               3              CALL GET_INPUT;
               3              IF(error_flags(ival_rhoz)=0)[
               4                  "got em.  Use em."
               4                  DO j=1,nne_tmp[
               5                      asym_tmp(j)=char_value(ival_elements,j);
               5                      rhoz_tmp(j)=value(ival_rhoz,j);
               5                      ]
               4                  elements_specified=.true.;
               4                  spec_by_rhoz=.true.;
               4                  ]
               3              ]
               2          IF(nne_tmp=1 & ~elements_specified)[
               3              "an element: set pz to 1 and use default atomic weight"
               3              asym_tmp(1)=char_value(ival_elements,1);
               3              pz_tmp(1)=1;
               3              elements_specified=.true.;
               3              spec_by_pz=.true.;
               3              ]
               2          IF(elements_specified)[
               3              $WRITE_MEDERR(' Composition specified in .egsinp file.');
               3              ]
               2          ]
               1
               1      "see what else is there"
               1      ival=ival+1;
               1      ival_rho=ival;
               1      values_sought(ival) = 'rho';
               1      type(ival)=1;
               1      nvalue(ival)=1;
               1      value_min(ival)=0.;
               1      value_max(ival)=1e15;
               1      default(ival)=1.0;
               1      nmin=ival_rho;nmax=ival_rho;
               1      CALL GET_INPUT;
               1      IF(error_flags(ival_rho)=0)[
               2          rho_tmp=value(ival_rho,1);
               2          rho_specified=.true.;
               2          $WRITE_MEDERR(' Rho specified in .egsinp file.');
               2          ]
               1
               1      "now see what else is specified in the .egsinp file"
               1      ival=ival+1;
               1      ival_sterncid=ival;
               1      values_sought(ival)='sterncid';
               1      type(ival)=2;
               1      nvalue(ival)=1;
               1      nmin=ival_sterncid;nmax=ival_sterncid;
               1      CALL GET_INPUT;
               1      IF(error_flags(ival_sterncid)=0)[
               2          sterncid_tmp=char_value(ival_sterncid,1);
               2          stern_specified=.true.;
               2          $WRITE_MEDERR(' STERNCID specified in .egsinp file.');
               2          ]
               1
               1      ival=ival+1;
               1      ival_iunrst=ival;
               1      values_sought(ival)='stopping powers';
               1      type(ival)=3;
               1      nvalue(ival)=1;
               1      allowed_inputs(ival,0)='restricted total';
               1      allowed_inputs(ival,1)='unrestricted collision';
               1      allowed_inputs(ival,2)='unrestricted collision and radiative';
               1      allowed_inputs(ival,3)='unrestricted collision and restricted radiative';
               1      allowed_inputs(ival,4)='restricted collision and unrestricted radiative';
               1      allowed_inputs(ival,5)='unrestricted radiative';
               1      nmin=ival_iunrst;nmax=ival_iunrst;
               1      CALL GET_INPUT;
               1      IF(error_flags(ival_iunrst)=0)[
               2          iunrst_tmp=value(ival_iunrst,1);
               2          iunrst_specified=.true.;
               2          $WRITE_MEDERR(' IUNRST specified in .egsinp file.');
               2          ]
               1
               1      ival=ival+1;
               1      ival_iaprim=ival;
               1      values_sought(ival)='bremsstrahlung correction';
               1      type(ival)=3;
               1      nvalue(ival)=1;
               1      allowed_inputs(ival,0)='KM';
               1      allowed_inputs(ival,1)='NRC';
               1      allowed_inputs(ival,2)='none';
               1      nmin=ival_iaprim;nmax=ival_iaprim;
               1      CALL GET_INPUT;
               1      IF(error_flags(ival_iaprim)=0)[
               2          iaprim_tmp=value(ival_iaprim,1);
               2          iaprim_specified=.true.;
               2          $WRITE_MEDERR(' IAPRIM specified in .egsinp file.');
               2          ]
               1
               1      ival=ival+1;
               1      ival_gasp=ival;
               1      values_sought(ival)='gas pressure';
               1      type(ival)=1;
               1      nvalue(ival)=1;
               1      value_min(ival)=0.;
               1      value_max(ival)=1e15;
               1      default(ival)=0.0;
               1      nmin=ival_gasp;nmax=ival_gasp;
               1      CALL GET_INPUT;
               1      IF(error_flags(ival_gasp)=0)[
               2          gasp_tmp=value(ival_gasp,1);
               2          gasp_specified=.true.;
               2          $WRITE_MEDERR(' GASP specified in .egsinp file.');
               2          ]
               1
               1      ival=ival+1;
               1      ival_densityfile=ival;
               1      values_sought(ival)='density correction file';
               1      type(ival)          = 2;
               1      nvalue(ival)=1;
               1      nmin=ival_densityfile;nmax=ival_densityfile;
               1      CALL GET_INPUT;
               1      IF(error_flags(ival_densityfile)=0)[
               2          density_file=char_value(ival_densityfile,1);
               2          densityfile_specified=.true.;
               2          "may get changed to false later if it cannot be opened"
               2          $WRITE_MEDERR(' Density correction file specified in .egsinp file.');
               2          ]
               1
               1      "check if the user has specified an output file for plotting"
               1      "e- data."
               1      ival = ival+1;
               1      ival_outfile = ival;
               1      values_sought(ival) = 'e- stopping power output file';
               1      type(ival) = 2;
               1      nvalue(ival) =1;
               1      nmin=ival_outfile;nmax=ival_outfile;
               1      CALL GET_INPUT;
               1      IF(error_flags(ival_outfile)=0)[
               2          spoutput_file(i)=char_value(ival_outfile,1);
               2          outfile_specified(i)=.true.;
               2          $WRITE_MEDERR(' e- stopping powers will be output to ',
               2          spoutput_file(i));
               2          ]
               1      ELSE [
               2          outfile_specified(i)=.false.;
               2          ]
               1
               1      "done reading the .egsinp file for this medium"
               1      "see if we need anything from the material data file"
               1      IF(medfile_specified & (~elements_specified | ~rho_specified |
               1      ~iunrst_specified | ~iaprim_specified | ~gasp_specified |
               1      ~stern_specified | ~densityfile_specified))[
               2          "we assume at this point that the media file has been opened"
               2          "let us find the delimeters for this medium"
               2          rewind(i_medfile);
               2          start_delim_found=.false.;
               2          end_delim_found=.false.;
               2          WHILE(~start_delim_found | ~end_delim_found)[
               3              read(i_medfile,'(a)',end=:stop_medfile_read:)text_string;
               3              text_save=text_string;
               3              text_string=toUpper($cstring(text_string));
               3              mindex=index(text_string,'MEDIUM');
               3              eindex=index(text_string,'=');
               3              IF(mindex>0 & eindex>mindex)[
               4                  "remove everything up to ="
               4                  text_string=text_save(eindex+1:);
               4                  text_string=$cstring(text_string);
               4                  $SKIP LEADING BLANKS IN text_string;
               4                  IF(text_string=medium_name)[
               5                      delim_start=text_save;
               5                      start_delim_found=.true.;
               5                      ]
               4                  ELSEIF(start_delim_found)[
               5                      delim_end=text_save;
               5                      end_delim_found=.true.;
               5                      ]
               4
               4                  ]
               3              ]
               2          :stop_medfile_read:
               2          IF(~start_delim_found)[
               3              $WRITE_MEDERR(' Warning: Data for ',medium_name,' not found');
               3              $WRITE_MEDERR(' in material data file.');
               3              ]
               2          ELSE[
               3              IF(~end_delim_found)[
               4                  "eof is end delimiter"
               4                  delim_end='NONE';
               4                  ]
               3
               3              ival=0;
               3              "now go through and get what is required"
               3              IF(~elements_specified)[
               4                  ival=ival+1;
               4                  ival_elements=ival;
               4                  values_sought(ival) = 'elements';
               4                  type(ival)          = 2;  "i.e.  character input"
               4                  nvalue(ival)        = 0;
               4                  nmin=ival_elements;nmax=ival_elements;
               4                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               4                  IF(error_flags(ival_elements)=0)[
               5                      "now get fraction of each element"
               5                      ival=ival+1;
               5                      ival_pz=ival;
               5                      nne_tmp=nvalue(ival_elements);
               5                      values_sought(ival)='number of atoms';
               5                      type(ival)=0;
               5                      nvalue(ival)=nne_tmp;
               5                      nmin=ival_pz;nmax=ival_pz;
               5                      CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               5                      IF(nne_tmp>1 & error_flags(ival_pz)=0)[
               6                          "got em.  Use em.  If its not an element"
               6                          DO j=1,nne_tmp[
               7                              asym_tmp(j)=char_value(ival_elements,j);
               7                              pz_tmp(j)=value(ival_pz,j);
               7                              ]
               6                          elements_specified=.true.;
               6                          spec_by_pz=.true.;
               6                          ]
               5                      ELSE[
               6                          "check to see if fractional wts specified"
               6                          ival=ival+1;
               6                          ival_rhoz=ival;
               6                          values_sought(ival)='mass fractions';
               6                          type(ival)=1;
               6                          nvalue(ival)=nne_tmp;
               6                          nmin=ival_rhoz;nmax=ival_rhoz;
               6                          IF(nne_tmp=1)[
               7                              "set max, min and default values"
               7                              value_min(ival)=0.0;
               7                              value_max(ival)=1.e15;
               7                              default(ival)=1.;
               7                              ]
               6                          CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               6                          IF(error_flags(ival_rhoz)=0)[
               7                              "got em.  Use em."
               7                              DO j=1,nne_tmp[
               8                                  asym_tmp(j)=char_value(ival_elements,j);
               8                                  rhoz_tmp(j)=value(ival_rhoz,j);
               8                                  ]
               7                              elements_specified=.true.;
               7                              spec_by_rhoz=.true.;
               7                              ]
               6                          ]
               5                      IF(nne_tmp=1 & ~elements_specified)[
               6                          asym_tmp(1)=char_value(ival_elements,1);
               6                          pz_tmp(1)=1;
               6                          elements_specified=.true.;
               6                          spec_by_pz=.true.;
               6                          ]
               5                      IF(elements_specified)[
               6                          $WRITE_MEDERR(' Composition specified in material data file');
               6                          ]
               5                      ]
               4                  ]
               3
               3              IF(~rho_specified)[
               4                  ival=ival+1;
               4                  ival_rho=ival;
               4                  values_sought(ival) = 'rho';
               4                  type(ival)=1;
               4                  nvalue(ival)=1;
               4                  value_min(ival)=0.;
               4                  value_max(ival)=1e15;
               4                  default(ival)=1.0;
               4                  nmin=ival_rho;nmax=ival_rho;
               4                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               4                  IF(error_flags(ival_rho)=0)[
               5                      rho_tmp=value(ival_rho,1);
               5                      rho_specified=.true.;
               5                      $WRITE_MEDERR(' Rho specified in material data file');
               5                      ]
               4                  ]
               3
               3              IF(~stern_specified)[
               4                  ival=ival+1;
               4                  ival_sterncid=ival;
               4                  values_sought(ival)='sterncid';
               4                  type(ival)=2;
               4                  nvalue(ival)=1;
               4                  nmin=ival_sterncid;nmax=ival_sterncid;
               4                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               4                  IF(error_flags(ival_sterncid)=0)[
               5                      sterncid_tmp=char_value(ival_sterncid,1);
               5                      stern_specified=.true.;
               5                      $WRITE_MEDERR(' STERNCID specified in material data file');
               5                      ]
               4                  ]
               3
               3              IF(~iunrst_specified)[
               4                  ival=ival+1;
               4                  ival_iunrst=ival;
               4                  values_sought(ival)='stopping powers';
               4                  type(ival)=3;
               4                  nvalue(ival)=1;
               4                  allowed_inputs(ival,0)='restricted total';
               4                  allowed_inputs(ival,1)='unrestricted collision';
               4                  allowed_inputs(ival,2)='unrestricted collision and radiative';
               4                  allowed_inputs(ival,3)=
               4                  'unrestricted collision and restricted radiative';
               4                  allowed_inputs(ival,4)=
               4                  'restricted collision and unrestricted radiative';
               4                  allowed_inputs(ival,5)='unrestricted radiative';
               4                  nmin=ival_iunrst;nmax=ival_iunrst;
               4                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               4                  IF(error_flags(ival_iunrst)=0)[
               5                      iunrst_tmp=value(ival_iunrst,1);
               5                      iunrst_specified=.true.;
               5                      $WRITE_MEDERR(' IUNRST specified in material data file');
               5                      ]
               4                  ]
               3
               3              IF(~iaprim_specified)[
               4                  ival=ival+1;
               4                  ival_iaprim=ival;
               4                  values_sought(ival)='bremsstrahlung correction';
               4                  type(ival)=3;
               4                  nvalue(ival)=1;
               4                  allowed_inputs(ival,0)='KM';
               4                  allowed_inputs(ival,1)='NRC';
               4                  allowed_inputs(ival,2)='none';
               4                  nmin=ival_iaprim;nmax=ival_iaprim;
               4                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               4                  IF(error_flags(ival_iaprim)=0)[
               5                      iaprim_tmp=value(ival_iaprim,1);
               5                      iaprim_specified=.true.;
               5                      $WRITE_MEDERR(' IAPRIM specified in material data file');
               5                      ]
               4                  ]
               3
               3              IF(~gasp_specified)[
               4                  ival=ival+1;
               4                  ival_gasp=ival;
               4                  values_sought(ival)='gas pressure';
               4                  type(ival)=1;
               4                  nvalue(ival)=1;
               4                  value_min(ival)=0.;
               4                  value_max(ival)=1.e15;
               4                  default(ival)=0.;
               4                  nmin=ival_gasp;nmax=ival_gasp;
               4                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               4                  IF(error_flags(ival_gasp)=0)[
               5                      gasp_tmp=value(ival_gasp,1);
               5                      gasp_specified=.true.;
               5                      $WRITE_MEDERR(' GASP specified in material data file');
               5                      ]
               4                  ]
               3
               3              IF(~densityfile_specified)[
               4                  ival=ival+1;
               4                  ival_densityfile=ival;
               4                  values_sought(ival)='density correction file';
               4                  type(ival)          = 2;
               4                  nvalue(ival)=1;
               4                  nmin=ival_densityfile;nmax=ival_densityfile;
               4                  CALL GET_INPUT_PLUS(i_medfile,delim_start,delim_end);
               4                  IF(error_flags(ival_densityfile)=0)[
               5                      density_file=char_value(ival_densityfile,1);
               5                      densityfile_specified=.true.;
               5                      "may get changed to false later if it cannot be opened"
               5                      $WRITE_MEDERR(
               5                      ' Density correction file specified in material data file.');
               5                      ]
               4                  ]
               3              ]
               2
               2          ]
               1
               1      "now, try to open the density correction file, if specified"
               1      IF(densityfile_specified)[
               2          "if a file separator is specified in the name, assume the full path + name"
               2          "of the file is specified"
               2          IF(index(density_file,$file_sep)>0) [
               3              tmp_string=$cstring(density_file);
               3              inquire(file=tmp_string,exist=ex);
               3              IF(~ex)[
               4                  $WRITE_MEDERR(' Error: Density correction file ',tmp_string);
               4                  $WRITE_MEDERR(' cannot be found.');
               4                  ]
               3              ]
               2          ELSE [
               3              density_file=$cstring(density_file)//'.density';
               3              "first look in $EGS_HOME/pegs4/density_corrections"
               3              tmp_string=$cstring(egs_home) // 'pegs4' // $file_sep //
               3              'density_corrections' // $file_sep // density_file;
               3              inquire(file=tmp_string,exist=ex);
               3              IF(ex) goto :density_file_found:;
               3              tmp_string=$cstring(egs_home) // 'pegs4' // $file_sep //
               3              'density_corrections' // $file_sep // 'elements' //
               3              $file_sep // density_file;
               3              inquire(file=tmp_string,exist=ex);
               3              IF(ex) goto :density_file_found:;
               3              tmp_string=$cstring(egs_home) // 'pegs4' // $file_sep //
               3              'density_corrections' // $file_sep // 'compounds' //
               3              $file_sep // density_file;
               3              inquire(file=tmp_string,exist=ex);
               3              IF(ex) goto :density_file_found:;
               3              "now look in $EGS_HOME/pegs4/density in case directory still there"
               3              tmp_string=$cstring(egs_home) // 'pegs4' // $file_sep //
               3              'density' // $file_sep // density_file;
               3              inquire(file=tmp_string,exist=ex);
               3              IF(ex) goto :density_file_found:;
               3              "now look through $HEN_HOUSE/pegs4/density_corrections"
               3              tmp_string=$cstring(hen_house) // 'pegs4' // $file_sep //
               3              'density_corrections' // $file_sep // 'elements' //
               3              $file_sep // density_file;
               3              inquire(file=tmp_string,exist=ex);
               3              IF(ex) goto :density_file_found:;
               3              tmp_string=$cstring(hen_house) // 'pegs4' // $file_sep //
               3              'density_corrections' // $file_sep // 'compounds' //
               3              $file_sep // density_file;
               3              inquire(file=tmp_string,exist=ex);
               3              IF(ex) goto :density_file_found:;
               3              $WRITE_MEDERR(' Error: Density correction file',
               3              density_file);
               3              $WRITE_MEDERR(' does not exist in');
               3              $WRITE_MEDERR(' $EGS_HOME/pegs4/density_corrections, ');
               3              $WRITE_MEDERR(' $EGS_HOME/pegs4/density_corrections/elements, ');
               3              $WRITE_MEDERR(' $EGS_HOME/pegs4/density_corrections/compounds, ');
               3              $WRITE_MEDERR(' $EGS_HOME/pegs4/density, ');
               3              $WRITE_MEDERR(
               3              ' $HEN_HOUSE/pegs4/density_corrections/elements or ');
               3              $WRITE_MEDERR(
               3              ' $HEN_HOUSE/pegs4/density_corrections/compounds.');
               3              :density_file_found:
               3              ]
               2          ]
               1
               1      IF(densityfile_specified)[
               2          "now try to open it"
               2          i_density=19;
               2          i_density=egs_get_unit(i_density);
               2          IF(i_density < 1)[
               3              $egs_fatal('(a)','Error: Failed to get available fortran unit for',
               3              ' density correction file.');
               3              ]
               2          open(i_density,file=tmp_string,status='old',err=:no_density_file:);
               2          density_file=tmp_string;
               2          densityfile_specified=.true.;
               2          epstfl_tmp=1;
               2
               2          "the density file is open at this point so just read the data"
               2
               2          read(i_density,'(a)')title;
               2          read(i_density,*)nepst_df,iev_df,rho_df,nne_df;
               2          read(i_density,*)(z_df(j),rhoz_df(j),j=1,nne_df);
               2
               2          "get atomic symbols and pz based on df header"
               2          DO j=1,nne_df[
               3              i01=z_df(j);
               3              asym_df(j)=ASYMT(i01);
               3              ]
               2
               2          "check to see if data read from density file matches"
               2          "composition and rho already input"
               2          IF(elements_specified)[
               3              IF(nne_tmp~=nne_df)[
               4                  df_if_elem_mismatch(i)=.true.;
               4                  ]
               3              ELSE[
               4                  rhoz_tot=0.;
               4                  DO j=1,nne_tmp["normalize rhoz as it is in dcf"
               5                      IF(spec_by_pz)[
               6                          i01=ZTBL(asym_tmp(j));
               6                          rhoz_tmp(j)=pz_tmp(j)*WATBL(i01);
               6                          ]
               5                      rhoz_tot=rhoz_tot+rhoz_tmp(j);
               5                      ]
               4                  DO j=1,nne_df[
               5                      DO k=1,nne_tmp[ "at this point nne_df=nne_tmp"
               6                          IF(asym_df(j)=asym_tmp(k))[
               7                              IF(rhoz_df(j)>(1+0.01)*rhoz_tmp(k)/rhoz_tot |
               7                              rhoz_df(j)<(1-0.01)*rhoz_tmp(k)/rhoz_tot)[
               8                                  df_if_elem_mismatch(i)=.true.;
               8                                  ]
               7                              exit;
               7                              ]
               6                          ]
               5                      IF(k>nne_tmp) df_if_elem_mismatch(i)=.true.;
               5                      "never found the element"
               5                      IF(df_if_elem_mismatch(i)) [exit;];
               5                      ]
               4                  ]
               3              IF(df_if_elem_mismatch(i))[
               4                  $WRITE_MEDERR(' Warning: composition specified in density correction',
               4                  ' file is not the same as that');
               4                  $WRITE_MEDERR(' specified in input or material data file.');
               4                  $WRITE_MEDERR(
               4                  ' Will use the composition specified in the density correction file.');
               4                  nne_tmp=nne_df;
               4                  DO j=1,nne_tmp[
               5                      z_tmp(j)=z_df(j);
               5                      rhoz_tmp(j)=rhoz_df(j);
               5                      asym_tmp(j)=asym_df(j);
               5                      ]
               4                  spec_by_rhoz=.true.;
               4                  ]
               3              ]
               2          ELSE[
               3              $WRITE_MEDERR(' Composition specified in density correction file');
               3              nne_tmp=nne_df;
               3              DO j=1,nne_tmp[
               4                  z_tmp(j)=z_df(j);
               4                  rhoz_tmp(j)=rhoz_df(j);
               4                  asym_tmp(j)=asym_df(j);
               4                  ]
               3              spec_by_rhoz=.true.;
               3              elements_specified=.true.;
               3              ]
               2
               2          IF(rho_specified)[
               3              "check to see if rho read from density correction file matches"
               3              "that already input"
               3              IF(rho_df>(1+0.01)*rho_tmp | rho_df<(1-0.01)*rho_tmp)[
               4                  $WRITE_MEDERR(' Warning: rho specified in density correction',
               4                  ' file is not the same as that');
               4                  $WRITE_MEDERR(' specified in input or material data file.');
               4                  $WRITE_MEDERR(
               4                  ' Will use rho as specified in the density correction file.');
               4                  rho_tmp=rho_df;
               4                  df_if_rho_mismatch(i)=.true.;
               4                  ]
               3              ]
               2          ELSE[
               3              rho_tmp=rho_df;
               3              rho_specified=.true.;
               3              $WRITE_MEDERR(' Rho specified in density correction file');
               3              ]
               2
               2          IF(gasp_specified)[
               3              "any value of gasp other than 1 atm is incompatible with"
               3              "use of dcf and, since gasp is only used to scale rho when"
               3              "dcf is used, this input is now unecessary at best"
               3              $WRITE_MEDERR(' Warning: gas pressure input not required',
               3              ' when using density correction file.  Will set GASP=0.');
               3              gasp_specified=.false.;
               3              gasp_tmp=0.;
               3              ]
               2
               2          "close the density file"
               2          close(i_density);
               2          ]
               1
               1      "okay, now commit this to the media library"
               1      IF(elements_specified & rho_specified)[
               2
               2          ae(i)=ae_tmp;
               2          ue(i)=ue_tmp;
               2          ap(i)=ap_tmp;
               2          up(i)=up_tmp;
               2
               2          DO j=1,24[
               3              inpstrn(j,i) = sterncid_tmp(j:j);
               3              ]
               2
               2          nne(i)=nne_tmp;
               2          rho(i)=rho_tmp;
               2
               2          DO j=1,nne_tmp[
               3              inpasym(i,j)=asym_tmp(j);
               3              "assume we are getting z from asym"
               3              "redundant in the case where medium defined using"
               3              "density correction file"
               3              "ZTBL is a function defined in pegs4_routines.mortran"
               3              zelem(i,j)=ZTBL(asym_tmp(j));
               3              i01=zelem(i,j);
               3              "WATBL defined in pegs4_macros.mortran"
               3              wa(i,j)=WATBL(i01);
               3              wa4(i,j)=WATBL(i01);
               3              "also do $REAL4 math so we can check against cross-sections"
               3              "calculated by pegs4.mortran"
               3              IF(spec_by_rhoz)[
               4                  rhoz(i,j)=rhoz_tmp(j);
               4                  rhoz4(i,j)=rhoz_tmp(j);
               4                  pz(i,j)=rhoz(i,j)/wa(i,j);
               4                  pz4(i,j)=rhoz4(i,j)/wa4(i,j);
               4
               4                  ]
               3              ELSEIF(spec_by_pz)[
               4                  pz(i,j)=pz_tmp(j);
               4                  pz4(i,j)=pz_tmp(j);
               4                  rhoz(i,j)=pz(i,j)*wa(i,j);
               4                  rhoz4(i,j)=pz4(i,j)*wa4(i,j);
               4                  ]
               3              ]
               2
               2          iunrst(i)=iunrst_tmp;
               2          iaprim(i)=iaprim_tmp;
               2          epstfl(i)=epstfl_tmp;
               2          inpgasp(i)=gasp_tmp;
               2          inpdensity_file(i)=density_file;
               2
               2          ]
               1      ELSE[
               2          $WRITE_MEDERR(' Error: Medium ',medium_name,' not correctly defined.');
               2          ]
               1      ]
               0
               0  IF(medfile_specified) close(i_medfile);
               0
               0  IF(n_parallel=0 | i_parallel=first_parallel) close(i_mederr);
               0
               0
               0  entry show_media_parameters(ounit);
               0
               0  IF ( ounit <= 0 ) return;
               0
               0  IF(is_pegsless)[
               1
               1      "show common data"
               1
               1      write(ounit,*);
               1      write(ounit,*)' Medium data: ';
               1      write(ounit,*);
               1      write(ounit,'(a,1p,e14.5,a,e14.5,a)')' AE = ',ae(1),' MeV,  UE = ',ue(1),' MeV';
               1      write(ounit,'(a,1p,e14.5,a,e14.5,a)')' AP = ',ap(1),' MeV,  UP = ',up(1),' MeV';
               1      write(ounit,*);
               1      IF(medfile_specified)[
               2          write(ounit,*)' Material data file: ',material_file;
               2          ]
               1      ELSE[
               2          write(ounit,*)' No material data file supplied.  Material data obtained from';
               2          write(ounit,*)' .egsinp file or density correction file.';
               2          ]
               1      write(ounit,*);
               1
               1      "now list data for individual media that were successfully read in"
               1
               1      DO i=1,nmed[
               2
               2          write(ounit,'(a,24a1)')'   Medium: ',(media(j,i),j=1,24);
               2          write(ounit,'(a,24a1)')' Sterncid: ',(inpstrn(j,i),j=1,24);
               2          write(ounit,'(a,1p,e14.5,a)')'     rho: ',rho(i),' g/cm^3';
               2          write(ounit,'(a,24a4)')' Elements: ',(inpasym(i,j),j=1,nne(i));
               2          write(ounit,'(a,1p,12e14.5)')'    rhoz: ',(rhoz(i,j),j=1,nne(i));
               2          write(ounit,'(a,1p,12e14.5)')'      pz: ',(pz(i,j),j=1,nne(i));
               2          write(ounit,'(a,i5)')'  iunrst: ',iunrst(i);
               2          write(ounit,'(a,i5)')'  iaprim: ',iaprim(i);
               2          write(ounit,'(a,1p,e14.5,a)')'    gasp: ',inpgasp(i),' atm.';
               2          IF(epstfl(i)=1)[
               3              write(ounit,*)' density correction file: ',
               3              $cstring(inpdensity_file(i));
               3              IF(df_if_elem_mismatch(i))[
               4                  write(ounit,*)' ****Warning: composition specified in density correction',
               4                  ' file is not the same as that';
               4                  write(ounit,*)' specified in input or material data file.';
               4                  write(ounit,*)
               4                  ' Will use the composition specified in the density correction file.';
               4                  ]
               3              IF(df_if_rho_mismatch(i))[
               4                  write(ounit,*)' ****Warning: rho specified in density correction',
               4                  ' file is not the same as that';
               4                  write(ounit,*)' specified in input or material data file.';
               4                  write(ounit,*)
               4                  ' Will use rho as specified in the density correction file.';
               4                  ]
               3              ]
               2          write(ounit,*);
               2
               2          "output stopping powers to file for plotting if requested"
               2          IF(outfile_specified(i) & (n_parallel=0 | i_parallel=first_parallel)) [
               3              inquire(file=spoutput_file(i),exist=ex);
               3              IF(ex) [
               4                  $egs_warning('(a)','Warning: stopping power output file ',
               4                  spoutput_file(i),'already exists.  Will overwrite.');
               4                  ]
               3              i_outfile=20;
               3              i_outfile=egs_get_unit(i_outfile);
               3              IF(i_outfile < 1)[
               4                  $egs_warning('(a)','Warning: Failed to get available fortran unit for',
               4                  ' stopping power output file.');
               4                  ]
               3              open(i_outfile,file=spoutput_file(i),status='unknown',err=:no_output_file:);
               3              goto :got_outfile:;
               3              :no_output_file:
               3              $egs_warning('(a)','Warning: Failed to open stopping power output file ',
               3              spoutput_file(i));
               3              goto :end_outfile:;
               3              :got_outfile:
               3              IFLAG1=0;IFLAG2=0;IPLOTE=0;MEDIUM=i;
               3              XAXIS = 'kinetic energy / MeV';
               3              YAXISE = 'dE/drhoX MeV/g/cm\\S2\\N';
               3              YAXISEmfp = 'mean free path / cm';
               3              YAXISPmfp = 'mean free path / cm';
               3              write(GRAPHTITLE,'(24a1)')(media(j,i),j=1,24);
               3              SUBTITLE = 'Electron data';
               3              DO j=1,8[
               4                  DO k=1,16[
               5                      EKE=ETAB(k)*10.**(j-4);
               5                      IF(EKE <= AE(1)-PRM) [
               6                          IF(IFLAG1 = 0) [
               7                              IFLAG1=1; EKE=AE(1)-PRM;
               7                              ] ELSE [ EKE=0.0; ]
               6                          ]
               5
               5                      IF(EKE > UE(1)-PRM) [
               6                          IF(IFLAG2 = 0) [
               7                              IFLAG2=1; EKE=UE(1)-PRM;
               7                              ] ELSE [ EKE=1.E30; ]
               6                          ]
               5                      EIE=EKE+PRM;       TMXSO=0.0;        DEDXE=0.0;
               5                      DEDXP=0.0;           EFRACT=0.0;
               5                      IF(EIE >= AE(1)-0.0001 & EIE <= UE(1)+0.001) [
               6                          ELKE=LOG(EKE);
               6                          $SET INTERVAL ELKE,EKE;
               6                          $EVALUATE DEDXE USING EDEDX(ELKE);"RESTRICTED STOPPING POWERS"
               6
               6                          "enable below to plot other quantities"
               6
               6
               6
               6
               6
               6
               6
               6
               6
               6
               6
               6
               6
               6
               6
               6
               6                          IPLOTE=IPLOTE+1;   "keep track of how many entries"
               6                          PLOTEEN(IPLOTE)=EKE;
               6                          PLOTE(IPLOTE)=DEDXE/RHO(MEDIUM);
               6                          "enable below to plot other quantities
               6
               6
               6
               6
               6
               6
               6
               6
               6                          ]
               5                      ]
               4                  ]
               3              IF(IPLOTE>0)[
               4                  "currently only plots stopping powers"
               4                  IF(iunrst(i)=0) [
               5                      SERIES='restricted total stopping power';
               5                      ]
               4                  ELSEIF(iunrst(i)=1) [
               5                      SERIES='unrestricted collision stopping power';
               5                      ]
               4                  ELSEIF(iunrst(i)=2) [
               5                      SERIES='unrestricted collision + radiative stopping power';
               5                      ]
               4                  ELSEIF(iunrst(i)=3) [
               5                      SERIES='unrestricted collision + restricted radiative stopping power';
               5                      ]
               4                  ELSEIF(iunrst(i)=4) [
               5                      SERIES='restricted collision + unrestricted radiative stopping power';
               5                      ]
               4                  ELSEIF(iunrst(i)=5) [
               5                      SERIES='unrestricted radiative stopping power';
               5                      ]
               4                  CALL MEDXVGRPLOT(PLOTEEN,PLOTE,IPLOTE,0,SERIES,
               4                  XAXIS,YAXISE,GRAPHTITLE,SUBTITLE,i_outfile,2);
               4                  ]
               3              close(i_outfile);
               3              :end_outfile:
               3              ]
               2          ]
               1      ]
               0
               0  return;
               0  :no_media_file:
               0  $egs_fatal('(a)','Error: Cannot open material data file',material_file);
               0  return;
               0  :no_density_file:
               0  $egs_fatal('(a)','Error: Cannot open density correction file: ',
               0  $cstring(density_file));
               0  return;
               0  end;
               0  ;
               0
               0  "==========================end of get_inputs.mortran=================="
               0
               0  SUBROUTINE MEDXVGRPLOT (X, Y, NPTS, CURVENUM, SERIESTITLE,
               0  XTITLE, YTITLE, GRAPHTITLE, SUBTITLE,
               0  UNITNUM, AXISTYPE);
               0  "a version of XVGRPLOT specifically for plotting stopping powers and"
               0  "associated data.  Note that this is required because xvgrplot.mortran"
               0  "is not included at compile time for all user codes."
               0  IMPLICIT NONE;
               0
               0  COMIN/EGS-IO/;
               0
               0  $INTEGER MAX;
               0  PARAMETER (MAX = 400);  "---MAX used in defining the maximum number of---"
               0  "---points that can be plotted in one series. ---"
               0  $INTEGER NPTS,NPTS1,CURVENUM, COUNT,UNITNUM,TYPE,AXISTYPE;
               0  $REAL X(NPTS),Y(NPTS),ERRY(NPTS),YMIN,SMALLESTX,
               0  SMALLESTY,FUDGE;
               0  $INTEGER TITLELENGTH,SUBLENGTH,XAXISLENGTH,YAXISLENGTH,SERIESLENGTH;
               0  $INTEGER LOGX, LOGY;
               0  CHARACTER*(*) SUBTITLE;
               0  CHARACTER*(*) GRAPHTITLE,XTITLE,YTITLE,SERIESTITLE;
               0  $LOGICAL TESTFILE, ALLPOS;
               0
               0  FUDGE = 1.e-10;
               0
               0  IF ( NPTS .gt. MAX) [ "Asked for too many points"
               1      OUTPUT NPTS, MAX;(//' **************************'/
               1      ' Number of points asked for =', I5,
               1      ' is greater than max allowed of', I4/
               1      ' Setting NPTS to MAX, you could adjust MAX in xvgrplot.mortran'/
               1      ' **************************'//);
               1      NPTS1 = MAX;
               1      ] ELSE [NPTS1 = NPTS;]
               0
               0  INQUIRE(UNIT = UNITNUM, OPENED = TESTFILE);
               0
               0  IF (~TESTFILE) [ "---File has not been opened - print message.---"
               1      WRITE(6,:125:) UNITNUM;
               1      :125: FORMAT (//'  ---------Error in Subroutine XVGRPLOT---------'
               1      ,/'   Unit specified (',I2,') is not open.'
               1      ,/'   Unit must be opened before using subroutine.'
               1      ,/'   Data not written to file.'
               1      ,/'  ----------------------------------------------'//);
               1      RETURN;
               1      ] "---End of error message for unopened file---"
               0
               0
               0  TITLELENGTH = 61;    SUBLENGTH = 61;       XAXISLENGTH = 61;
               0  YAXISLENGTH = 61;    SERIESLENGTH = 61;
               0
               0  "---Find title string length---"
               0  LOOP [
               1      TITLELENGTH = TITLELENGTH - 1;
               1      ] UNTIL (GRAPHTITLE(TITLELENGTH:TITLELENGTH) ~= ' ');
               0
               0  "---Find subtitle string length---"
               0  LOOP [
               1      SUBLENGTH = SUBLENGTH - 1;
               1      ] UNTIL (SUBTITLE(SUBLENGTH:SUBLENGTH) ~= ' ');
               0
               0  "---Find x-axis string length---"
               0  LOOP [
               1      XAXISLENGTH = XAXISLENGTH - 1;
               1      ] UNTIL (XTITLE(XAXISLENGTH:XAXISLENGTH) ~= ' ');
               0
               0  "---Find y-axis string length---"
               0  LOOP [
               1      YAXISLENGTH = YAXISLENGTH - 1;
               1      ] UNTIL (YTITLE(YAXISLENGTH:YAXISLENGTH) ~= ' ');
               0
               0  "---Find series title length---"
               0  LOOP [
               1      SERIESLENGTH = SERIESLENGTH - 1;
               1      ] UNTIL (SERIESTITLE(SERIESLENGTH:SERIESLENGTH) ~= ' ');
               0
               0  "---Initialize LOGX, LOGY, to be not set (0)---"
               0  LOGX = 0;          LOGY = 0;
               0
               0  ALLPOS=.TRUE.;
               0  IF ( X(1)=0.0 ) [SMALLESTX = 0.1;] ELSE [SMALLESTX=X(1);]
               0  IF ( Y(1)=0.0 ) [SMALLESTY = 0.1;] ELSE [SMALLESTY=Y(1);]
               0  DO COUNT = 1, NPTS1 [
               1      IF ((X(COUNT) < SMALLESTX) & (X(COUNT)~=0.)) [SMALLESTX=X(COUNT);]
               1      IF ((Y(COUNT) < SMALLESTY) & (Y(COUNT)~=0.)) [SMALLESTY=Y(COUNT);]
               1      IF ((X(COUNT) < 0.)|(Y(COUNT) < 0.)) [ALLPOS=.FALSE.;]
               1      ]
               0  IF (ALLPOS) [
               1      DO COUNT = 1, NPTS1 [
               2          IF (X(COUNT)=0.) [X(COUNT)=SMALLESTX*FUDGE;]
               2          IF (Y(COUNT)=0.) [Y(COUNT)=SMALLESTY*FUDGE;]
               2          ]
               1      ]
               0
               0
               0  IF (AXISTYPE > 0) [  "---At least one axis is of log type---"
               1      DO COUNT = 1, NPTS1 [
               2          IF (X(COUNT) <= 0.) [ LOGX = 1; ]
               2          IF (Y(COUNT) <= 0.) [ LOGY = 1; ]
               2          ]
               1      ]
               0  "---Now begin writing information to unit---"
               0  IF (CURVENUM = 0) [ "---Case where plot file must start from scratch---"
               1      "---Insert xvgr graph header in file.---"
               1
               1      "---Start with type of graph.  (lin-lin, log-lin, lin-log, or log-log)---"
               1      IF (AXISTYPE = 0) [ "---Graph is of type lin-lin---"
               2          WRITE(UNITNUM,:90:) 'xy';
               2          ] ELSEIF (AXISTYPE = 1) [ "---Graph is of type log-lin---"
               2          WRITE(UNITNUM,:90:) 'logy';
               2          WRITE(UNITNUM,:1080:);
               2          ] ELSEIF (AXISTYPE = 2) [ "---Graph is of type lin-log---"
               2          WRITE(UNITNUM,:90:) 'logx';
               2          WRITE(UNITNUM,:1080:);
               2          ] ELSEIF (AXISTYPE = 3) [ "---Graph is of type log-log---"
               2          WRITE(UNITNUM,:90:) 'logxy';
               2          WRITE(UNITNUM,:1080:);
               2          WRITE(UNITNUM,:1090:);
               2          ] ELSE [ "--anything else specified is in error--"
               2          WRITE(6,:91:) AXISTYPE;
               2          :91: FORMAT (//'  ------------Error in Subroutine XVGRPLOT-----------'
               2          ,/'   AXISTYPE specified (',I2,') is not a valid option.'
               2          ,/'  ----------------------------------------------'//);
               2          RETURN;
               2          ]
               1      :90: FORMAT ('@g0 type ',A,' ');
               1      :1080: FORMAT ('@    xaxis  ticklabel format exponential');
               1      :1090: FORMAT ('@    yaxis  ticklabel format exponential');
               1
               1      "---Titles and things---"
               1      WRITE(UNITNUM,:100:) GRAPHTITLE(1:TITLELENGTH)
               1      ,SUBTITLE(1:SUBLENGTH)
               1      ,XTITLE(1:XAXISLENGTH)
               1      ,YTITLE(1:YAXISLENGTH);
               1      :100: FORMAT ('@    title "',A,'"'/
               1      ,'@    subtitle "',A,'"'/
               1      ,'@    legend on'/
               1      ,'@    legend box linestyle 0'/
               1      ,'@    legend x1 0.6'/
               1      ,'@    legend y1 0.75'/
               1      ,'@    view xmin 0.250000'/
               1      ,'@    xaxis  label "',A,'"'/
               1      ,'@    timestamp on'/
               1      ,'@    yaxis  label "',A,'"');
               1      ]  "---End CURVENUM = 0---"
               0
               0  IF (AXISTYPE = 1 & LOGY = 1) [  "--LOGY error--"
               1      WRITE(UNITNUM,:90:) 'xy';
               1      WRITE(6,:95:);
               1      :95: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
               1      ,/'  Log scale requested for Y axis when one or more   '
               1      ,/'  Y data points are 0 or negative.                  '
               1      ,//'  Y axis scale changed to linear.                   '
               1      ,/' ---------------------------------------------------'/);
               1      ]
               0
               0  IF (AXISTYPE = 2 & LOGX = 1) [  "--LOGX error--"
               1      WRITE(UNITNUM,:90:) 'xy';
               1      WRITE(6,:96:);
               1      :96: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
               1      ,/'  Log scale requested for X axis when one or more   '
               1      ,/'  X data points are 0 or negative.                  '
               1      ,//'  X axis scale changed to linear.                   '
               1      ,/' ---------------------------------------------------'/);
               1      ]
               0
               0  IF (AXISTYPE = 3 & (LOGX = 1 | LOGY = 1)) [  "--LOGX or LOGY error--"
               1      IF (LOGX = 1 & LOGY = 1) [
               2          WRITE(UNITNUM,:90:) 'xy';
               2          WRITE(6,:97:);
               2          :97: FORMAT (/' ----------WARNING from Subroutine XVGRPLOT---------'
               2          ,/'  Log scale requested for X axis and Y axis when    '
               2          ,/'  one or more X and Y data points are 0 or negative.'
               2          ,//'  X and Y axes scales changed to linear.            '
               2          ,/' ---------------------------------------------------'/);
               2          ]
               1      ELSEIF (LOGX = 1) [ WRITE(UNITNUM,:90:) 'logy'; WRITE(6,:96:); ]
               1      ELSE              [ WRITE(UNITNUM,:90:) 'logx'; WRITE(6,:95:); ]
               1      ]
               0
               0  IF (CURVENUM < 10 ) [
               1      WRITE(UNITNUM,'(''@    s'',I1,'' on'')') CURVENUM;
               1      ]
               0  ELSE [
               1      WRITE(UNITNUM,'(''@    s'',I2,'' on'')') CURVENUM;
               1      ]
               0  WRITE(UNITNUM,:150:)  CURVENUM,SERIESTITLE(1:SERIESLENGTH);
               0  :150: FORMAT ('@    legend string ',I2,' "',A,'"');
               0
               0
               0  "---Data set is of type XY---"
               0  WRITE(UNITNUM,:200:);
               0  :200: FORMAT ('@TYPE xy');
               0  IF (CURVENUM < 10) [
               1      WRITE(UNITNUM,:151:) CURVENUM;
               1      IF (CURVENUM = 9) [WRITE(UNITNUM,:197:) CURVENUM, CURVENUM+1;]
               1      ELSE [WRITE(UNITNUM,:198:) CURVENUM, CURVENUM+1;]
               1      ]
               0  ELSE [
               1      WRITE(UNITNUM,:152:) CURVENUM;
               1      WRITE(UNITNUM,:199:) CURVENUM, CURVENUM+1;
               1      ]
               0  :151: FORMAT ('@    s',I1,' errorbar length 0.000000');
               0  :152: FORMAT ('@    s',I2,' errorbar length 0.000000');
               0  :197: FORMAT ('@    s',I1,' symbol color ',I2);
               0  :198: FORMAT ('@    s',I1,' symbol color ',I1);
               0  :199: FORMAT ('@    s',I2,' symbol color ',I2);
               0
               0  "---Then write the data to the file.---"
               0  DO COUNT = 1, NPTS1 [ WRITE(UNITNUM,:250:) X(COUNT),Y(COUNT); ]
               0  :250: FORMAT (1PE15.4,1PE15.4);
               0
               0  "---Insert end of series indicator to file.---"
               0  WRITE(UNITNUM,'(''&'')');
               0
               0  RETURN;
               0  END;
               0  ;
               0  "---End of subroutine.---"
               0
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc pegs4 routines                                                      "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Blake Walters, 2013                                       "
               0  "                                                                             "
               0  "  Contributors:                                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The content of this file was adapted from the original pegs4 source code   "
               0  "  to enable on-the-fly pegs data generation in EGSnrc. Please see the pegs4  "
               0  "  sources for more information on the authorship of the original code.       "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  "Compiler directives"
               0  "==================="
               0  %Q1         "Automatically close comments at end of line                       ;
               0  "but NOTE, this doesn't happen inside a REPLACE macro
               0  "you must open and close within a REPLACE macro.
               0  %C80        "Allow 80 columns of source/line (default is 72)                   ;
               0  !INDENT M2; "Indent Mortran compile listing 2 spaces each nesting level
               0  !INDENT F2; "Indent fortran output 2 spaces each nesting level
               0  %L          "Turn on listing                                                   ;
               0  %I4 "INDENT FOUR SPACES EACH LEVEL"                                            ;
               0
1              0  %E
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE EFUNS(E,V);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  implicit none;
               0  ;
               0
               0  $REAL4 E,V(8);
               0
               0  " IK: Variable declarations for implicit none"
               0  $REAL4 BREM,AMOLL,BHAB,ANNIH,ESIG,PSIG;
               0
               0  " IK: Function declarations for implicit none"
               0  $REAL4 BREMTM,AMOLTM,BHABTM,ANIHTM,SPTOTE,SPTOTP,TMXS,THBREM;
               0
               0  "*****SUBROUTINE TO COMPUTE ELECTRON FUNCTIONS TO BE FIT           "
               0  "     IN A WAY THAT AVOIDS REPETITION.                             "
               0  COMIN/THRESHP,DERCON,EGS-IO/;
               0  THBREM=RMP+APP;"threshold for bremsstrahlung"
               0  IF(IUNRSTP.EQ.0 .OR. IUNRSTP.EQ.1 .OR. IUNRSTP.EQ.5)[
               1  "  REGULAR DATA SET OR"
               1  "   UNRESTRICTED COLLISIONAL(1) OR RADIATIVE(5) STOPPING POWERS"
               1  "write(58,*)' here e ',e;"
               1  BREM=BREMTM(E);
               1  AMOLL=AMOLTM(E);
               1  BHAB=BHABTM(E);
               1  ANNIH=ANIHTM(E);
               1  ESIG=BREM+AMOLL; "TOTAL ELECTRON CROSS-SECTION"
               1  V(1)=ESIG;
               1  PSIG=BREM+BHAB+ANNIH;"TOTAL POSITRON CROSS SECTION"
               1  V(2)=PSIG;
               1  V(3)=SPTOTE(E,AEP,APP); "TOTAL ELECTRON STOPPING POWER"
               1  V(4)=SPTOTP(E,AEP,APP);"TOTAL POSITRON STOPPING POWER"
               1  "EBR1=BREM/(BREM+AMOLL)"
               1  IF (ESIG.GT.0.0)[V(5)=BREM/ESIG;]
               1  ELSE["BELOW THRESHOLD FOR BOTH BREMS AND MOLLER. USE THE BRANCHING"
               2  "RATIO THAT EXISTED WHEN CROSS SECTION APPROACHED ZERO"
               2  IF (THBREM.LE.THMOLLP)[V(5)=1.0;]ELSE[V(5)=0.0;]
               2  ]
               1  V(6)=BREM/PSIG;"PBR1=BREM/(BREM+BHABA+ANNIH)"
               1  V(7)=(BREM+BHAB)/PSIG;"PBR2=(BREM+BHABA)/(PSIG)"
               1  "MAXIMUM ALLOWED TRANSPORT STEP, FROM MULTIPLE SCATTERING"
               1  V(8)=TMXS(E);
               1  "write(*,*)'v1,v2,v3,v4,v5,v6,v7,v8 ',v(1),v(2),v(3),v(4),v(5),v(6),v(7),v(8);"
               1  ]
               0  "  THE FOLLOWING ARE UNDOCUMENTED ADDITIONS"
               0  ELSEIF(IUNRSTP.EQ.2)[ "FULL CSDA DATA SET WITH NO DISCRETE INTERACTIONS"
               1  /V(1),V(2),V(5),V(6),V(7)/=0.0;
               1  "ZERO TOTAL CROSS SECTION FOR EL & POS, AND ZERO BRANCHING RATIOS"
               1  V(3) = SPTOTE(E,E,E);"  TOTAL UNRESTRICTED STOPPING POWER"
               1  V(4) = SPTOTP(E,E,E);
               1  V(8) = TMXS(E);]
               0  ELSEIF(IUNRSTP.EQ.3)["CONSIDER BREM AND ANNIHILATION IN FLIGHT AS"
               1  "     DISCRETE EVENTS BUT TREAT DELTAS IN CSDA"
               1  BREM=BREMTM(E);  ANNIH=ANIHTM(E);
               1  V(1)=BREM; "TOTAL X-SECTION IS JUST BREM"
               1  V(2)=BREM + ANNIH;"POSITRONS ALSO HAVE ANNIHILATION IN FLIGHT"
               1  V(3)=SPTOTE(E,E,APP);"UNRESTRICTED COLLISIONAL+RESTRICTED RADIATIVE"
               1  V(4)=SPTOTP(E,E,APP);"    ''                             ''    "
               1  V(5)=1.0;"ALL ELECTRON EVENTS ARE BREM EVENTS"
               1  V(6)=BREM/V(2);"FRACTION FOR POSITRONS WHICH IS BREM"
               1  V(7)=V(6);"FRACTION WHICH IS BREM + COLLISION(=0)"
               1  V(8)=TMXS(E);]
               0
               0  ELSEIF(IUNRSTP.EQ.4)["CREATE SECONDARIES BUT HAVE NO DISCRETE BREM OR"
               1  "ANNIHILATION IN FLIGHT"
               1
               1  V(1)=AMOLTM(E);"ONLY MOLLERS FOR ELECTRONS"
               1  V(2)=BHABTM(E);"ONLY BHABHA FOR POSITRONS"
               1  V(3)=SPTOTE(E,AEP,E);"RESTRICTED COLLISIONAL + UNRESTRICTED RADIATIVE"
               1  V(4)=SPTOTP(E,AEP,E);"         ''                         ''       "
               1  V(5)=0.0;"I.E. NEVER BREMS"
               1  V(6)=0.0;"I.E. NEVER BREMS"
               1  V(7)=1.0;"ALL BHABHA - NO ANNIHILATION"
               1  V(8)=TMXS(E);]
               0
               0  ELSE ["IUNRST=6 OR 7 NOT ALLOWED HERE"
               1  OUTPUT IUNRSTP; (//'*********IUNRST=',I4,' NOT ALLOWED BY EFUNS*****'/
               1  ' IUNRST=6 OR 7 ONLY ALLOWED WITH CALL OR PLTN OPTIONS'//);
               1  $CALL_EXIT(20);]
               0  RETURN;
               0  END; "END OF SUBROUTINE EFUNS"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BREMTM(E0);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4 E0,BREMRM;
               0  COMIN/THRESHP,DERCON/;
               0  IF (E0.LE.APP+RMP) [BREMTM=0.; ]
               0  ELSE [BREMTM=BREMRM(E0,APP,E0-RMP);]
               0  RETURN;
               0  END; "END OF FUNCTION BREMTM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BREMRM(E,K1,K2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4 E,K1,K2;
               0  $INTEGER I;
               0  $REAL4    BREMRZ;
               0  COMIN/MIXDAT/;
               0  BREMRM=0.;
               0  DO I=1,NEP [BREMRM=BREMRM+PZP(I)*BREMRZ(ZELEMP(I),E,K1,K2);]
               0  RETURN;
               0  END; "END OF FUNCTION BREMRM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BREMRZ(Z,E,K1,K2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL4 Z,E,K1,K2;
               0  EXTERNAL BREMFZ;
               0  $REAL4  DUMMY,BREMDZ,QD,BREMFZ;
               0  "     INITIALIZE BREMFZ                                                "
               0
               0  "    CHANGED"
               0
               0  "    CALL BREMDZ(Z,E,K1);"
               0
               0  "    TO"
               0
               0  "    DUMMY=BREMDZ(Z,E,K1);"
               0
               0  "    FOR SUN COMATIBILITY AFB 89/12/27"
               0  "write(58,*)'2 e ',e;"
               0  DUMMY=BREMDZ(Z,E,K1);
               0  BREMRZ=QD(BREMFZ,K1,K2,'BREMFZ');
               0  "write(58,*)'bremrz ',BREMRZ;"
               0  RETURN;
               0  END; "END OF FUNCTION BREMRZ"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BREMDZ(Z,E,K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL4    Z,E,K,BRMSDZ;
               0  "***ALL ENTRIES TO THIS FUNCTION GIVE THE CONTRIBUTION THAT ELEMENT Z"
               0  "   WOULD HAVE IF THERE WERE ONE PER MOLECULE.                      "
               0  "   ENTRIES STARTING WITH D DO THEIR OWN INITIALIZATION.             "
               0  "   ENTRIES STARTING WITH F RELY ON PREVIOUS D FOR INITIALIZATION.   "
               0  "   BREMDZ.. D-SIGMA/D-K FOR BREMS IN Z                              "
               0  "   BRMSDZ.. K*(D-SIGMA/D-K) FOR SOFT ENERGY LOSS FROM BREMS IN Z    "
               0
               0  "EVALUATES EQUATION 2.7.108 IN SLAC-265"
               0
               0  BREMDZ=BRMSDZ(Z,E,K)/K;
               0  "write(58,*)'bremdz,z,e,k ',BREMDZ,z,e,k;"
               0  RETURN;
               0  END;  "END OF FUNCTION BREMDZ"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BREMFZ(K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL4 K,BRMSFZ;
               0  BREMFZ=BRMSFZ(K)/K;
               0  "write(58,*)'bremfz ',BREMFZ;"
               0  RETURN;
               0  END;  "END OF FUNCTION BREMFZ"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BRMSFZ(K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4 K;
               0  $REAL4 EMKLOC,DELTA,SB1,SB2,EE;
               0  COMIN/LBREMZ/;
               0  EMKLOC=EBREMZ-K;
               0  IF(EMKLOC.EQ.0.0) [EMKLOC=1.E-25;]
               0  DELTA=DELC*K/EMKLOC;
               0  IF (DELTA.GE.DELTAM) [BRMSFZ=0.0;]
               0  ELSE [IF (DELTA.LE.1.)[
               2  SB1=20.867+DELTA*(-3.242+DELTA*0.625)-XLNZ;
               2  SB2=20.209+DELTA*(-1.930+DELTA*(-0.086))-XLNZ;]
               1  ELSE [SB1=21.12-4.184*LOG(DELTA+0.952)-XLNZ;
               2  SB2=SB1;]
               1  EE=EMKLOC/EBREMZ;
               1  BRMSFZ=CONST*((1.+EE*EE)*SB1-0.666667*EE*SB2);]
               0  "write(58,*)' const,ee,sb1,sb2,brmsfz ',const,ee,sb1,sb2,brmsfz;"
               0  RETURN;
               0  END; "END OF FUNCTION BRMSFZ"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION AMOLTM(E0);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4    E0;
               0  $REAL4    T0,AMOLRM;
               0  "***TOTAL CROSS SECTION FOR MOLLER SCATTERING WITH INCIDENT ELECTRON"
               0  "   ENERGY(TOTAL) OF E0."
               0  COMIN/THRESHP,DERCON/;
               0  IF (E0.LE.THMOLLP) [AMOLTM=0.; ]
               0  ELSE [T0=E0-RMP;
               1  AMOLTM=AMOLRM(E0,AEP,T0*0.5+RMP);] "EQ.2.10.6"
               0  RETURN;
               0  END; "END OF FUNCTION AMOLTM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION AMOLRM(EN0,EN1,EN2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4    EN0,EN1,EN2;
               0  $REAL4    T0,T1,T2,TM,EM,C1,C2,BETASQ,CMOLL2,EPS1,EPSP1,EPS2,EPSP2;
               0  "***MOLLER CROSS SECTION FOR INCIDENT ELECTRON OF TOTAL ENERGY EN0 TO"
               0  "   PRODUCE SECONDARY ELECTRON IN THE TOTAL ENERGY RANGE EN1 TO EN2."
               0  COMIN/PMCONS,MOLVAR,DERCON/;
               0  T0=EN0-RMP;
               0  T1=EN1-RMP;
               0  T2=EN2-RMP;
               0  TM=T0/RMP;
               0  EM=TM+1.;
               0  C1=(TM/EM)**2;
               0  C2=(2.*TM+1.)/EM**2;
               0  BETASQ=1.-1./EM**2;
               0  CMOLL2=RLCP*EDEN*2.*PIP*R0**2/(BETASQ*TM); "CONSTANT FACTOR IN EQ.2.10.3"
               0  EPS1=T1/T0;
               0  EPSP1=1.-EPS1;
               0  EPS2=T2/T0;
               0  EPSP2=1.-EPS2;
               0  AMOLRM=CMOLL2*(C1*(EPS2-EPS1)+1./EPS1-1./EPS2+1./EPSP2-1./EPSP1
               0    -C2*LOG(EPS2*EPSP1/(EPS1*EPSP2))); "EQ.2.10.3"
               0  RETURN;
               0  END; "END OF FUNCTION AMOLRM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BHABTM(E0);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***TOTAL CROSS SECTION FOR BHABHA SCATTERING WITH INCIDENT POSITRON"
               0  "   ENERGY(TOTAL) OF E0."
               0  ;
               0  implicit none;
               0  $REAL4 E0,BHABRM;
               0  COMIN/THRESHP/;
               0  IF (E0.LE.AEP) [BHABTM=0.;]
               0  ELSE [BHABTM=BHABRM(E0,AEP,E0);]  "EQ.2.11.4"
               0  RETURN;
               0  END; "END OF FUNCTION BHABTM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BHABRM(EN0,EN1,EN2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***BHABHA CROSS SECTION FOR INCIDENT POSITRON OF TOTAL ENERGY EN0 TO"
               0  "   PRODUCE SECONDARY ELECTRON IN THE TOTAL ENERGY RANGE EN1 TO EN2."
               0  ;
               0  implicit none;
               0  $REAL4 EN0,EN1,EN2;
               0  $REAL4 T0,T1,T2,TM,EM,Y,BETASI,CBHAB2,B1,B2,B3,B4,EPS1,EPS2;
               0  COMIN/PMCONS,MOLVAR,DERCON/;
               0  T0=EN0-RMP;
               0  T1=EN1-RMP;
               0  T2=EN2-RMP;
               0  TM=T0/RMP;
               0  EM=TM+1.;
               0  Y=1./(TM+2.);
               0  BETASI=1./(1.-1./EM**2);
               0  CBHAB2=RLCP*EDEN*2.*PIP*R0**2/TM; "CONSTANT FACTOR IN EQ.2.11.2"
               0  B1=2.-Y**2;
               0  B2=3.-Y*(6.-Y*(1.-Y*2.));
               0  B3=2.-Y*(10.-Y*(16.-Y*8.));
               0  B4=1.-Y*(6.-Y*(12.-Y*8.));
               0  EPS1=T1/T0;
               0  EPS2=T2/T0;
               0  BHABRM=CBHAB2*(BETASI*(1./EPS1-1./EPS2)-B1*LOG(EPS2/EPS1)
               0    +B2*(EPS2-EPS1)+EPS2*EPS2*(EPS2*B4/3.-0.5*B3)
               0    - EPS1*EPS1*(EPS1*B4/3.-0.5*B3));  "EQ.2.11.2"
               0  RETURN;
               0  END; "END OF FUNCTION BHABRM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION ANIHTM(E0);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***TOTAL CROSS SECTION FOR TWO-PHOTON POSITRON-ELECTRON ANNIHILATION"
               0  "   WITH INCIDENT POSITRON ENERGY(TOTAL) OF E0."
               0  ;
               0  implicit none;
               0  $REAL4    E0;
               0  $REAL4    GAM,P0P2,P0P,CANIH;
               0  COMIN/PMCONS,MOLVAR,DERCON/;
               0  GAM=E0/RMP;   "EQ.2.12.3"
               0  P0P2=GAM*GAM-1.0;
               0  P0P=SQRT(P0P2);  "EQ.2.12.6"
               0  CANIH=RLCP*EDEN*PIP*R0**2/(GAM+1.); "CONSTANT FACTOR IN EQ.2.12.14"
               0  ANIHTM=CANIH*((GAM*GAM+4.*GAM+1.)/P0P2*LOG(GAM+P0P)
               0     -(GAM+3.)/P0P);   "EQ.2.12.14"
               0  RETURN;
               0  END;  "END OF FUNCTION ANIHTM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION SPTOTP(E0,EE,EG);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "MODIFIED JAN 1989 DWOR AS SPTOTE                                  "
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4 E0,EE,EG;
               0  $REAL4 SPIONP,BRMSTM;
               0  COMIN/THRESHP/;
               0  IF (IUNRSTP.EQ.0) ["RESTRICTED TOTAL STOPPING POWER I.E. NORMAL"
               1                    SPTOTP=SPIONP(E0,EE)+BRMSTM(E0,EG);
               1  "write(*,*)' eo,ee,eg,spionp,brmstm ',e0,ee,eg,SPIONP(E0,EE),BRMSTM(E0,EG);"]
               0  ELSEIF(IUNRSTP.EQ.1)[SPTOTP=SPIONP(E0,E0);]"UNRESTRICTED COLLISION"
               0  ELSEIF(IUNRSTP.EQ.2)["UNRESTRICTED COLLISION AND RADIATIVE        "
               1                      SPTOTP=SPIONP(E0,E0)+BRMSTM(E0,E0);]
               0  ELSEIF(IUNRSTP.EQ.3)["UNRESTRICTED COLLISION +RESTRICTED RADIATIVE"
               1                      SPTOTP=SPIONP(E0,E0)+BRMSTM(E0,EG);]
               0  ELSEIF(IUNRSTP.EQ.4)["RESTRICTED COLLISION +UNRESTRICTED RADIATIVE"
               1                      SPTOTP=SPIONP(E0,EE)+BRMSTM(E0,E0);]
               0  ELSEIF(IUNRSTP.EQ.5)[SPTOTP=BRMSTM(E0,E0);]"UNRESTRICTED RADIATIVE"
               0  ELSEIF(IUNRSTP.EQ.6)[SPTOTP=BRMSTM(E0,EG);]"RESTRICTED RADIATIVE  "
               0  ELSEIF(IUNRSTP.EQ.7)[SPTOTP=SPIONP(E0,EE);]"RESTRICTED COLLISON   "
               0  RETURN;
               0  END;  "END OF FUNCTION SPTOTP"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION SPTOTE(E0,EE,EG);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  " patched DWOR, Jan 1988 to correct IURST=2,3,4 and add 6 and 7    "
               0  "******************************************************************"
               0  ;
               0  implicit none;
               0  $REAL4 E0,EE,EG;
               0  $REAL4 SPIONE,BRMSTM;
               0  COMIN/THRESHP/;
               0  IF (IUNRSTP.EQ.0) ["RESTRICTED TOTAL STOPPING POWER I.E. NORMAL"
               1                    SPTOTE=SPIONE(E0,EE)+BRMSTM(E0,EG);]
               0  ELSEIF(IUNRSTP.EQ.1)[SPTOTE=SPIONE(E0,E0);]"UNRESTRICTED COLLISION"
               0  ELSEIF(IUNRSTP.EQ.2)["UNRESTRICTED COLLISION AND RADIATIVE        "
               1                      SPTOTE=SPIONE(E0,E0)+BRMSTM(E0,E0);]
               0  ELSEIF(IUNRSTP.EQ.3)["UNRESTRICTED COLLISION +RESTRICTED RADIATIVE"
               1                      SPTOTE=SPIONE(E0,E0)+BRMSTM(E0,EG);]
               0  ELSEIF(IUNRSTP.EQ.4)["RESTRICTED COLLISION +UNRESTRICTED RADIATIVE"
               1                      SPTOTE=SPIONE(E0,EE)+BRMSTM(E0,E0);]
               0  ELSEIF(IUNRSTP.EQ.5)[SPTOTE=BRMSTM(E0,E0);]"UNRESTRICTED RADIATIVE"
               0  ELSEIF(IUNRSTP.EQ.6)[SPTOTE=BRMSTM(E0,EG);]"RESTRICTED RADIATIVE  "
               0  ELSEIF(IUNRSTP.EQ.7)[SPTOTE=SPIONE(E0,EE);]"RESTRICTED COLLISON   "
               0  RETURN;
               0  END;  "END OF FUNCTION SPTOTE"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION SPIONE(E0,EE);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL4 E0,EE,SPIONB;
               0  SPIONE=SPIONB(E0,EE,.FALSE.);
               0  RETURN;
               0  END;  "END OF FUNCTION SPIONE"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION SPIONB(E0,EE,POSITR);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***STOPPING POWER FOR AN ELECTRON.  THIS FUNCTION ALSO HAS OTHER    "
               0  "   ENTRY POINTS. . .                                                "
               0  "   SPIONP(E0,EE) - STOPPING POWER FOR A POSITRON                    "
               0  "   SPINIT(MEDIUM) - DOES INITIALIZATION FOR THE OTHER ENTRY POINTS  "
               0  "   WHENEVER THE MEDIUM CHANGES.                                     "
               0  "   THIS FUNCTION IS FOR STOPPING POWER DUE TO COLLISIONS WITH LESS  "
               0  "   THAN EE-RM ENERGY TRANSFER AND DOES NOT INCLUDE SOFT BREMS LOSS. "
               0  "   WE USE BERGER AND SELTZER'S FORMULATION.                         "
               0  "   STOPPING POWER IS RETURNED IN UNITS OF MEV/R.L.                  "
               0  ;
               0  implicit none;
               0  $REAL4   E0,EE;
               0  LOGICAL POSITR;
               0  $REAL4   G,EEM,T,ETA2,BETA2,ALETA2,X,D,FTERM,TP2,D2,D3,D4,DELTA;
               0  $INTEGER I;
               0  COMIN/DERCON,LSPION,EPSTAR/; "MOD NOV 24,1988"
               0  "     COMMON POINT FOR E- AND E+ ENTRIES.                              "
               0  G=E0/RMP;
               0  EEM=EE/RMP-1.;
               0  "     T IS BERGER'S TAU                                                "
               0  T=G-1;
               0  ETA2=T*(G+1.);
               0  BETA2=ETA2/G**2;
               0  ALETA2=LOG(ETA2);
               0  X=0.21715*ALETA2;
               0  "     0.21715=ALOG10(E)/2.   THIS FACTOR IS BECAUSE THE DEFINITION OF  "
               0  "     X IS ALOG10(P/(MC)) AND ETA2=ETA**2=(P/MC)**2                    "
               0  IF (.NOT.POSITR)["THIS IS ELECTRON CASE"
               1  "     COMPUTE F-TERM FOR ELECTRON.  MAXIMUM TRANSFER IS T/2            "
               1  "     D IS BERGER'S CAPITOL DELTA.                                     "
               1  D=AMIN1(EEM,0.5*T);
               1  "     EEM IS DEFINED AS EE/RM-1 IS ENERGY TRANSFER THRESHOLD FOR       "
               1  "     DISCRETE MOLLER AND BHABHA SCATTERING(IN UNITS OF RM.)           "
               1  FTERM=-1.-BETA2+LOG((T-D)*D)+T/(T-D)
               1    +(D*D/2.+(2.*T+1.)*LOG(1.-D/T))/(G*G);]
               0  "     COMPUTE F-TERM FOR POSITRON.  MAXIMUM TRANSFER IS T.             "
               0  ELSE ["THIS IS POSITRON CASE"
               1  D=AMIN1(EEM,T);
               1  TP2=T+2.;
               1  D2=D*D;
               1  D3=D*D2;
               1  D4=D*D3;
               1  FTERM=LOG(T*D)-(BETA2/T)*( T + 2.*D - (3.*D2/2.)/TP2
               1   -(D-D3/3.)/(TP2*TP2)-(D2/2.-T*D3/3.+D4/4.)/TP2**3);]
               0
               0  "     NOW COMPUTE THE DENSITY CORRECTION TERM.                         "
               0
               0  IF(EPSTFLP = 0) ["USE STANDARD PEGS4 METHOD"
               1  IF (X.LE.X0) [DELTA=0.0;]
               1  ELSEIF (X.LT.X1) [DELTA=TOLN10*X - CBAR + AFACT*(X1 - X)**SK;]
               1  ELSE [DELTA=TOLN10*X - CBAR;]]
               0
               0  ELSE ["USE LINEAR INTERPOLATION OF USER SUPPLIED INPUT TABLE"
               1
               1  "IEPST IS A POINTER SUCH THAT                              "
               1  "       EPSTEN(IEPST) <= E0 < EPSTEN(IEPST+1)              "
               1  "                                                          "
               1  "IEPST IS INITIALIZED IN BLOCK DATA TO 1. WE START FROM    "
               1  "THE PREVIOUS VALUE OF THE POINTER SINCE WE ASSUME THAT    "
               1  "THE CODE IS WORKING UP OR DOWN A GRID.                    "
               1  "  THIS CODING IS FAR FROM OPTIMAL                         "
               1
               1  IF(E0 >= EPSTEN(IEPST))["AT OR ABOVE PREVIOUS ENTRY"
               2  IF(E0 = EPSTEN(IEPST))["FOUND ENTRY, INCLUDING THE POSSIBILITY"
               3  "THAT WE ARE AT THE TOP OF THE TABLE"     GO TO :END-SEARCH:;]
               2
               2  DO I= IEPST,NEPST-1 [
               3       IF(E0<EPSTEN(I+1))["WE FOUND IT" IEPST = I; GO TO :END-SEARCH:]
               3       ]
               2  "IF WE FALL THRU TO HERE, WE MUST BE AT UPPER ENERGY"
               2  IEPST = NEPST; GO TO :END-SEARCH:;
               2  ]"END OF BLOCK E0>EPSTEN(IEPST)"
               1
               1  ELSE [ "E0<EPSTEN(IEPST)"
               2
               2  DO I = IEPST,2,-1 [
               3      IF(E0 >= EPSTEN(I-1)) [IEPST = I-1; GO TO :END-SEARCH:;]
               3      ]
               2  "   IF WE GET HERE WE MUST BE IN THE FIRST REGION"
               2      IEPST = 1;]
               1
               1  :END-SEARCH:
               1
               1  "NOW JUST INTERPOLATE LINEARLY IN THE ENERGY"
               1  IF(IEPST < NEPST) [
               2     DELTA = EPSTD(IEPST) + (E0 - EPSTEN(IEPST))/
               2     (EPSTEN(IEPST+1) - EPSTEN(IEPST)) * (EPSTD(IEPST+1) - EPSTD(IEPST));]
               1  ELSE [DELTA = EPSTD(NEPST);]
               1
               1  ]"END OF EPSTFL NON-ZERO BLOCK"
               0
               0  "     NOW PUT IT ALL TOGETHER                                          "
               0  SPIONB=(SPC1/BETA2)*(LOG(T + 2.) - SPC2 + FTERM - DELTA);
               0  RETURN;
               0  END;  "END OF FUNCTION SPIONB"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION SPIONP(E0,EE);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL4 E0,EE,SPIONB;
               0  SPIONP=SPIONB(E0,EE,.TRUE.);
               0  RETURN;
               0  END;  "END OF FUNCTION SPIONP"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BRMSTM(E0,EG);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4 E0,EG,BRMSRM,AU,zero;
               0  parameter (zero=0);
               0  COMIN/DERCON/;
               0  IF (E0.LE.RMP) [BRMSTM=0.; ]
               0  ELSE [AU=AMIN1(EG,E0-RMP);
               1  BRMSTM=BRMSRM(E0,zero,AU);
               1  "write(*,*)'au,e0,brmsrm ',au,e0,BRMSRM(E0,zero,AU);"
               1  ]
               0  RETURN;
               0  END; "END OF FUNCTION BRMSTM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BRMSRM(E,K1,K2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  ;
               0  implicit none;
               0  $REAL4 E,K1,K2,BRMSRZ;
               0  $INTEGER I;
               0  COMIN/MIXDAT/;
               0  BRMSRM=0.;
               0  DO I=1,NEP[BRMSRM=BRMSRM+PZP(I)*BRMSRZ(ZELEMP(I),E,K1,K2);
               1  "write(*,*)'i,e,k1,k2,pz,brmsrz ',i,e,k1,k2,PZ(i_med,I),"
               1  "BRMSRZ(ZELEM(i_med,I),E,K1,K2);"]
               0  RETURN;
               0  END; "END OF FUNCTION BRMSRM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BRMSRZ(Z,E,K1,K2);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL4 Z,E,K1,K2;
               0  EXTERNAL BRMSFZ;
               0  $REAL4 DUMMY,BRMSDZ,QD,BRMSFZ;
               0  "     INITIALIZE BRMSFZ                                                "
               0
               0  "    CHANGED"
               0
               0  "    CALL BRMSDZ(Z,E,K1);"
               0
               0  "    TO"
               0
               0  "    DUMMY=BRMSDZ(Z,E,K1);"
               0
               0  "    FOR SUN COMATIBILITY AFB 89/12/27"
               0  "write(58,*)' e ',e;"
               0  DUMMY=BRMSDZ(Z,E,K1);
               0  BRMSRZ=QD(BRMSFZ,K1,K2,'BRMSFZ');
               0  "write(58,*)'brmsrz ',BRMSRZ;"
               0  RETURN;
               0  END; "END OF FUNCTION BRMSRZ"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION BRMSDZ(Z,EA,K);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4 Z,EA,K;
               0  $REAL4 APRIM,XSIFP,FCOULCP,BRMSFZ;
               0  COMIN/PMCONS,DERCON,MOLVAR,LBREMZ/;
               0  EBREMZ=EA;
               0  DELC=136.*Z**(-1./3.)*RMP/EBREMZ;
               0  CONST=APRIM(Z,EBREMZ)*(AN*RHOP/WM)*R0**2*FSC*Z*(Z+XSIFP(Z))*RLCP;
               0  "write(58,*)' z,ebremz,an,rho,wm,r0,fsc,xsif,rlc,aprim ',z,ebremz,an,rhop,"
               0  "wm,r0,fsc,xsifp(z),RLCP,APRIM(Z,Ebremz);"
               0  XLNZ=4./3.*LOG(Z);
               0  IF (EBREMZ.GE.50)XLNZ=XLNZ+4.*FCOULCP(Z);
               0  ".....DELTAM IS THE DELTA AT WHICH THE SQUARE BRACKETS GO TO ZERO      "
               0  DELTAM=EXP((21.12-XLNZ)/4.184)-0.952;
               0  BRMSDZ=BRMSFZ(K);
               0  RETURN;
               0  END;  "END OF FUNCTION BRMSDZ"
               0
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION APRIM(Z,E);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "     EMPIRICAL CORRECTION FACTOR TO BREMS CROSS SECTION               "
               0
               0  " This version can be switched to use different values:                "
               0  "   IAPRIM = 0  equivalent to old PEGS4 (default)                      "
               0  "            1  reads in values from unit 22                           "
               0  "            2  sets APRIM to 1.0                                      "
               0  " Future changes can be accommodated by reading in                     "
               0  " different data on unit 22 and if necessary changing the array sizes: "
               0
               0  ;
               0  implicit none;
               0  $REAL4 Z,E;
               0  $INTEGER  napre,naprz,ie,iz,aprim_unit,egs_get_unit,lnblnk1;
               0  $REAL4     EM,AINTP;
               0  character  aprim_file*256;
               0  REPLACE {$NAPRE} WITH {115} " Maximum number of energies ( > 18 )      "
               0  REPLACE {$NAPRZ} WITH {14}  " Maximum number of elements ( > 5 )       "
               0
               0  REPLACE {$NAPR1} WITH {{COMPUTE $NAPRE - 18}}
               0  REPLACE {$NAPR2} WITH {{COMPUTE $NAPRZ - 5}}
               0  REPLACE {$NAPR3} WITH {{COMPUTE $NAPRE * $NAPR2}}
               0  ;COMIN/DERCON,EPSTAR,EGS-IO/; "NRC CHANGE NOV 88"
               0  $REAL4 APRIMD($NAPRE,$NAPRZ),EPRIM($NAPRE),ZPRIM($NAPRZ),APRIMZ($NAPRE);
               0  DATA APRIMD/
               0  1.32,1.26,1.18,1.13,1.09,1.07,1.05,1.04,1.03, 1.02,8*1.0,$NAPR1*0.0,
               0  1.34,1.27,1.19,1.13,1.09,1.07,1.05,1.04,1.03,1.02, 8*1.0,$NAPR1*0.0,
               0  1.39,1.30,1.21,1.14,1.10,1.07,1.05,1.04,1.03,1.02,0.994,
               0   2*0.991,0.990,2*0.989,2*0.988,$NAPR1*0.0,
               0  1.46,1.34,1.23,1.15,1.11,1.08, 1.06,1.05,1.03,1.02,0.989,
               0   0.973,0.971,0.969,0.967,0.965,2*0.963,$NAPR1*0.0,
               0  1.55,1.40,1.26,1.17,1.12,1.09,1.07,1.05,1.03,1.02,0.955,0.935,
               0   0.930,0.925,0.920,0.915,2*0.911,$NAPR1*0.0,
               0  $NAPR3*0.0/,
               0  EPRIM /
               0  2.,3.,4.,5.,6.,7.,8.,9.,10.,11.,21.,31.,41.,51.,61.,71.,81.,91.,
               0  $NAPR1*0.0/,
               0  ZPRIM /6.,13.,29.,50.,79.,$NAPR2*0.0/;
               0  save APRIMD,EPRIM,ZPRIM,APRIMZ,napre,naprz;
               0
               0  IF (IAPRIMP.EQ.0) [ " PEGS4 default APRIM"
               1      IF(IAPRFL = 0)[IAPRFL=1;
               2
               2
               2
               2
               2
               2      ]
               1      IF (E.GE.50) [ APRIM=1.; ]
               1      ELSE [ " INTERPOLATE APRIM OVER Z "
               2          EM=E/RMP;
               2          DO IE=1,18[
               3             APRIMZ(IE)=
               3             AINTP(Z,ZPRIM,5,APRIMD(IE,1),$NAPRE,.FALSE.,.FALSE.);
               3             ] " Z INTERPOLATION IS NOW COMPLETE. NOW DO ENERGY "
               2          APRIM=AINTP(EM,EPRIM,18,APRIMZ,1,.FALSE.,.FALSE.);
               2      ]
               1  ]
               0  ELSEIF (IAPRIMP.EQ.1) [
               1      IF (IAPRFL.EQ.0) [ " read in data from APRIME.DATA"
               2
               2
               2
               2
               2          aprim_file = $cstring(hen_house) // 'pegs4' // $file_sep //
               2                       'aprime.data';
               2          aprim_unit=22;" want unit 22"
               2          aprim_unit=egs_get_unit(aprim_unit);
               2          IF( aprim_unit < 1 ) [
               3               $egs_fatal(*,'APRIM: failed to get a free fortran unit');
               3          ]
               2          open(aprim_unit,file=aprim_file,status='old',err=:no_aprim_file:);
               2
               2          READ(aprim_unit,*) NAPRZ, NAPRE;
               2          IF (NAPRZ.GT.$NAPRZ) [
               3              OUTPUT; (//,' TOO MANY ELEMENTS FOR APRIME INTERPOLATION:',
               3              /,'   CHANGE $NAPRZ AND RECOMPILE PEGS'); $CALL_EXIT(24);]
               2          IF (NAPRE.GT.$NAPRE) [
               3              OUTPUT; (//,' TOO MANY ENERGIES FOR APRIME INTERPOLATION:',
               3              /,'   CHANGE $NAPRE AND RECOMPILE PEGS'); $CALL_EXIT(24);]
               2          READ(aprim_unit,*) (EPRIM(IE),IE=1,NAPRE);
               2          DO IE=1,NAPRE [ EPRIM(IE)=1.+EPRIM(IE)/RMP; ]
               2          DO IZ=1,NAPRZ [READ(aprim_unit,*)ZPRIM(IZ),(APRIMD(IE,IZ),IE=1,NAPRE);]
               2          IAPRFL=1;
               2          close(aprim_unit);
               2          ]
               1      EM=E/RMP;
               1      DO IE=1,NAPRE [ " INTERPOLATE APRIM OVER LOG(Z)  "
               2          APRIMZ(IE)=
               2          AINTP(Z,ZPRIM,NAPRZ,APRIMD(IE,1),$NAPRE,.TRUE.,.FALSE.);
               2          ]           " NOW DO ENERGY INTERPOLATION     "
               1      APRIM=AINTP(EM,EPRIM,NAPRE,APRIMZ,1,.FALSE.,.FALSE.);
               1      ]
               0  ELSEIF (IAPRIMP.EQ.2) [
               1          IF(IAPRFL = 0)[IAPRFL=1;
               2
               2
               2
               2
               2          ]
               1          APRIM=1.0]
               0  ELSE [ OUTPUT IAPRIMP; (//,' ILLEGAL VALUE FOR IAPRIM: ',I4);
               1         $CALL_EXIT(24); ]
               0  RETURN;
               0  :no_aprim_file:
               0  $egs_fatal(*,'Cannot open file $HEN_HOUSE/pegs4/aprime.data');
               0  RETURN;
               0  END; "END OF FUNCTION APRIM"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION AINTP(X,XA,NX,YA,ISK,XLOG,YLOG);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  implicit none;
               0
               0  "     LINEAR OR LOG INTERPOLATION FUNCTION.                          "
               0
               0  "CHANGED"
               0  "REAL XA(1),YA(ISK,1);"
               0  "TO"
               0  "REAL XA(NX),YA(ISK,NX);"
               0  "FOR SUN AFB 89/12/27"
               0
               0  $INTEGER NX,ISK;
               0  $REAL4    X;
               0  $REAL4    XA(NX),YA(ISK,NX);
               0  LOGICAL XLOG,YLOG,XLOGL;
               0
               0  $INTEGER I,J;
               0  $REAL4    XI,XJ,XV,YI,YJ;
               0  XLOGL=XLOG;  "SET LOCAL VARIABLE"
               0  "     FIND INTERVAL FOR X INTERPOLATION.                             "
               0  DO J=2,NX[
               1  IF (X.LT.XA(J))GO TO :NSTEP:;]
               0  J=NX;
               0  :NSTEP:    I=J-1;
               0  IF (XA(I).LE.0.0) [XLOGL=.FALSE.;]
               0  IF (.NOT.XLOGL)[ XI=XA(I); XJ=XA(J); XV=X;]
               0  ELSE [XI=LOG(XA(I)); XJ=LOG(XA(J)); XV=LOG(X);]
               0  IF (YLOG.AND.(YA(1,I).EQ.0.0.OR.YA(1,J).EQ.0.0))
               0     [AINTP=0.0;]
               0  ELSE[
               1      IF(YLOG)[YI=LOG(YA(1,I));YJ=LOG(YA(1,J));
               2      IF(XJ.EQ.XI) [AINTP=YI;]
               2      ELSE [AINTP=(YI*(XJ-XV)+YJ*(XV-XI))/(XJ-XI);]
               2      AINTP=EXP(AINTP);]
               1      ELSE[YI=YA(1,I); YJ=YA(1,J);
               2           IF(XJ.EQ.XI) [AINTP=YI;]
               2           ELSE [AINTP=(YI*(XJ-XV)+YJ*(XV-XI))/(XJ-XI);]]
               1  ]
               0  RETURN;
               0  END; "END OF FUNCTION AINTP"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION TMXS(E);"MAXIMUM STEP SIZE VALID FOR MULTIPLE SCATTERING"
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL4 E,TMXB;
               0  $REAL4 SAFETY,TABSMX;
               0  DATA SAFETY/0.8/,TABSMX/10.0/;
               0  save SAFETY,TABSMX;
               0  TMXS=AMIN1(TMXB(E)*SAFETY,TABSMX);
               0  "THE FACTORE 'SAFETY' IS TO KEEP SOMEWHAT BELOW BETHE'S LIMIT"
               0  "TABSMX IS AN ABSOLUTE LIMIT TO SIZE OF ELECTRON TRANSPORT,"
               0  "  INDEPENDENT OF THE MULTIPLE SCATTERING LIMIT"
               0  RETURN;
               0  END;  "END OF FUNCTION TMXS"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION TMXB(E);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  $REAL4 E;
               0  "THIS FUNCTION FINDS THE TRANSPORT DISTANCE WHICH AT THIS ENERGY"
               0  "IS THE LARGEST CONSISTENT WITH BETHE'S CRITERION, NAMELY"
               0  "  XC**2*B.LE.1;   SINCE XC ANB B ARE INCREASING FUNCTIONS OF T"
               0  " THE TRANSPORT DISTANCE, THE CRITERION FOR TMXB IS THEN"
               0  "  XC**2*B=1;      OTHER RELATIONS USED IN THE DERIVATION ARE"
               0  "EXPLAINED IN SUBROUTINES MIX AND MOLIER.  THEY ARE:"
               0  "  XC=XCC*SQRT(T)/(E*BETA**2); "
               0  "  EXP(B)/B = BLCC*T/BETA**2;  "
               0  "FROM THESE IS DERIVED THE EQUATION THIS FUNCTION IS BASED ON:"
               0  "TMXB=(E**2*BETA**2/XCC**2)*BETA**2/LOG(BLCC*(E**2*BETA**2/XCC**2));"
               0  ;
               0  $REAL4 ESQ,BETA2,PX2;
               0  COMIN/DERCON,MOLVAR/;
               0  ESQ=E**2;
               0  BETA2=1.0-RMPSQ/ESQ;
               0  PX2=ESQ*BETA2/XCCP**2;
               0  TMXB=PX2*BETA2/LOG(BLCCP*PX2);
               0  RETURN;
               0  END;   "END OF FUNCTION TMXB"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION ALKE(E);"LOG OF KINETIC ENERGY"
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4 E;
               0  COMIN/DERCON/;
               0  ALKE=LOG(E-RMP);
               0  "write(58,*)' alke,e,rm,e-rm ',alke,e,rmp,e-rmp;"
               0  RETURN;
               0  END;  "END OF FUNCTION ALKE"
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION ALKEI(X);"INVERSE OF LOG OF KINETIC ENERGY"
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  $REAL4 x;
               0  COMIN/DERCON/;
               0  ALKEI=EXP(X) + RMP;
               0  RETURN;
               0  END;  "END OF FUNCTION ALKEI"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE PWLF1(NI,NIMX,XL,XU,XR,EP,ZTHR,ZEP,NIP,XFUN,XFI,
               0                   AX,BX,NALM,NFUN,AF,BF,VFUNS);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  "***PWLF1 IS A ROUTINE WHICH WILL FIT UP TO 10(CURRENTLY) FUNCTIONS  "
               0  "   SIMULTANEOUSLY ON AN INTERVAL (XL,XU) OF THE INDEPENDENT VARIABLE"
               0  "   X OF THE FUNCTIONS. THE FIT IS A PIECEWISE LINEAR FUNCTION OF    "
               0  "   XFUN(X).  XFI IS THE INVERSE FUNCTION OF XFUN.  THE SUBINTERVALS "
               0  "   ARE CHOSEN OF UNIFORM WIDTH IN XFUN(X) AND SUFFICIENT OF THEM    "
               0  "   ARE CHOSEN SO THAT THE FIT GIVES A RELATIVE ERROR[EP FOR ALL     "
               0  "   THE FUNCTIONS OVER ALL THE SUBINTERVALS.                         "
               0  "   QFIT IS AN AUXILIARY FUNCTION.       "
               0  "   EXPLANATION OF THE ARGUMENTS:                                    "
               0  "   NI   ON RETURN IS NUMBER OF SUBINTERVALS USED FOR THE FIT.       "
               0  "   XL   LOWER LIMIT OF INTERVAL ON WHICH TO FIT THE FUNCTIONS.      "
               0  "   XU   UPPER LIMIT                                                 "
               0  "   XR   VALUE OF X WHICH WILL BE FORCED TO BE A SUBINTERVAL BOUNDARY"
               0  "        THE SIGNIFICANCE OF THIS IS THAT THE STRAIGHT LINES ON THE  "
               0  "        SUBINTERVALS ARE CHOSEN TO FIT EXACTLY AT THE SUBINTERVAL   "
               0  "        BOUNDARIES, THUS IF ONE WANTS AN EXACT FIT OF THE FUNCTIONS "
               0  "        AT A PARTICULAR POINT, XR SHOULD BE SET TO THAT VALUE.      "
               0  "        OTHERWISE XR SHOULD BE SET TO XH.  ANOTHER REQUIREMENT      "
               0  "        IS THAT XU SHOULD BE LARGER THAN XL.                        "
               0  "   EP   THE MAXIMUM RELATIVE ERROR ALLOWED THE FIT.                 "
               0  "   NIP  THE MINUIMUM NUMBER OF POINTS INTERIOR TO (XL,XU) AT WHICH  "
               0  "        THE FIT IS TO BE TESTED FOR RELATIVE ERROR VS. EP.          "
               0  "   XFUN A FUNCTION OF X OVER WHICH IT IS HOPED THE FUNCTIONS TO BE  "
               0  "        FIT ARE MORE LINEAR THAN OVER X.  XFUN IS EXPECTED TO BE    "
               0  "        MONOTONICALLY INCREASING IN X.                              "
               0  "   XFI  THE INVERSE OF XFUN. THAT IS XFI(XFUN(X))=X.                "
               0  "   AX,BX ARE COEFFICIENTS USED AS SHOWN BELOW TO DETERMINE WHICH    "
               0  "        SUBINTERVAL A VALUE OF X IS IN.                             "
               0  "   AF,BF ARE ARRAYS OF COEFFICIENTS USED TO GET VALUES OF THE FUNCS."
               0  "   THE PROCEDURE FOR FINDING THE FIT VALUE OF FUNCTION IFUN IS:     "
               0  "   INTERV=AX*XFUN(X)+BX                                             "
               0  "   VALUE=AF(INTERV,IFUN)*XFUN(X)+BF(INTERV,IFUN)                    "
               0  "   NALM  IS THE MAXIMUM NUMBER OF SUBINTERVALS FOR WHICH ARRAY SPACE"
               0  "         HAS BEEN ALLOCATED.                                        "
               0  "   NFUN  IS THE NUMBER OF FUNCTIONS TO BE FITTED(SIMULTANEOUSLY,I.E."
               0  "         ALL FUNCTIONS HAVE THE SAME XFUN AND SUBINTERVALS, AND ALL "
               0  "         ARE REQUIRED TO BE FIT WITH MAX REL ERR[EP)                "
               0  "   VFUNS IS A SUBROUTINE TO FILL AN ARRAY WITH THE VALUES OF THE    "
               0  "   FUNCTIONS TO BE FITTED.                                          "
               0  ;
               0  implicit none;
               0
               0  COMIN/EGS-IO/;
               0
               0  $INTEGER NI,NIMX,NIP,NALM,NFUN;
               0  $REAL4    XL,XU,XR,EP,AX,BX,XFUN,XFI;
               0  EXTERNAL XFI,VFUNS,XFUN;
               0  $REAL4 AF(NALM,NFUN),BF(NALM,NFUN),ZTHR(NFUN),ZEP(NFUN);
               0  "   QFIT IS A LOGICAL FUNCTION WHICH IS TRUE IF THE STATED NUMBER    "
               0  "   OF INTERVALS GIVES A SUFFICIENTLY CLOSE FIT.                     "
               0  LOGICAL QFIT;
               0
               0  " IK: Variable declarations for implicit none"
               0  $INTEGER NL,NU,IPRN,NJ,NK;
               0  $REAL4    REM;
               0  "   FIND # OF INTERVALS REQUIRED.                                    "
               0  NL=0;
               0  NU=1;
               0  IPRN=0;
               0  LOOP [NJ=MIN0(NU,NIMX);
               1  "write(58,*)' 1 nj ',nj;"
               1  IF (QFIT(NJ,XL,XU,XR,EP,ZTHR,ZEP,REM,NIP,XFUN,XFI,
               1   AX,BX,NALM,NFUN,AF,BF,VFUNS,0)) EXIT;
               1  IF (NU.GE.NIMX) [
               2
               2
               2
               2
               2
               2  "write(58,*)' nj ',nj;"
               2  NI=NJ;RETURN;]
               1  NL=NU;
               1  NU=NU*2;]
               0  "   WE NOW HAVE AN UPPER AND LOWER LIMIT ON NI, REFINE IT.           "
               0  NU=NJ ; "SAVE SUCCESSFUL INDEX"
               0  WHILE(NU.GT.NL+1)["LOOP UNTIL CONVERGENCE"
               1  NJ=(NL+NU)/2;
               1  NK=NJ; "THIS IS NECESSARY BECAUSE QFIT MAY LOWER NJ,BUT NEED ORIGINAL"
               1  " FOR SETTING NL OR MAY GET INTO INFINITE LOOP."
               1  IF (QFIT(NJ,XL,XU,XR,EP,ZTHR,ZEP,REM,NIP,XFUN,XFI,
               1  AX,BX,NALM,NFUN,AF,BF,VFUNS,0))[NU=NJ;]ELSE[NL=NK;]
               1  ]
               0  "     NU IS NOW THE SMALLEST NI WHICH FITS OK.                       "
               0  NI=NU;
               0  IF (NI.EQ.NJ)RETURN;"LAST TEST WAS SUCCESS"
               0  "     CALL IT ONCE MORE TO GET THE FITS.                             "
               0  IF (.NOT.QFIT(NI,XL,XU,XR,EP,ZTHR,ZEP,REM,NIP,XFUN,XFI,
               0  AX,BX,NALM,NFUN,AF,BF,VFUNS,0)) OUTPUT NI;
               0  (' CATASTROPHE---DOES NOT FIT WHEN IT SHOULD,NI=',I5);
               0  RETURN;
               0  END;  "END OF SUBROUTINE PWLF1"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  LOGICAL FUNCTION QFIT(NJ,XL,XH,XR,EP,ZTHR,ZEP,REM,NJP,XFUN,XFI,
               0   AX,BX,NALM,NFUN,AF,BF,VFUNS,IPRN);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  COMIN/EGS-IO/;
               0  "EXTERNAL XFUN,XFI,VFUNS;"
               0  EXTERNAL VFUNS;
               0  $REAL4    XFUN,XFI;
               0  $INTEGER NJ,NALM,NFUN,NJP,IPRN;
               0  $REAL4    XL,XH,XR,AX,BX,REM,EP;
               0  $REAL4 FSXL(10),FSXH(10),FIP(10),FFIP(10),AFIP(10),RE(10),AER(10);
               0  $REAL4 AF(NALM,NFUN),BF(NALM,NFUN),ZTHR(NFUN),ZEP(NFUN);
               0  "     CONSTRUCT THE INTERVAL COEFFICIENTS.                             "
               0  "     XR SHOULD BE IN THE INTERVAL (XL,XH).  IF NOT IT WILL BE SE TO TH"
               0  "     NEAREST LIMIT.  SUBINTERVALS WILL BE ARRANGED SO                 "
               0  "     THAT XR IS ALWAYS ON A SUBINTERVAL BOUNDARY.   THE PURPOSE OF THI"
               0  "     FEATURE IS TO MORE EASILY FIT FUNCTIONS WHICH HAVE AN INTERIOR   "
               0  "     DISCONTINUITY IN SLOPE.  EXAMPLES ARE THE MOLLER AND PAIR        "
               0  "     CROSS SECTIONS WHICH CONTRIBUTE DISCONTINUITIES IN SLOPE         "
               0  "     TO THE ELECTRON AND PHOTON INTERACTION PROBABILITIES IN          "
               0  "     THE INTERIOR OF THE ENERGY RANGES FOR THESE PARTICLES.           "
               0  "     IN ABLE TO GIVE SOME VALUE FOR X'S WHICH MAY LIE SLIGHTLY OUTSIDE"
               0  "     THE INTERVAL (XL,XH) AN EXTRA SUBINTERVAL ON EACH SIDE OF (XL,XH)"
               0  "     IS PROVIDED, WHICH USED THE SAME STRAIGHT LINES AS THE ADJACENT  "
               0  "     INCLUDED SUBINTERVAL.  NJ IS THE TOTAL NUMBER OF SUBINTERVALS    "
               0  "     AND NI IS DEFINED TO BE THE NUMBER OF INTERNAL SUBINTERVALS=NJ-2."
               0  "     NJP IS THE MINUMUM NUMBER OF POINTS INTERIOR TO THE INTERVAL     "
               0  "     (XL,XH) AT WHICH THE FIT IS TO BE TESTED.  A NUMBER NIP WILL BE  "
               0  "     CHOSEN AS THE NUMBER OF INTERIOR POINTS WITHIN EACH SUBINTERVAL  "
               0  "     AT WHICH TO TEST SO THAT NIP*NI]=NJP.                        "
               0  $REAL4    XS,XFL,XFH,XFS,XM,DX,W,XLL,SXFL,XSXF,SXFH,DSXF,WIP,
               0           SXFIP,XIP;
               0  $INTEGER NI,NIP,ISUB,IFUN,JSUB,IP;
               0  $INTEGER nkp;
               0  DATA NKP/3/;
               0  save nkp;
               0  IF (XH.LE.XL)[
               1  OUTPUT XL,XH;(' QFIT ERROR:XL SHOULD BE < XH. XL,XH=',2G14.6);
               1  QFIT=.FALSE.; RETURN;]
               0  XS=AMAX1(XL,AMIN1(XH,XR));
               0  "     GET NUMBER OF INTERNAL SUBINTERVALS ARE ALLOWED AND CHECK        "
               0  NI=NJ-2;
               0  "     AT LEAST 2 SUBINTERVALS ARE NEEDED IF XR(XS) IS NOT AN END POINT."
               0  IF (((XS.EQ.XL.OR.XS.EQ.XH).AND.NI.GE.1).OR.NI.GE.2) [XFL=XFUN(XL);]
               0  ELSE [QFIT=.FALSE.; RETURN;]
               0  XFH=XFUN(XH);
               0  XFS=XFUN(XS);
               0  "write(58,*)'xfh,xfs,xh,xs ',xfh,xfs,xh,xs;"
               0  "     SET SUBINTERVAL WIDTH.                                           "
               0  XM=AMAX1(XFH-XFS,XFS-XFL);
               0  DX=XFH-XFL;
               0  W=XM/AMAX1(1.,AINT(NI*XM/DX));
               0  "write(58,*)' w,xm,ni,dx ',w,xm,ni,dx;"
               0  "     RESET NI TO HOW MANY WE'RE ACTUALLY GOING TO USE.                "
               0  NI=NI-AINT(NI-DX/W);
               0  "     COMPUTE HOW MANY INTERIOR POINTS TO SAMPLE IN EACH SUBINTERVAL.  "
               0  NIP=MAX0(NKP,(NJP+NI-1)/NI);
               0  "     MAKE NIP ODD                                                     "
               0  NIP=(NIP/2)*2+1;
               0  "     SET ACTUAL LOWER LIMIT OF INTERVAL.                              "
               0  IF (XFH-XFS.LE.XFS-XFL) [XLL=XFL;]
               0  ELSE [XLL=XFH-NI*W;]
               0  "     COEFICIENTS FOR USER TO COMPUTE WHICH SUBINTERVAL TO USE.        "
               0  "     ISUBINT=AX*XFUN(X)+BX                                            "
               0  AX=1./W;
               0  BX=2.-XLL*AX;
               0  "     THE RIGHT BOUNDARY OF SUBINTERVAL I IS XFI(XLL+W*(I-1))          "
               0  "     NOW COMPUTE THE FIT COEFFICIENTS FOR THE SUBINTERVALS            "
               0  "     AND FIND MAXIMUM RELATIVE ERROR(REM).                            "
               0  REM=0.0;
               0  QFIT=.TRUE.;
               0  "     LOOP OVER SUBINTERVALS                                           "
               0  "     INITIALIZE LOWER BOUNDARY AND VALUE.                             "
               0  SXFL=AMAX1(XLL,XFL);
               0  ISUB=0;
               0  XSXF=XFI(SXFL);
               0  "write(58,*)' 1 xsxf ',XSXF;"
               0  CALL VFUNS(XSXF,FSXL);
               0  IF (IPRN.NE.0) WRITE(6,:FMT:) ISUB,SXFL,XSXF,(FSXL(IFUN),IFUN=1,NFUN);
               0  :FMT: FORMAT(' QFIT:ISUB,SXF,XSXF,FSX()=',I4,1P,9G11.4/(1X,12G11.4));
               0  DO ISUB=1,NI[
               1  "     ALLOW FOR EXTRA SUBINTERVAL OUTSIDE THE MAIN INTERVAL            "
               1  JSUB=ISUB+1;
               1  SXFH=AMIN1(XLL+W*ISUB,XH);
               1  XSXF=XFI(SXFH);
               1  "write(58,*)' 2 xsxf ',XSXF;"
               1  CALL VFUNS(XSXF,FSXH);
               1  IF (IPRN.NE.0)WRITE(6,:FMT:)ISUB,SXFH,XSXF,(FSXH(IFUN),IFUN=1,NFUN);
               1  DSXF=SXFH-SXFL;
               1  "write(58,*)' xll,w,isub,xh ',xll,w,isub,xh;"
               1  "write(58,*)' dsxf,sxfh,sxfl ',dsxf,sxfh,sxfl;"
               1  DO IFUN=1,NFUN[
               2  AF(JSUB,IFUN)=(FSXH(IFUN)-FSXL(IFUN))/DSXF;
               2  BF(JSUB,IFUN)=(FSXL(IFUN)*SXFH-FSXH(IFUN)*SXFL)/DSXF;] "END OF IFUN"
               1  "     LOOP OVER INTERIOR POINTS TO LOOK FOR MAX. REL.ERROR             "
               1  "     COMPUTE INTERIOR POINT SPACING.                                  "
               1  WIP=DSXF/(NIP+1);
               1  "write(58,*)' dsxf,nip ',dsxf,nip;"
               1  DO IP=1,NIP[
               2  "     VALUE OF XFUN AT THE INTERIOR POINT OF THIS SUBINTERVAL.         "
               2  SXFIP=SXFL+IP*WIP;
               2  XIP=XFI(SXFIP);
               2  "write(58,*)' sxfl,ip,wip ',sxfl,ip,wip;"
               2  "     COMPUTE FUNCTION AT INTERIOR POINT                               "
               2  "write(58,*)' xip ',XIP;"
               2  CALL VFUNS(XIP,FIP);
               2  "     COMPUTE FITTED VALUES.                                           "
               2  DO IFUN=1,NFUN[
               3  FFIP(IFUN)=AF(JSUB,IFUN)*SXFIP+BF(JSUB,IFUN);
               3  AFIP(IFUN)=ABS(FIP(IFUN));
               3  AER(IFUN)=ABS(FFIP(IFUN)-FIP(IFUN));
               3  RE(IFUN)=0.0;
               3  IF (FIP(IFUN).NE.0.0) [RE(IFUN)=AER(IFUN)/AFIP(IFUN);]
               3  IF (AFIP(IFUN).GE.ZTHR(IFUN)) [REM=AMAX1(REM,RE(IFUN));]
               3  ELSEIF (AER(IFUN).GT.ZEP(IFUN)) [QFIT=.FALSE.;]
               3  ] "END OF IFUN"
               2  "*****WRITE OUT SO WE CAN SEE HOW WE ARE DOING.                        "
               2  IF (IPRN.NE.0) [
               3  OUTPUT ISUB,IP,SXFIP,XIP,REM,QFIT,(FIP(IFUN),FFIP(IFUN),
               3   RE(IFUN),AER(IFUN),IFUN=1,NFUN);
               3  (1X,2I4,1P,2G12.5,6P,F12.0,L2,1P,2G11.4,6P,F11.0,1P,G11.4/
               3   (1X,3(1P,2G11.4,6P,F11.0,1P,G11.4)));]
               2  ] "END OF IP"
               1  "     SAVE RIGHT BOUNDARY AND VALUE FOR NEXT SUBINTERVAL.              "
               1  SXFL=SXFH;
               1  DO IFUN=1,NFUN [FSXL(IFUN)=FSXH(IFUN);]
               1  ] "END OF ISUB"
               0  "     SET UP SKIRTING SUBINTERVALS(VIA EXTRAPOLATION)                  "
               0  DO IFUN=1,NFUN[
               1  AF(1,IFUN)=AF(2,IFUN);
               1  BF(1,IFUN)=BF(2,IFUN);
               1  AF(NI+2,IFUN)=AF(NI+1,IFUN);
               1  BF(NI+2,IFUN)=BF(NI+1,IFUN);] "END OF IFUN"
               0  QFIT=QFIT.AND.REM.LE.EP;
               0  NJ=NI+2; "TELL ACTUAL NO. OF SUBINTERVALS USED."
               0  "write(58,*)'ni ',ni;"
               0  RETURN;
               0  END; "END OF LOGICAL FUNCTION QFIT
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION QD(F,A,B,MSG);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  implicit none;
               0  COMIN/EGS-IO/;
               0  $REAL4    A,B,F;
               0  EXTERNAL F;
               0  CHARACTER*6 MSG;
               0  logical first_time;
               0  data first_time/.true./;
               0  save first_time;
               0
               0  "    CHANGED"
               0
               0  "    REAL*8 DCADRE,ADUM,BDUM,ERRDUM,MSG;"
               0
               0  "    TO"
               0
               0  "    DOUBLE PRECISION DCADRE,ADUM,BDUM,ERRDUM;"
               0  "    CHARACTER*6 MSG;"
               0
               0  "    FOR SUN COMPATIBILITY AFB 89/12/27"
               0
               0  "DOUBLE PRECISION DCADRE,ADUM,BDUM,ERRDUM;"
               0  $REAL4 DCADRE,ADUM,BDUM,ERRDUM;
               0  $INTEGER IER;
               0
               0  ADUM=A; BDUM=B;
               0  QD=DCADRE(F,ADUM,BDUM,$AERR,$RERR,ERRDUM,IER);
               0  "write(58,*)' qd ',QD;"
               0  IF (IER.GT.66)[
               1      OUTPUT IER,MSG,A,B,QD,ERRDUM;
               1      (' DCADRE CODE=',I4,' FOR INTEGRAL ',A6,' FROM ',1P,G14.6,' TO ',G14.6,
               1      ',QD=',G14.6,'+-',G14.6);
               1  ]
               0  RETURN;
               0  END;  "END OF FUNCTION QD"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  "DOUBLE PRECISION FUNCTION DCADRE(F,A,B,AERR,RERR,ERROR,IER);"
               0  $REAL4 FUNCTION DCADRE(F,A,B,AERR,RERR,ERROR,IER);
               0  implicit none;
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  "                                                                  "
               0  "                                                                  "
               0  "------------------------------------------------------------------"
               0  "-DCADRE--------D-------LIBRARY 1----------------------------------"
               0  "------------------------------------------------------------------"
               0  "                                                                  "
               0  "FUNCTION:          - INTEGRATE F(X) FROM A TO B, USING CAUTIOUS   "
               0  "                     ADAPTIVE ROMBERG EXTRAPOLATION.              "
               0  "                                                                  "
               0  "USAGE:             - FUNCTION DCADRE(F,A,B,AERR,RERR,ERROR,IER)   "
               0  "                                                                  "
               0  "PARAMETERS: DCADRE - ESTIMATE OF THE INTEGRAL OF F(X) FROM A TO B."
               0  "                                                                  "
               0  "            F      - A SINGLE-ARGUMENT REAL FUNCTION SUBPROGRAM   "
               0  "                     SUPPLIED BY THE USER.  F MUST BE DECLARED    "
               0  "                     EXTERNAL IN THE CALLING PROGRAM.             "
               0  "                                                                  "
               0  "            A,B    - THE TWO ENDPOINTS OF THE INTERVAL OF         "
               0  "                     INTEGRATION (INPUT).                         "
               0  "                                                                  "
               0  "            AERR   - DESIRED ABSOLUTE ERROR IN THE ANSWER (INPUT)."
               0  "                                                                  "
               0  "            RERR   - DESIRED RELATIVE ERROR IN THE ANSWER (INPUT)."
               0  "                                                                  "
               0  "            ERROR  - ESTIMATED BOUND ON THE ABSOLUTE ERROR OF     "
               0  "                     THE OUTPUT NUMBER, DCADRE.                   "
               0  "                                                                  "
               0  "            IER    - ERROR PARAMETER                              "
               0  "                                                                  "
               0  "                     WARNING ERROR(WITH FIX) = 64 + N             "
               0  "                                                                  "
               0  "                       N = 1 IMPLIES THAT ONE OR MORE SINGULAR-   "
               0  "                             ITIES WERE SUCCESSFULLY HANDLED.     "
               0  "                                                                  "
               0  "                       N = 2 IMPLIES THAT, IN SOME SUBINTERVAL(S),"
               0  "                             THE ESTIMATE OF THE INTEGRAL WAS     "
               0  "                             ACCEPTED MERELY BECAUSE THE ESTIMATED"
               0  "                             ERROR WAS SMALL, EVEN THOUGH NO REG- "
               0  "                             ULAR BEHAVIOR WAS RECOGNIZED.        "
               0  "                                                                  "
               0  "                     TERMINAL ERROR = 128 + N                     "
               0  "                                                                  "
               0  "                       N = 3 FAILURE DUE TO INSUFFICIENT INTERNAL "
               0  "                             WORKING STORAGE.                     "
               0  "                                                                  "
               0  "                       N = 4 FAILURE.  THIS MAY BE DUE TO TOO MUCH"
               0  "                             NOISE IN THE FUNCTION (RELATIVE TO   "
               0  "                             THE GIVEN ERROR REQUIREMENTS) OR DUE "
               0  "                             TO AN ILL-BEHAVED INTEGRAND.         "
               0  "                                                                  "
               0  "                       N = 5 INDICATES THAT RERR IS GREATER THAN  "
               0  "                             0.1, OR RERR IS LESS THAN 0.0, OR    "
               0  "                             RERR IS TOO SMALL FOR THE PRECISION  "
               0  "                             OF THE MACHINE.                      "
               0  "                                                                  "
               0  "------------------------------------------------------------------"
               0  "VERSION DATE:      - 8 OCTOBER 1974                               "
               0  "                                                                  "
               0  "MORTRAN VERSION    - 4 OCTOBER 1984/1545 (W. R. NELSON)           "
               0  "------------------------------------------------------------------"
               0  "                                                                  "
               0  ; "NOTE: SEMI-COLON TO CLEAR MORTRAN BUFFER                        "
               0  "                                                                  "
               0  "ADDED"
               0  "EXTERNAL F;"
               0  "FOR SUN AFB 89/12/27"
               0
               0  "EXTERNAL F;"
               0
               0  DIMENSION T(10,10),R(10),AIT(10),DIF(10),RN(4),TS(2049);
               0  DIMENSION IBEGS(30),BEGIN(30),FINIS(30),EST(30);
               0  DIMENSION REGLSV(30);
               0  LOGICAL H2CONV,AITKEN,RIGHT,REGLAR,REGLSV;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  $REAL4 T,R,AIT,DIF,RN,TS,BEGIN,FINIS,EST,AITLOW;
               0  $REAL4 H2TOL,AITTOL,LENGTH,JUMPTL,ZERO,P1,HALF,ONE;
               0  $REAL4 TWO,FOUR,FOURP5,TEN,HUN,CADRE,ERROR,A,B;
               0  $REAL4 AERR,RERR,STEPMN,STEPNM,STAGE,CUREST,FNSIZE;
               0  $REAL4 PREVER,BEG,FBEG,END,FEND,STEP,ASTEP,TABS,HOVN;
               0  $REAL4 FN,SUM,SUMABS,ABSI,VINT,TABTLM,ERGL,ERGOAL;
               0  $REAL4 ERRA,ERRR,FEXTRP,ERRER,DIFF,SING,FEXTM1,ALG4O2;
               0  $REAL4 H2NXT,SINGNX,SLOPE,FBEG2,ALPHA;
               0  $REAL4 ERRET,H2TFEX,FI;
               0  "ADDED"
               0  "REAL RVAL,F;"
               0  "FOR SUN AFB 89/12/27"
               0
               0  $REAL4 RVAL,F;
               0
               0  $INTEGER IBEGS,IER,ISTAGE,IBEG,IEND,L,N,LM1,N2,ISTEP,II,III,I,ISTEP2,IT,NNLEFT;
               0  $INTEGER MAXTS,MAXTBL,MXSTGE;
               0  DATA AITLOW,H2TOL,AITTOL,JUMPTL,MAXTS,MAXTBL,MXSTGE/1.1D0,.15D0,
               0       .1D0,.01D0,2049,10,30/;
               0  DATA RN(1),RN(2),RN(3),RN(4)/.7142005D0,.3466282D0,.843751D0,
               0       .1263305D0/;
               0  DATA ZERO,P1,HALF,ONE,TWO,FOUR,FOURP5,TEN,HUN/0.0D0,0.1D0,0.5D0,
               0       1.0D0,2.0D0,4.0D0,4.5D0,10.0D0,100.0D0/;
               0  save MAXTS,MAXTBL,MXSTGE;
               0  ALG4O2=LOG10(TWO);
               0  /CADRE,ERROR,CUREST,VINT/=ZERO;
               0  IER=0;
               0  LENGTH=ABS(B-A);
               0  IF(LENGTH.EQ.ZERO) GO TO 215;
               0  IF(RERR.GT.P1.OR.RERR.LT.ZERO) GO TO 210;
               0  IF(AERR.EQ.ZERO.AND.(RERR+HUN).LE.HUN) GO TO 210;
               0  ERRR=RERR;
               0  ERRA=ABS(AERR);
               0  STEPMN=(LENGTH/FLOAT(2**MXSTGE));
               0  STEPNM=DMAX1(LENGTH,ABS(A),ABS(B))*TEN;
               0  STAGE=HALF;
               0  ISTAGE=1;
               0  FNSIZE=ZERO;
               0  PREVER=ZERO;
               0  REGLAR=.FALSE.;
               0  "                              THE GIVEN INTERVAL OF INTEGRATION   "
               0  "                                IS THE FIRST INTERVAL CONSIDERED. "
               0  BEG=A;
               0
               0  "CHANGED"
               0  "FBEG=F(BEG)*HALF;"
               0  "TO"
               0  "RVAL=BEG;FBEG=F(RVAL)*HALF;"
               0  "FOR SUN AFB 89/12/27"
               0
               0  RVAL=BEG;FBEG=F(RVAL)*HALF;
               0  "write(*,*)' rval, f, half ',rval,F(RVAL),half;"
               0
               0  TS(1)=FBEG;
               0  IBEG=1;
               0  END=B;
               0
               0  "CHANGED"
               0  "FEND=F(END)*HALF;"
               0  "TO"
               0  "RVAL=END;FEND=F(RVAL)*HALF;"
               0  "FOR SUN AFB 89/12/27"
               0
               0  RVAL=END;FEND=F(RVAL)*HALF;
               0
               0  TS(2)=FEND;
               0  IEND=2;
               0  5 RIGHT=.FALSE.;
               0  "                              INVESTIGATION OF A PARTICULAR       "
               0  "                                SUBINTERVAL BEGINS AT THIS POINT. "
               0  10 STEP=END - BEG;
               0  ASTEP=ABS(STEP);
               0  IF(ASTEP.LT.STEPMN) GO TO 205;
               0  IF(STEPNM+ASTEP.EQ.STEPNM) GO TO 205;
               0  T(1,1)=FBEG + FEND;
               0  TABS=ABS(FBEG) + ABS(FEND);
               0  L=1;
               0  N=1;
               0  H2CONV=.FALSE.;
               0  AITKEN=.FALSE.;
               0  15 LM1=L;
               0  L=L + 1;
               0  "                              CALCULATE THE NEXT TRAPEZOID SUM,   "
               0  "                                T(L,1), WHICH IS BASED ON *N2* + 1"
               0  "                                EQUISPACED POINTS. HERE,          "
               0  "                                N2 = N*2 = 2**(L-1).              "
               0  N2=N + N;
               0  FN=N2;
               0  ISTEP=(IEND - IBEG)/N;
               0  IF(ISTEP.GT.1) GO TO 25;
               0  II=IEND;
               0  IEND=IEND + N;
               0  IF(IEND.GT.MAXTS) GO TO 200;
               0  HOVN=STEP/FN;
               0  III=IEND;
               0  FI=ONE;
               0  DO I=1,N2,2[
               1  TS(III)=TS(II);
               1
               1  "CHANGED"
               1  "TS(III-1)=F(END - FI * HOVN);"
               1  "TO"
               1  "RVAL=END-FI*HOVN;TS(III-1)=F(RVAL);"
               1  "FOR SUN AFB 89/12/27"
               1
               1  RVAL=END-FI*HOVN;TS(III-1)=F(RVAL);
               1
               1  FI=FI+TWO;
               1  III=III-2;
               1  II=II-1;]
               0  ISTEP=2;
               0  25 ISTEP2=IBEG + ISTEP/2;
               0  SUM=ZERO;
               0  SUMABS=ZERO;
               0  DO I=ISTEP2,IEND,ISTEP[
               1  SUM=SUM + TS(I);
               1  SUMABS=SUMABS + ABS(TS(I));]
               0  T(L,1)=T(L-1,1)*HALF+SUM/FN;
               0  TABS=TABS*HALF+SUMABS/FN;
               0  ABSI=ASTEP*TABS;
               0  N=N2;
               0  "                              GET PRELIMINARY VALUE FOR *VINT*    "
               0  "                                FROM LAST TRAPEZOID SUM AND UPDATE"
               0  "                                THE ERROR REQUIREMENT *ERGOAL*    "
               0  "                                FOR THIS SUBINTERVAL.             "
               0  IT=1;
               0  VINT=STEP*T(L,1);
               0  TABTLM=TABS*TEN;
               0  FNSIZE=DMAX1(FNSIZE,ABS(T(L,1)));
               0  ERGL=ASTEP*FNSIZE*TEN;
               0  ERGOAL=STAGE*DMAX1(ERRA,ERRR*ABS(CUREST+VINT));
               0  "                              COMPLETE ROW L AND COLUMN L OF *T*  "
               0  "                                ARRAY.                            "
               0  FEXTRP=ONE;
               0  DO I=1,LM1[
               1  FEXTRP=FEXTRP*FOUR;
               1  T(I,L)=T(L,I) - T(L-1,I);
               1  T(L,I+1)=T(L,I) + T(I,L)/(FEXTRP-ONE);]
               0  ERRER=ASTEP*ABS(T(1,L));
               0  "                              PRELIMINARY DECISION PROCEDURE      "
               0  "                                IF L = 2 AND T(2,1) = T(1,1),     "
               0  "                                GO TO 135 TO FOLLOW UP THE        "
               0  "                                IMPRESSION THAT INTERGRAND IS     "
               0  "                                STRAIGHT LINE.                    "
               0  IF(L.GT.2) GO TO 40;
               0  IF(TABS+P1*ABS(T(1,2)).EQ.TABS) GO TO 135;
               0  GO TO 15;
               0  "                              CACULATE NEXT RATIOS FOR            "
               0  "                                COLUMNS 1,...,L-2 OF T-TABLE      "
               0  "                                RATIO IS SET TO ZERO IF DIFFERENCE"
               0  "                                IN LAST TWO ENTRIES OF COLUMN IS  "
               0  "                                ABOUT ZERO                        "
               0  40 DO 45 I=2,LM1;
               0  DIFF=ZERO;
               0  IF(TABTLM+ABS(T(I-1,L)).NE.TABTLM) DIFF=T(I-1,LM1)/T(I-1,L);
               0  T(I-1,LM1)=DIFF;
               0  45 CONTINUE;
               0  IF(ABS(FOUR-T(1,LM1)).LE.H2TOL) GO TO 60;
               0  IF(T(1,LM1).EQ.ZERO) GO TO 55;
               0  IF(ABS(TWO-ABS(T(1,LM1))).LT.JUMPTL) GO TO 130;
               0  IF(L.EQ.3) GO TO 15;
               0  H2CONV=.FALSE.;
               0  IF(ABS((T(1,LM1)-T(1,L-2))/T(1,LM1)).LE.AITTOL) GO TO 75;
               0  50 IF(REGLAR) GO TO 55;
               0  IF(L.EQ.4) GO TO 15;
               0  55 IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 175;
               0  GO TO 145;
               0  "                              CAUTIOUS ROMBERG EXTRAPOLATION      "
               0  60 IF(H2CONV) GO TO 65;
               0  AITKEN=.FALSE.;
               0  H2CONV=.TRUE.;
               0  65 FEXTRP=FOUR;
               0  70 IT=IT + 1;
               0  VINT=STEP*T(L,IT);
               0  ERRER=ABS(STEP/(FEXTRP-ONE)*T(IT-1,L));
               0  IF(ERRER.LE.ERGOAL) GO TO 160;
               0  IF(ERGL+ERRER.EQ.ERGL) GO TO 160;
               0  IF(IT.EQ.LM1) GO TO 125;
               0  IF(T(IT,LM1).EQ.ZERO) GO TO 70;
               0  IF(T(IT,LM1).LE.FEXTRP) GO TO 125;
               0  IF(ABS(T(IT,LM1)/FOUR-FEXTRP)/FEXTRP.LT.AITTOL)
               0  FEXTRP=FEXTRP*FOUR;
               0  GO TO 70;
               0  "                              INTEGRAND MAY HAVE X**ALPHA TYPE    "
               0  "                                SINGULARITY                       "
               0  "                                RESULTING IN A RATIO OF *SING*  = "
               0  "                                2**(ALPHA + 1)                    "
               0  75 IF(T(1,LM1).LT.AITLOW) GO TO 175;
               0  IF(AITKEN) GO TO 80;
               0  H2CONV=.FALSE.;
               0  AITKEN=.TRUE.;
               0  80 FEXTRP=T(L-2,LM1);
               0  IF(FEXTRP.GT.FOURP5) GO TO 65;
               0  IF(FEXTRP.LT.AITLOW) GO TO 175;
               0  IF(ABS(FEXTRP-T(L-3,LM1))/T(1,LM1).GT.H2TOL) GO TO 175;
               0  SING=FEXTRP;
               0  FEXTM1=ONE/(FEXTRP - ONE);
               0  AIT(1)=ZERO;
               0  DO 85 I=2,L;
               0  AIT(I)=T(I,1) + (T(I,1)-T(I-1,1))*FEXTM1;
               0  R(I)=T(1,I-1);
               0  DIF(I)=AIT(I) - AIT(I-1);
               0  85 CONTINUE;
               0  IT=2;
               0  90 VINT=STEP*AIT(L);
               0  ERRER=ERRER*FEXTM1;
               0  IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 95;
               0  ALPHA=LOG10(SING)/ALG4O2 - ONE;
               0  IER=MAX0(IER,65);
               0  GO TO 160;
               0  95 IT=IT + 1;
               0  IF(IT.EQ.LM1) GO TO 125;
               0  IF(IT.GT.3) GO TO 100;
               0  H2NXT=FOUR;
               0  SINGNX=SING+SING;
               0  100 IF(H2NXT.LT.SINGNX) GO TO 105;
               0  FEXTRP=SINGNX;
               0  SINGNX=SINGNX+SINGNX;
               0  GO TO 110;
               0  105 FEXTRP=H2NXT;
               0  H2NXT=FOUR*H2NXT;
               0  110 DO 115 I=IT,LM1;
               0  R(I+1)=ZERO;
               0  IF(TABTLM+ABS(DIF(I+1)).NE.TABTLM) R(I+1)=DIF(I)/DIF(I+1);
               0  115 CONTINUE;
               0  H2TFEX=-H2TOL*FEXTRP;
               0  IF(R(L)-FEXTRP.LT.H2TFEX) GO TO 125;
               0  IF(R(L-1)-FEXTRP.LT.H2TFEX) GO TO 125;
               0  ERRER=ASTEP*ABS(DIF(L));
               0  FEXTM1=ONE/(FEXTRP - ONE);
               0  DO 120 I=IT,L;
               0  AIT(I)=AIT(I) + DIF(I)*FEXTM1;
               0  DIF(I)=AIT(I) - AIT(I-1);
               0  120 CONTINUE;
               0  GO TO 90;
               0  "                              CURRENT TRAPEZOID SUM AND RESULTING "
               0  "                                EXTRAPOLATED VALUES DID NOT GIVE  "
               0  "                                A SMALL ENOUGH *ERRER*.           "
               0  "                                NOTE -- HAVING PREVER .LT. ERRER  "
               0  "                                IS AN ALMOST CERTAIN SIGN OF      "
               0  "                                BEGINNING TROUBLE WITH IN THE FUNC"
               0  "                                TION VALUES. HENCE, A WATCH FOR,  "
               0  "                                AND CONTROL OF, NOISE SHOULD      "
               0  "                                BEGIN HERE.                       "
               0  125 FEXTRP=DMAX1(PREVER/ERRER,AITLOW);
               0  PREVER=ERRER;
               0  IF(L.LT.5) GO TO 15;
               0  IF(L-IT.GT.2.AND.ISTAGE.LT.MXSTGE) GO TO 170;
               0  ERRET=ERRER/(FEXTRP**(MAXTBL-L));
               0  IF(ERRET.GT.ERGOAL.AND.(ERGL+ERRET).NE.ERGL) GO TO 170;
               0  GO TO 15;
               0  "                              INTEGRAND HAS JUMP (SEE NOTES)      "
               0  130 IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 170;
               0  "                                NOTE THAT  2*FN=2**L              "
               0  DIFF=ABS(T(1,L))*(FN+FN);
               0  GO TO 160;
               0  "                              INTEGRAND IS STRAIGHT LINE          "
               0  "                                TEST THIS ASSUMPTION BY COMPARING "
               0  "                                THE VALUE OF THE INTEGRAND AT     "
               0  "                                FOUR *RANDOMLY CHOSEN* POINTS WITH"
               0  "                                THE VALUE OF THE STRAIGHT LINE    "
               0  "                                INTERPOLATING THE INTEGRAND AT THE"
               0  "                                TWO END POINTS OF THE SUB-INTERVAL"
               0  "                                IF TEST IS PASSED, ACCEPT *VINT*  "
               0  135 SLOPE=(FEND-FBEG)*TWO;
               0  FBEG2=FBEG+FBEG;
               0  DO 140 I=1,4;
               0
               0  "CHANGED"
               0  "DIFF=ABS(F(BEG+RN(I)*STEP) - FBEG2-RN(I)*SLOPE);"
               0  "TO"
               0  "RVAL=BEG+RN(I)*STEP;DIFF=ABS(F(RVAL) - FBEG2-RN(I)*SLOPE);"
               0  "FOR SUN AFB 89/12/27"
               0
               0  RVAL=BEG+RN(I)*STEP;DIFF=ABS(F(RVAL) - FBEG2-RN(I)*SLOPE);
               0
               0  IF(TABTLM+DIFF.NE.TABTLM) GO TO 155;
               0  140 CONTINUE;
               0  GO TO 160;
               0  "                              NOISE MAY BE DOMINANT FEATURE       "
               0  "                                ESTIMATE NOISE LEVEL BY COMPARING "
               0  "                                THE VALUE OF THE INTEGRAND AT     "
               0  "                                FOUR *RANDOMLY CHOSEN* POINTS WITH"
               0  "                                THE VALUE OF THE STRAIGHT LINE    "
               0  "                                INTERPOLATING THE INTEGRAND AT THE"
               0  "                                TWO ENDPOINTS. IF SMALL ENOUGH,   "
               0  "                                ACCEPT *VINT*                     "
               0  145 SLOPE=(FEND-FBEG)*TWO;
               0  FBEG2=FBEG+FBEG;
               0  I=1;
               0
               0  "CHANGED"
               0  "150 DIFF=ABS(F(BEG+RN(I)*STEP) - FBEG2-RN(I)*SLOPE);"
               0  "TO"
               0  "150 RVAL=BEG+RN(I)*STEP;DIFF=ABS(F(RVAL) - FBEG2-RN(I)*SLOPE);"
               0  "FOR SUN AFB 89/12/27"
               0
               0  150 RVAL=BEG+RN(I)*STEP;DIFF=ABS(F(RVAL) - FBEG2-RN(I)*SLOPE);
               0
               0  155 ERRER=DMAX1(ERRER,ASTEP*DIFF);
               0  IF(ERRER.GT.ERGOAL.AND.(ERGL+ERRER).NE.ERGL) GO TO 175;
               0  I=I+1;
               0  IF(I.LE.4) GO TO 150;
               0  IER=66;
               0  "                              INTERGRATION OVER CURRENT SUB-      "
               0  "                                INTERVAL SUCCESSFUL               "
               0  "                                ADD *VINT* TO *DCADRE* AND *ERRER*"
               0  "                                TO *ERROR*, THEN SET UP NEXT SUB- "
               0  "                                INTERVAL, IF ANY.                 "
               0  160 CADRE=CADRE + VINT;
               0  ERROR=ERROR + ERRER;
               0  IF(RIGHT) GO TO 165;
               0  ISTAGE=ISTAGE - 1;
               0  IF(ISTAGE.EQ.0) GO TO 220;
               0  REGLAR=REGLSV(ISTAGE);
               0  BEG=BEGIN(ISTAGE);
               0  END=FINIS(ISTAGE);
               0  CUREST=CUREST - EST(ISTAGE+1) + VINT;
               0  IEND=IBEG - 1;
               0  FEND=TS(IEND);
               0  IBEG=IBEGS(ISTAGE);
               0  GO TO 180;
               0  165 CUREST=CUREST + VINT;
               0  STAGE=STAGE+STAGE;
               0  IEND=IBEG;
               0  IBEG=IBEGS(ISTAGE);
               0  END=BEG;
               0  BEG=BEGIN(ISTAGE);
               0  FEND=FBEG;
               0  FBEG=TS(IBEG);
               0  GO TO 5;
               0  "                              INTEGRATION OVER CURRENT SUBINTERVAL"
               0  "                                IS UNSUCCESSFUL. MARK SUBINTERVAL "
               0  "                                FOR FURTHER SUBDIVISION. SET UP   "
               0  "                                NEXT SUBINTERVAL.                 "
               0  170 REGLAR=.TRUE.;
               0  175 IF(ISTAGE.EQ.MXSTGE) GO TO 205;
               0  IF(RIGHT) GO TO 185;
               0  REGLSV(ISTAGE+1)=REGLAR;
               0  BEGIN(ISTAGE)=BEG;
               0  IBEGS(ISTAGE)=IBEG;
               0  STAGE=STAGE*HALF;
               0  180 RIGHT=.TRUE.;
               0  BEG=(BEG+END)*HALF;
               0  IBEG=(IBEG+IEND)/2;
               0  TS(IBEG)=TS(IBEG)*HALF;
               0  FBEG=TS(IBEG);
               0  GO TO 10;
               0  185 NNLEFT=IBEG - IBEGS(ISTAGE);
               0  IF(IEND+NNLEFT.GE.MAXTS) GO TO 200;
               0  III=IBEGS(ISTAGE);
               0  II=IEND;
               0  DO 190 I=III,IBEG;
               0  II=II + 1;
               0  TS(II)=TS(I);
               0  190 CONTINUE;
               0  DO 195 I=IBEG,II;
               0  TS(III)=TS(I);
               0  III=III + 1;
               0  195 CONTINUE;
               0  IEND=IEND + 1;
               0  IBEG=IEND - NNLEFT;
               0  FEND=FBEG;
               0  FBEG=TS(IBEG);
               0  FINIS(ISTAGE)=END;
               0  END=BEG;
               0  BEG=BEGIN(ISTAGE);
               0  BEGIN(ISTAGE)=END;
               0  REGLSV(ISTAGE)=REGLAR;
               0  ISTAGE=ISTAGE + 1;
               0  REGLAR=REGLSV(ISTAGE);
               0  EST(ISTAGE)=VINT;
               0  CUREST=CUREST + EST(ISTAGE);
               0  GO TO 5;
               0  "                              FAILURE TO HANDLE GIVEN INTEGRA-    "
               0  "                                TION PROBLEM                      "
               0  200 IER=131;
               0  GO TO 215;
               0  205 IER=132;
               0  GO TO 215;
               0  210 IER=133;
               0  215 CADRE=CUREST + VINT;
               0  220 DCADRE=CADRE;
               0  9000 CONTINUE;
               0  9005 RETURN;
               0  END;  "END OF FUNCTION DCADRE"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE SPINIT(density_file);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  ;
               0  implicit none;
               0
               0  COMIN/PMCONS,SPCOMM,DERCON,MOLVAR,BREMPRP,ELEMTB,LSPION,EPSTAR,THRESHP,
               0  EGS-IO,MIXDAT,MISC/;
               0
               0  $REAL4 IMEV;
               0  " IK: Variable declarations for implicit none"
               0  $INTEGER IM,J,IZ,IE,I,ICHECK,IESPEL,IPEGEL,density_unit,lnblnk1,egs_get_unit;
               0  $REAL4    VPLASM,ALIADG,EDENL,ALGASP,EPSTRH,
               0           TLRNCE,EPSTWT;
               0  CHARACTER*256 density_file;
               0
               0  TOLN10=2.0*LOG(10.0);IM=-100;
               0
               0  IF(EPSTFLP < 0 | EPSTFLP > 1) [
               1          EPSTFLP = 0;
               1  ]
               0  "ABOVE IS NRCC MOD DEC 1988"
               0
               0  IF(EPSTFLP=0)["DEFAULT TO STANDARD PEGS4 METHODS"
               1
               1  "MATERIAL MUST BE FOUND IN THE SSB TABLE OR THE S-P"
               1  "      GENERAL FORMULA WILL BE USED.
               1
               1  "CHECK TO SEE IF MATERIAL IS A 'STERNHEIMER-SELTZER-BERGER' (SSB)"
               1  "MATERIAL, FOR WHICH THE DENSITY EFFECT PARAMETERS ARE ALREADY"
               1  "SPECIFIED.  IF IT IS NOT, THEN CALCULATE THEM USING THE GENERAL"
               1  "FORMULA BY STERNHEIMER-PEIERLS (S-P)."
               1
               1  "STERNHEIMER-SELTZER-BERGER (SSB) LOOKUP TABLE SECTION:"
               1  :TRY: DO IM=1,NUMSTMED [DO J=1,LMED
               2  [IF (IDSTRN(J).NE.MEDTBL(J,IM)) NEXT :TRY:;]
               2  "CALCULATION FOLLOWS IF A MATCH IS FOUND"
               2  AFACT=STDATA(1,IM); SK=STDATA(2,IM); X0=STDATA(3,IM);
               2  X1=STDATA(4,IM); IEV=STDATA(5,IM); CBAR=STDATA(6,IM);
               2  IMEV=IEV*1.0E-6; "EV TO MEV"
               2  VPLASM=SQRT(EDEN*R0*C**2/PIP);
               2  GO TO :SSB-PARAMETERS-DEFINED:;]
               1
               1  "STERNHEIMER-PEIERLS (S-P) GENERAL FORMULA SECTION:"
               1  IM=0;
               1  "DETERMINE THE MEAN EXCITATION ENERGY, IMEV (IN MEV)"
               1  IF (NEP.EQ.1) ["ELEMENT"
               2  IZ=ZELEMP(1);
               2  IF (IZ.EQ.1.OR.IZ.EQ.7.OR.IZ.EQ.8) ["I.E., DIATOMIC MOLECULE"
               3  OUTPUT ; (' STOPPED IN SUBROUTINE SPINIT BECAUSE THIS',/,
               3   ' ELEMENT (H, N, OR O) CAN ONLY EXIST AS A DIATOMIC MOLECULE.',/,
               3   ' REMEDY:  USE COMP OPTION FOR H2, N2, OR O2 WITH NE=2,PZ=1,1'/,
               3   '          AND, IN THE CASE OF A GAS, DEFINE STERNHEIMER ID',/,
               3   '          (I.E., IDSTRN) LIKE H2-GAS');
               3  $CALL_EXIT(21);]
               2  IEV=ITBL(IZ);     "EV"
               2  ]
               1
               1  ELSE ["COMPOUND/MIXTURE---USE BRAGG ADDITIVITY RULE"
               2  ALIADG=0.0;
               2  DO IE=1,NEP [
               3  IZ=ZELEMP(IE);
               3  IF (IZ.EQ.1) [IEV=19.2;]   "EV"
               3  ELSEIF (IZ.EQ.6) [IF (GASPP.EQ.0.0) [IEV=81.0;] ELSE [IEV=70.0;]]
               3  ELSEIF (IZ.EQ.7) [IEV=82.0;]
               3  ELSEIF (IZ.EQ.8) [IF (GASPP.EQ.0.0) [IEV=106.0;] ELSE [IEV=97.0;]]
               3  ELSEIF (IZ.EQ.9) [IEV=112.0;]
               3  ELSEIF (IZ.EQ.17) [IEV=180.0;]
               3  ELSE [IEV=1.13*ITBL(IZ);]
               3  "NRCC comment - above 7 lines reflect table 6 in ref 59 of SLAC-265"
               3  "       Berger and Seltzer's fudge to get better agreement with expt"
               3  ALIADG=ALIADG + PZP(IE)*ZELEMP(IE)*LOG(IEV);
               3  ]
               2  ALIADG=ALIADG/ZC;
               2  IEV=EXP(ALIADG);    "EV"
               2  ]
               1
               1  IMEV=IEV*1.0E-6;  "EV TO MEV"
               1  "COMPUTE VARIOUS STERNHEIMER CONSTANTS"
               1  IF (GASPP.EQ.0.0) [EDENL=EDEN;]
               1  ELSE ["VPLASM MUST BE FOR NTP FOR A GAS, AND EDEN HAS"
               2  "      BEEN DEFINED IN MIX FOR THE ACTUAL PRESSURE"
               2         EDENL=EDEN/GASPP;]
               1  VPLASM = SQRT(EDENL*R0*C**2/PIP);
               1  "ABOVE PATCHED JAN 9,1989 TO REFLECT ERROR POINTED OUT BY"
               1  "PROF KAMAE, TOKYO UNIVERSITY, VIA HIDEO HIRAYAMA"
               1
               1  CBAR=1. + 2.*LOG(IMEV/(HBAR*2*PIP*VPLASM/ERGMEV));
               1
               1  IF (NEP.EQ.1.AND.INT(ZELEMP(1)).EQ.2.AND.GASPP.NE.0.0)[
               2            "SPECIAL HE(GAS) CASE"
               2  X0=2.191; X1=3.0; SK=3.297;
               2  ]
               1
               1  ELSEIF (NEP.EQ.2.AND.INT(ZELEMP(1)).EQ.1
               1          .AND.INT(ZELEMP(2)).EQ.1) [
               2  IF (GASPP.EQ.0.0) ["SPECIAL H2(LIQUID) CASE"
               3  X0=0.425; X1=2.0; SK=5.949;
               3  ]
               2  ELSE ["SPECIAL H2(GAS) CASE"
               3  X0=1.837; X1=3.0; SK=4.754;
               3  ]
               2  ]
               1
               1  ELSE ["REGULAR CASES"
               2  SK=3.0;
               2  IF (GASPP.EQ.0.0) ["SOLIDS AND LIQUIDS"
               3  IF (IEV.LT.100.0) [
               4  IF (CBAR.LT.3.681) [X0=0.2; X1=2.0;]
               4  ELSE [X0=0.326*CBAR - 1.0; X1=2.0;]
               4  ]
               3  ELSE ["IEV GE 100.0"
               4  IF (CBAR.LT.5.215) [X0=0.2; X1=3.0;]
               4  ELSE [X0=0.326*CBAR - 1.5; X1=3.0;]
               4  ]
               3  IF (X0.GE.X1) [OUTPUT X0,X1,CBAR;
               4  (' STOPPED IN SPINIT DUE TO X0.GE.X1 , X0,X1,CBAR=',3G15.5,/
               4  ,' IF THIS IS GAS, YOU MUST DEFINE GASP(ATM)'); $CALL_EXIT(21);]
               3  ]
               2  ELSE ["GASES---AT NTP AT THIS STAGE"
               3  IF (CBAR.LT.10.0) [X0=1.6; X1=4.0;]
               3  ELSEIF (CBAR.LT.10.5) [X0=1.7; X1=4.0;]
               3  ELSEIF (CBAR.LT.11.0) [X0=1.8; X1=4.0;]
               3  ELSEIF (CBAR.LT.11.5) [X0=1.9; X1=4.0;]
               3  ELSEIF (CBAR.LT.12.25) [X0=2.0; X1=4.0;]
               3  ELSEIF (CBAR.LT.13.804) [X0=2.0; X1=5.0;]
               3  ELSE [X0=0.326*CBAR - 2.5; X1=5.0;]
               3  ]
               2  ]  "END OF STERNHEIMER-PEIERLS (S-P) GENERAL FORMULA SECTION"
               1
               1  :SSB-PARAMETERS-DEFINED:
               1
               1  "GAS PRESSURE CORRECTION COMES NEXT"
               1  IF (GASPP.NE.0.0) [
               2  ALGASP=LOG(GASPP);
               2  CBAR=CBAR - ALGASP;
               2  X0=X0 - ALGASP/TOLN10;
               2  X1=X1 - ALGASP/TOLN10;
               2  ]
               1
               1  IF (IM.EQ.0) [AFACT=(CBAR - TOLN10*X0)/(X1 - X0)**SK;]
               1  ]"END OF EPSTFL=0 BLOCK"
               0
               0  ELSE[ "EPSTFL=1 BLOCK  I.E. READ IN THE INPUT FROM THE DENSITY"
               1       "INPUT FILE"
               1  "get the name of the density file"
               1  density_file=$cstring(density_file);
               1  density_unit=20;
               1  density_unit=egs_get_unit(density_unit);
               1  IF( density_unit < 1 ) [
               2          $egs_fatal(*,'SPINIT: failed to get a free fortran unit');
               2  ]
               1  open(density_unit,file=density_file,status='old',err=:no_density_file:);
               1
               1  READ(density_unit,:A:)EPSTTL;:A:  FORMAT(A);
               1  READ(density_unit,*) NEPST,IEV,EPSTRH,NELEPS;
               1  READ(density_unit,*) (ZEPST(I),WEPST(I),I=1,NELEPS);
               1  READ(density_unit,*) (EPSTEN(I),EPSTD(I),I=1,NEPST);
               1
               1  close(density_unit);
               1
               1  IF(NEPST>150)[OUTPUT NEPST;
               2  (//' *****NEPST=',I4,' IS GREATER THAN THE 150 ALLOWED');$CALL_EXIT(22);]
               1  "CONVERT TO TOTAL ENERGIES"
               1  DO I=1,NEPST[EPSTEN(I) = EPSTEN(I) + RMP;]
               1  IMEV = IEV*1.E-06;
               1
               1  "CHECK THAT WE HAVE COVERED ENERGY RANGES NEEDED"
               1  IF( AEP < EPSTEN(1))[OUTPUT EPSTEN(1),AEP;
               2  (//' ****LOWEST ENERGY INPUT FOR DENSITY EFFECT IS',1P,E10.3/
               2  T20,'WHICH IS HIGHER THAN THE VALUE OF AE=',1P,E10.3,' MEV'/
               2  ' ***IT HAS BEEN SET TO AE***'//);EPSTEN(1) = AEP;]
               1  IF( UEP > EPSTEN(NEPST))[ OUTPUT EPSTEN(NEPST),UEP;
               2  (//' ****HIGHEST ENERGY INPUT FOR DENSITY EFFECT IS',1P,E10.3/
               2  T20,'WHICH IS LOWER THAN THE VALUE OF UE=',1P,E10.3,' MEV'/
               2  ' ***IT HAS BEEN SET TO UE***'//);EPSTEN(NEPST) = UEP;]
               1
               1  "DO A CHECK ON THE COMPOSITION AND DENSITY TO INSURE THE RIGHT DELTA"
               1  "HAS BEEN PICKED UP. ALLOW A TOLERANCE OF 1 PERCENT ERROR ON THE"
               1  "COMPOSITION BY WEIGHT."
               1
               1  ICHECK=0; "FLAG GETS SET TO UNITY IF THE COMPOSITION DOES NOT MATCH"
               1      TLRNCE=0.01; "TOLERANCE ALLOWED ON FRACTION BY WEIGHT"
               1
               1  "FIRST CHECK THAT THE NUMBER OF ELEMENTS ARE THE SAME"
               1  IF(NELEPS.NE.NEP) ICHECK=1;
               1
               1  "NOW CHECK THAT THE DENSITIES ARE THE SAME WITHIN TOLERANCE"
               1  IF( (ICHECK.EQ.0)  .AND.
               1    ( (EPSTRH.LT.((1.0-TLRNCE)*RHOP)) .OR.
               1      (EPSTRH.GT.((1.0+TLRNCE)*RHOP))
               1    ) ) ICHECK=1; "DENSITY IS OUT OF RANGE"
               1  "WE MUST FIRST NORMALIZE THE PEGS FRACTIONS BY WEIGHT TO ENSURE THEY"
               1  "ARE NORMALIZED TO UNITY"
               1  EPSTWT = 0.0;DO I=1,NEP[ EPSTWT = EPSTWT + RHOZP(I);]
               1  IF(EPSTWT=0.0)[
               2  OUTPUT;(//' *****IN SPINIT***SOMETHING WRONG, MOLECULAR WEIGHT OF',
               2  'MOLECULE IS ZERO (I.E. SUM OF RHOZ)***'//);]
               1
               1  IF(ICHECK.EQ.0)[
               2      IESPEL=0;    "INITIALIZE ESP ELEMENT COUNTER"
               2      ICHECK=1;    "ASSUME FAILURE"
               2      LOOP["LOOP OVER ESP COMPONENTS"
               3          IESPEL=IESPEL+1;
               3          IPEGEL=0;    "INITIALIZE PEGS ELEMENT COUNTER"
               3          LOOP["LOOP OVER PEGS COMPONENTS"
               4              IPEGEL=IPEGEL+1;
               4              IF(INT(ZELEMP(IPEGEL)).EQ.ZEPST(IESPEL))[ICHECK=0;EXIT;]
               4              ]WHILE(IPEGEL.LT.NEP);
               3              IF( (ICHECK.EQ.0) "Z OF ELEMENT MATCHES"
               3              .AND.
               3              ( (WEPST(IESPEL).LT.((1.0-TLRNCE)*RHOZP(IPEGEL)/EPSTWT))
               3               .OR. (WEPST(IESPEL).GT.((1.0+TLRNCE)*RHOZP(IPEGEL)/EPSTWT))
               3              ) ) ICHECK=1; "MATCHED ELEMENT BUT WEIGHT FRACTION WRONG"
               3          ]WHILE(IESPEL.LT.NELEPS);
               2      ] "END OF TEST FOR ICHECK = 0"
               1
               1  IF(ICHECK.EQ.1)[ "PRINT MESSAGE AND STOP"
               2  OUTPUT;
               2  (////'0*** COMPOSITION IN INPUT DENSITY FILE DOES NOT MATCH ',
               2  ' THAT BEING USED BY PEGS'//' ***** QUITTING EARLY***'////);
               2  $CALL_EXIT(23); " ERRORS DETECTED";
               2  ]
               1
               1
               1  ]"END OF EPSTFL=1 BLOCK"
               0
               0
               0  SPC1=2.*PIP*R0**2*RMP*EDEN*RLCP;
               0  SPC2=LOG((IMEV/RMP)**2/2.0);
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  "$DUMP SPC1,SPC2;"
               0
               0  RETURN;
               0  :no_density_file:
               0  $egs_fatal(*,' Failed to open density file ',density_file);
               0  RETURN;
               0  END;  "END OF SUBROUTINE SPINIT"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE MIX;
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  ;
               0
               0  implicit none;
               0
               0  " IK: Variable declarations for implicit none"
               0  $INTEGER I,IZZ;
               0  $REAL4    AL183,ZAB,V2000;
               0
               0  " IK: Function declarations for implicit none"
               0  $REAL4 FCOULCP,XSIFP;
               0
               0  COMIN/MIMSD,MIXDAT,MOLVAR,PMCONS,DERCON,RADLEN,BREMPRP/;
               0  $REAL4 XSI(20),ZZX(20),FZC(20),FCOUL(20),ZZ(20);
               0  " MOLVAR - - MOLECULAR VARIABLES NEEDED BY DIFFER, AND MOLIER      "
               0
               0  " THE FOLLOWING ASSUMES THAT THE MATERIAL BEING DEALT WITH         "
               0  " IS EITHER A COMPOUND, OR A HOMOGENEOUS MIXTURE.                  "
               0  "          MOLECULAR VARIABLES                                     "
               0  " NE       NUMBER OF DIFFERENT TYPES OF ATOMS IN THE MATERIAL.     "
               0  " PZ(I)    PROPORTION OF ELEMENT OF TYPE I.  IF A COUMPOUND,       "
               0  " THEN PZ(I) WILL BE THE NUMBER OF ATOMS OF TYPE I IN THE MOLECULE."
               0  " IF A MIXTURE,SUCH AS CONCRETE, PZ(I) COULD BE THE PER CENT OF    "
               0  " THE ATOMS WHICH ARE OF TYPE I.                                   "
               0  " Z(I)     PERIODIC NUMBER OF ATOMS OF TYPE I                      "
               0  " WA(I)    ATOMIC WEIGHT FOR ATOMS OF TYPE I.                      "
               0  " WM = SUM(PZ(I)*WA(I)) = MOLECULAR  WEIGHT IF A COUMPOUND         "
               0  " OR A 'MIXTURE WEIGHT' IF A MIXTURE.                              "
               0  " RHO      DENSITY OF THE MATERIAL. (IN GRAMS/CM**3)               "
               0  " RHOZ(I)  PARTIAL DENSITY DUE TO ATOMS OF TYPE I. (GM/CM**3)      "
               0  "          ELECTRON DENSITY VARIABLE                               "
               0  " ZC = SUM(PZ(I)*Z(I)) = NUMBER OF ELECTRONS/MOLECULE              "
               0  "          BREMSSTRAHLUNG AND PAIR PRODUCTION VARIABLES ARE WEIGHTE"
               0  " BY PZ(I)*Z(I)**2 FOR THE NUCLEUS, AND BY PZ(I)*Z(I)*XSI(I) FOR   "
               0  " ATOMIC ELECTRONS.                                                "
               0  " TPZ = SUM(PZ(I))                                                 "
               0  " XSI(I) = LOG(A1440/Z(I)**(2./3.))/(LOG(A183/Z(I)**(1./3.))  -    "
               0  "               FCOUL(Z(I)) )                                      "
               0  " ZZX(I) =  PZ(I)*Z(I)*(Z(I)+XSI(I)) = BREMS AND PAAR WEIGHTS      "
               0  " EZ = ZC/TPZ  EFFECTIVE Z                                         "
               0  " ZT = SUM(ZZX(I))                                                 "
               0  " ZA = LOG(A183)*ZT   BUTCHER AND MESSELS L.C.'A' (1960)P.18       "
               0  " ZB = SUM(ZZX(I)*LOG(Z(I)**(-1./3.)  B&M'S L.C.'B' IBID.          "
               0  " ZF = SUM(ZZX(I)*FCOUL(Z(I))),WHERE FCOUL IS THE COULOMB          "
               0  " CORRECTION FUNCTION.                                             "
               0  " RATIOS--                                                         "
               0  " ZG = ZB/ZT ,EXP(ZG)=WEIGHTED GEOMETRIC MEAN OF Z**(-1/3)         "
               0  " ZP = ZB/ZA , B&M IBID.P18 L.C.'P'                                "
               0  " ZV= (ZB-ZF)/ZT                                                   "
               0  " ZU = (ZB-ZF)/ZA                                                  "
               0  "          MULTIPLE SCATTERING VARIABLES                           "
               0  " ACCORDING TO MESSEL AND CRAWFORD(1970), MOST OF THE MULTIPLE     "
               0  " SCATTERING DUE TO THE FIELD OF THE ATOMIC ELECTRONS IS ALREADY   "
               0  " ACCOUNTED FOR BY THE DISCRETE MOLLER SCATTERING. HENCE,THE       "
               0  " FOLLOWING VARIABLES ARE ONLY WEIGHTED BY PZ(I)*Z(I)**2           "
               0  " HOWEVER I HAVE NOT JUSTIFIED THE ABOVE ASSERTION THEORETICALLY   "
               0  " THEORETICALLY, AND COMPARISON OF EXPERIMENTS WITH EGS HAVE       "
               0  " SHOWN EGS PHOTON SPECTRUM DEFICIENT IN THE BACKWARD DIRECTION.   "
               0  " THEREFORE, I WILL EXPERIMENT WITH RESTORING THE ELECTRON SCATTER-"
               0  " ING TERM.  ITS CONTRIBUTION WILL BE REPRESENTED BY THE MACRO VAR-"
               0  " IABLE, $FUDGEMS, WHICH WILL HAVE THE VALUE 0.0 FOR NO ELECTRON   "
               0  " SCATTERING AND 1.0 FOR FULL ELECTRON SCATTERING.  AND WE NOW HAVE"
               0  " WEIGHTING BY PZ(I)*Z(I)*(Z(I)+$FUDGEMS).                         "
               0  " ZZ(I) = PZ(I)*Z(I)*(Z(I)+$FUDGEMS) "
               0  " ZS = SUM(ZZ(I))                                                  "
               0  " ZE = SUM(ZZ(I)*LOG(Z(I)**(-2./3.)))                              "
               0  " ZX = SUM(ZZ(I)*LOG(1.+3.34*(FSC*Z(I))**2))                       "
               0  "               ELECTON DENSITY(ELECTRONS/CM**3)                   "
               0  " EDEN=AN*RHO/WM*ZC                                                "
               0  "          RADIATION LENGTH                                        "
               0  " USEFUL FOR GAUGING THE STEP SIZE, EVEN IF IT IS NOT USED AS THE  "
               0  " UNIT OF DISTANCE.                                                "
               0  "  1./RLC =(AN*RHO/WM)*4.0*FSC*R0**2*                              "
               0  "    SUM( Z(I)*(Z(I)+XSI(I))*(LOG(A183*Z(I)**(-1./3.)-FCOUL(Z(I))) "
               0  "        =(AN*RHO/WM)*4.*FSC*R0**2*(ZAB-ZF)                        "
               0  " INPUT MOLECULAR VARIABLES AND COMPUTE Z-RELATED PARAMETERS       "
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  "SCALE RHO FOR GASES BY THE GAS PRESSURE"
               0  IF (GASPP.NE.0.0) [RHOP=GASPP*RHOP;]
               0  "     FIND VARIOUS SUMS AND SET OTHER VARIABLES                        "
               0  AL183 = LOG(A183);
               0  /TPZ,WM,ZC,ZT,ZB,ZF,ZS,ZE,ZX,ZAB/=0.0;
               0  DO I=1,NEP[
               1  TPZ = TPZ + PZP(I);
               1  WM = WM + PZP(I)*WAP(I);
               1  ZC = ZC + PZP(I)*ZELEMP(I);
               1  FZC(I) =(FSC*ZELEMP(I))**2;
               1  FCOUL(I) = FCOULCP(ZELEMP(I));
               1  XSI(I) = XSIFP (ZELEMP(I));
               1  ZZX(I) = PZP(I)*ZELEMP(I)*(ZELEMP(I)+XSI(I));
               1  IF (ZELEMP(I).LE.4.0) [IZZ=ZELEMP(I);
               2  ZAB=ZAB+ZZX(I)*ALRAD(IZZ);] "IN THE CASE OF Z.LE.4 "
               1  ELSE [ZAB=ZAB+ZZX(I)*(AL183+LOG(ZELEMP(I)**(-1./3.)));] "Z.GT.4"
               1  ZT = ZT + ZZX(I);
               1  ZB = ZB + ZZX(I)*LOG(ZELEMP(I)**(-1./3.));
               1  ZF = ZF + ZZX(I)*FCOUL(I);
               1  ZZ(I) = PZP(I)*ZELEMP(I)*(ZELEMP(I)+$FUDGEMS);
               1  ZS = ZS + ZZ(I);
               1  ZE = ZE + ZZ(I)*((-2./3.)*LOG(ZELEMP(I)));
               1  ZX = ZX + ZZ(I)*LOG(1.+3.34*FZC(I));
               1  ]
               0  "END OF I LOOP"
               0  EZ = ZC/TPZ;
               0  ZA = AL183*ZT;
               0  ZG = ZB/ZT;
               0  ZP = ZB/ZA;
               0  ZV = (ZB-ZF)/ZT;
               0  ZU = (ZB-ZF)/ZA;
               0  EDEN=AN*RHOP/WM*ZC;
               0  RLCP = 1./( (AN*RHOP/WM)*4.0*FSC*R0**2*(ZAB-ZF) );
               0
               0
               0
               0
               0
               0
               0
               0
               0  "$DUMP EDEN;"
               0
               0  "NOW COMPUTE MATERIAL-DEPENDENT CONSTANTS FOR MULTIPLE SCATTERING"
               0  "LET B BE MOLIERE'S UPPER CASE B, AND LET BLC BE MOLIERE'S LOWER CASE B"
               0  "THEN USING SCOTT'S NOTATION, A MEASURE OF THE NUMBER OF SCATTERS IS"
               0  "OMEGA0=EXP(BLC).  NOW B AND BLC ARE RELATED BY"
               0  "BLC=B-ALOG(B);, OR EXP(BLC)=EXP(B)/B; "
               0  "NOW LET T BE THE TRANSPORT DISTANCE IN RL. THEN,"
               0  "OMEGA0=EXP(BLC)"
               0  "      =( A6680*RHO*ZS*EXP(ZE/ZS)*RLC/(WM*EXP(ZX/ZS)) )*T/BETA**2"
               0  "WHERE BETA IS V/C FOR THE PARTICLE"
               0  "NOW SUPPOSE THAT XC IS CHI-SUB-C, THE CHARACTERISTIC ANGLE OF"
               0  "MOLIERE'S THEORY.  THEN IT IS GIVEN BY"
               0  "XC= (A22P9/RADDEG)*SQRT( ZS*RHO*RLC/WM ) * SQRT(T) /(E*BETA**2) "
               0  " WHERE E IS THE ENERGY OF THE PARTICLE IN MEV."
               0  "NOW IN MOLIERE'S THEORY, LET XRM BE XC*SQRT(B).  THEN"
               0  " (MOLIERE'S REDUCE ANGLE)=(REAL ANGLE)/XRM."
               0  "FOR THE VARIABLE SAMPLING DONE IN EGS, A DIFFERENT REDUCED"
               0  "ANGLE IS USED:"
               0  " (REDUCED ANGLE FOR VARIABLE SAMPLING)=(REAL ANGLE)/XRV "
               0  " WHERE NOW XRV=XC*SQRT(BLC)."
               0  "THIS IS DONE BECAUSE BLC IS MORE SIMPLY RELATED TO THE TRANSPORT"
               0  "DISTANCE THAN IS B."
               0
               0  "WITH THIS BACKGROUND WE NOW PROCEED TO COMPUTE"
               0  "XR0, TEFF0, BLCC, AND XCC, WHICH ARE PARAMETERS NEEDED IN EGS"
               0  "THESE PARAMETERS ARE USED AS FOLLOWS:(IN OUR NOTATION)"
               0  "XRM=XR0*SQRT(T*B/(T0*BMIN))/(E*BETA) "
               0  "  WHERE B IS EVALUATED FOR DISTANCE T, AND T0 IS THE"
               0  "  DISTANCE THAT WOULD GIVE B=BMIN. T0 IS A FUNCTION OF BETA, AND"
               0  "  IS GIVEN BY THE EXPRESSION  "
               0  "T0=TEFF0*BETA**2;  THIS IS ALSO THE DEFINING RELATION FOR TEFF0"
               0  "BMIN IS THE MINIMUM VALUE OF B FOR WHICH MOLIERE CONSIDERED HIS THEORY"
               0  "VALID.  WE CURRENTLY GIVE BMIN A VALUE OF 4.5."
               0  "OMEGA0=BLCC*T/BETA**2  IS THE USEAGE OF BLCC"
               0  "XRV= XCC*SQRT( T*BLC )/(E*BETA**2) IS THE USAGE OF XCC"
               0
               0  "WE NOW PROCEED TO SOLVE FOR THE ABOVE QUANTITIES."
               0  "COMPARING THE TWO EXPRESSIONS FOR OMEGA0, WE CONCLUDE THAT:"
               0
               0  BLCCP= A6680*RHOP*ZS*EXP(ZE/ZS)*RLCP/(WM*EXP(ZX/ZS)) ;
               0  "NOW USING THE EXPRESSION FOR OMEGA0 AT B=BMIN,WE HAVE"
               0  " OMEGA0=EXP(BLCMIN)"
               0  "       =EXP(BMIN)/BMIN"
               0  "       =BLCC*T0/BETA**2"
               0  "       =BLCC*TEFF0    ,     THEREFORE"
               0
               0  TEFF0P = ( EXP(BMIN)/BMIN )/BLCCP;
               0
               0  "COMPARING THE TWO EXPRESSION FOR XRV WE CONCLUDE THAT"
               0  "XC= XCC * SQRT(T) /(E*BETA**2)"
               0  "COMPARING THIS WITH OUR PREVIOUS EXPRESSION FOR XC, WE OBTAIN"
               0
               0  XCCP= (A22P9/RADDEG) * SQRT( ZS*RHOP*RLCP/WM );
               0
               0  "NOW COMPARING THE TWO EXPRESSIONS FOR XRM WE OBTAIN"
               0  "XRM=XC*SQRT(B)       USING DEFINITION OF XRM"
               0  "   =(XCC(i_med)*SQRT(T)/(E*BETA**2)) *SQRT(B)  AFTER SUBSTITUTING FOR XC"
               0  "   =XR0*SQRT((T*B)/(T0*BMIN))/(E*BETA)  USING EXPRESSION DEFINING XR0"
               0  "   =XR0*SQRT((T*B)/(TEFF0*BETA**2*BMIN))/(E*BETA)  EXPANDING T0"
               0  " THUS AFTER SOME CANCELLATION AND SOLVING FOR XR0 WE OBTAIN"
               0
               0  XR0P = XCCP*SQRT(TEFF0P*BMIN);
               0
               0  "THIS COMPLETE THE MS CALCULATIONS"
               0
               0
               0
               0
               0  RETURN;
               0  END; "END OF SUBROUTINE MIX"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  SUBROUTINE DIFFER;
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0  implicit none;
               0  ;
               0
               0  " IK: Variable declarations for implicit none"
               0  $REAL4 AL183,F10,F20,A1DEN,A2DEN,B1DEN,B2DEN,C1DEN,C2DEN;
               0  INTEGER I;
               0
               0  COMIN/MOLVAR,BREMPRP,DBRPR,DERCON,RADLEN/;
               0  "**********************************************************************"
               0  "***THE DIFFERENTIAL CROSS-SECTIONS OF BREMSSTRAHLUNG AND PAIR       "
               0  "   PRODUCTION ARE Z-DEPENDENT.  BUTCHER AND MESSEL USE A SAMPLING   "
               0  "   TECHNIQUE FOR BREMSSTRAHLUNG WHICH ALSO DEPENDS ON THE LARGEST   "
               0  "   AND SMALLEST ALLOWED ENERGY VALUES.                              "
               0  "   THIS IS NOW TAKEN INTO ACCOUNT BY THE FUNCTION ILOG2(E/AP) WHICH "
               0  "   GIVES THE NUMBER OF SUBDISTRIBUTIONS NEED TO PRODUCE PHOTONS DOWN"
               0  "   TO THE LIMIT AP.                                                 "
               0  "   THE DIFFERENTAL CROSS SECTIONS USED FOR BREMS AND PAIR ARE--     "
               0  "   (THEY ARE CROSS SECTION PER RADIATION LENGTH)                    "
               0
               0  "***BELOW 50MEV (BETHE-HEITLER)--                                      "
               0  "         BREMS--                                                      "
               0  "     PHI1=(LOG(2)*(4/3+1/(9*LOG(A183)*(1+ZP)))* (1/LOG(2)*(1-EPS)/EPS)"
               0  "    1 * A(DELTAPRIME) + (1/2) * (2*EPS) * B(DELTAPRIME)               "
               0  "         PAIR --                                                      "
               0  "     PHI2=(2/3 - 1/(36*LOG(A183)*(1+ZP)))*(1) * C(DELTAPRIME)         "
               0  "    1  + (1/12*(4/3+1/(9*LOG(A183)*(1+ZP))))* (12*(EPS-1/2)**2)       "
               0  "    2 * A(DELTAPRIME)                                                 "
               0  "       WHERE A,B,C ARE SCREENING REJECTION FUNCTIONS GIVEN BY         "
               0  "       A(D)=(3*F1(D)-F2(D)+8*ZG)/(3*F1(0)-F2(0)+8*ZG)                 "
               0  "       B(D)=(F1(D)+4*ZG)/(F1(0)+4*ZG)                                 "
               0  "       C(D)=(3*F1(D)+F2(D)+16*ZG)/(3*F1(0)+F2(0)+16*ZG)               "
               0  "       AND WHERE                                                      "
               0  "       DELTAPRIME= 136.*EXP(ZG)*RM*DEL= DELCM *DEL                    "
               0  "       AND                                                            "
               0  "       DEL =  EPS/(E*(1-EPS))      BREMSSTRAHLUNG                     "
               0  "           =  1/(E*EPS*(1-EPS))    PAIR PRODUCTION                    "
               0  "       F1(D) AND F2(D) ARE SCREENING FUNCTIONS GIVEN APPROXIMATELY BY "
               0  "             IF D.LE.1 ,THEN                                          "
               0  "       F1(D) = 20.867 - 3.242*D + 0.625*D**2                          "
               0  "       F2(D) = 20.209 - 1.930*D - 0.086*D**2                          "
               0  "         BUT IF D.GT.1 ,THEN                                          "
               0  "       F1(D)=F2(D)= 21.12 - 4.184*ALOG(D+0.952)                       "
               0  "         IN ADDITION WE HAVE THAT                                     "
               0  "       F1(0)= 4.*ALOG(A183)                                           "
               0  "       F2(0)= F1(0) - 2./3.                                           "
               0  "***ABOVE 50 MEV (COULOMB CORRECTED BETHE HEITLER)                     "
               0  "         BREMS--                                                      "
               0  "     PHI1=(LOG(2)*(4/3+1/(9*LOG(A183)*(1+ZU)))* (1/LOG(2)*(1-EPS)/EPS)"
               0  "    1 * A(DELTAPRIME) + (1/2) * (2*EPS) * B(DELTAPRIME)               "
               0  "         PAIR --                                                      "
               0  "     PHI2=(2/3-1/(36*LOG(A183)*(1+ZU)))* 1 * C(DELTAPRIME)            "
               0  "    1  + (1/12*(4/3+1/(9*LOG(A183)*(1+ZU))))* (12*(EPS-1/2)**2)       "
               0  "    2  * A(DELTAPRIME)                                                "
               0  "       WHERE A,B,AND C ARE NOW GIVEN BY                               "
               0  "       A(D) = (3*F1(D)-F2(D)+8*ZV)/(3*F1(0)-F2(0)+8*ZV)               "
               0  "       B(D) = (F1(D)+4*ZV)/(F1(0)+4*ZV)                               "
               0  "       C(D) = (3*F1(D)+F2(D)+16*ZV)/(3*F1(0)+F2(0)+16*ZV)             "
               0  "       AND DELTAPRIME,DEL,F1, AND F2 ARE THE SAME AS BELOW 50 MEV.    "
               0  "   BREMSSTRAHLUNG ALPHA(I), I=1,...,N.  ALPHA(N+1)=0.5                "
               0  AL2 = LOG(2.);
               0  AL183= LOG(A183);
               0  ALPHIP(1)= AL2*(4./3. + 1./(9.*AL183*(1.+ZP)));
               0  ALPHIP(2)= AL2*(4./3. + 1./(9.*AL183*(1.+ZU)));
               0  "*****PAIR PRODUCTION DIFFERENTIAL CROSS-SECTION NUMBERS               "
               0  ALFP1(1)= 2./3. - 1./(36.*AL183*(1.+ZP));
               0  ALFP1(2)= 2./3. - 1./(36.*AL183*(1.+ZU));
               0  ALFP2(1)= (1./12.)*(4./3. + 1./(9.*AL183*(1+ZP)));
               0  ALFP2(2)= (1./12.)*(4./3. + 1./(9.*AL183*(1+ZU)));
               0  "*****BRANCHING RATIO FOR PAIR PRODUCTION SAMPLING                     "
               0  BPARP(1)= ALFP1(1)/(ALFP1(1)+ALFP2(1));
               0  BPARP(2)= ALFP1(2)/(ALFP1(2)+ALFP2(2));
               0
               0  "*****WE MUST ALWAYS HAVE A,B,C(DELTA) POSITIVE. SHOWER ASSURES THIS BY"
               0  "     REQUIRING DEL.LT.DELPOS(),AND HENCE THAT DELTA.LT.DELCM *DELPOS()"
               0  "     THE CROSS-OVER POINT IS IN THE DELTA.GT.1 REGION,AND THE CROSSING"
               0  "     CONDITION REDUCES TO --                                          "
               0  "       F1(D) + 4*ZG = 0     IF  E.LT.50 MEV                           "
               0  "       F1(D) + 4*ZV = 0     IF  E.GT.50 MEV                           "
               0  "     OR --                                                            "
               0  "       21.12 - 4.184*ALOG(DELCM *DELPOS(1)+0.952) +4.*ZG =0     E.LT.5"
               0  "       21.12 - 4.184*ALOG(DELCM *DELPOS(2)+0.952) +4.*ZV =0     E.GT.5"
               0  "       THUS DELPOS IN THE TWO ENERGY REGIONS IS GIVEN BY              "
               0  DELCMP= 136.0*EXP(ZG)*RMP;
               0  DELPOSP(1)= (EXP((21.12+4.*ZG)/4.184)-0.952)/DELCMP;
               0  DELPOSP(2)= (EXP((21.12+4.*ZV)/4.184)-0.952)/DELCMP;
               0  "     CALCULATION OF THE BETHE-HEITLER(B-H) A,B,C(DELTA).AND THE       "
               0  "     COULUMB CORRECTED(CC) A,B,C(DELTA).  THE SHOWER PROGRAM COMPUTES "
               0  "     THESE SIX SCREENING REJECTION FUNCTION WITH THE EXPRESSIONS--    "
               0  "       DL1(LVL)+DELTA*(DL2(LVL)+DELTA*DL3(LVL))   IF DELTA.LT.1 ,AND B"
               0  "       DL4(LVL)+DL5(LV)*ALOG(DELTA+DL6(LVL))      IF DELTA.GE.1       "
               0  "       WHERE LVL IS USED TO SELECT THE FUNCTION--                     "
               0  "       LVL=1   B-H A(DELTA)                                           "
               0  "          =2   B-H B(DELTA)                                           "
               0  "          =3   B-H C(DELTA)                                           "
               0  "          =4   CC  A(DELTA)                                           "
               0  "          =5   CC  B(DELTA)                                           "
               0  "          =6   CC  C(DELTA)                                           "
               0  "     FIRST COMPUTE THE DENOMINATORS                                   "
               0  F10=4.*AL183;
               0  F20=F10 - 2./3.;
               0  A1DEN =3.0*F10- F20 + 8.0*ZG;
               0  A2DEN =3.0*F10- F20 + 8.0*ZV;
               0  B1DEN = F10 + 4.0*ZG;
               0  B2DEN = F10 + 4.0*ZV;
               0  C1DEN = 3.0*F10+ F20 + 16.0*ZG;
               0  C2DEN = 3.0*F10+ F20 + 16.0*ZV;
               0  "     LVL=1, B-H A(DELTA)                                              "
               0  DLP1(1)= (3.0*20.867-20.209+8.0*ZG)/A1DEN;
               0  DLP2(1)= (3.0*(-3.242)-(-1.930))/A1DEN;
               0  DLP3(1)= (3.0*(0.625)-(0.086))/A1DEN;
               0  DLP4(1)= (2.0*21.12+8.0*ZG)/A1DEN;
               0  DLP5(1)=  2.0*(-4.184)/A1DEN;
               0  DLP6(1)=  0.952;
               0  "     LVL=4, CC  A(DELTA)                                              "
               0  DLP1(4)= (3.0*20.867-20.209+8.0*ZV)/A2DEN;
               0  DLP2(4)= (3.0*(-3.242)-(-1.930))/A2DEN;
               0  DLP3(4)= (3.0*(0.625)-(0.086))/A2DEN;
               0  DLP4(4)= (2.0*21.12+8.0*ZV)/A2DEN;
               0  DLP5(4)=  2.0*(-4.184)/A2DEN;
               0  DLP6(4)=  0.952;
               0  "     LVL=2, B-H B(DELTA)                                              "
               0  DLP1(2)= (20.867+4.0*ZG)/B1DEN;
               0  DLP2(2)= -3.242/B1DEN;
               0  DLP3(2)=  0.625/B1DEN;
               0  DLP4(2)= (21.12+4.0*ZG)/B1DEN;
               0  DLP5(2)= -4.184/B1DEN;
               0  DLP6(2)= 0.952;
               0  "     LVL=5, CC B(DELTA)                                               "
               0  DLP1(5)= (20.867+4.0*ZV)/B2DEN;
               0  DLP2(5)= -3.242/B2DEN;
               0  DLP3(5)= 0.625/B2DEN;
               0  DLP4(5)= (21.12+4.0*ZV)/B2DEN;
               0  DLP5(5)= -4.184/B2DEN;
               0  DLP6(5)= 0.952;
               0  "     LVL=3, B-H C(DELTA)                                              "
               0  DLP1(3)= (3.0*20.867+20.209+16.0*ZG)/C1DEN;
               0  DLP2(3)= (3.0*(-3.242)+(-1.930))/C1DEN;
               0  DLP3(3)= (3.0*0.625+(-0.086))/C1DEN;
               0  DLP4(3)= (4.0*21.12+16.0*ZG)/C1DEN;
               0  DLP5(3)=  4.0*(-4.184)/C1DEN;
               0  DLP6(3)=  0.952;
               0  "     LVL=6, CC  C(DELTA)                                              "
               0  DLP1(6)= (3.0*20.867+20.209+16.0*ZV)/C2DEN;
               0  DLP2(6)= (3.0*(-3.242)+(-1.930))/C2DEN;
               0  DLP3(6)= (3.0*0.625+(-0.086))/C2DEN;
               0  DLP4(6)= (4.0*21.12+16.0*ZV)/C2DEN;
               0  DLP5(6)=  4.0*(-4.184)/C2DEN;
               0  DLP6(6)=  0.952;
               0  "*****PUNCHED AND PRINTED OUTPUT                                       "
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  RETURN;
               0  END; "END OF SUBROUTINE DIFFER"
               0
               0  $REAL4 function FCOULCP(Z);
               0  "************************"
               0  implicit none;
               0  $REAL4 Z,ASQ;
               0  COMIN/DERCON/;
               0  ASQ=(FSC*Z)**2;
               0  FCOULCP = ASQ*(1.0/(1.0+ASQ)+0.20206+ASQ*(-0.0369+
               0   ASQ*(0.0083+ASQ*(-0.002))));
               0  RETURN;
               0  END;  "END OF FUNCTION FCOULC"
               0
               0  $REAL4 function XSIFP(Z);
               0  "**********************"
               0  implicit none;
               0  $REAL4 Z,FCOULCP;
               0  $INTEGER IZ;
               0  COMIN/RADLEN/;
               0  IF (Z.LE.4.0) [IZ=Z;
               1  XSIFP=ALRADP(IZ)/(ALRAD(IZ)-FCOULCP(Z));]
               0  ELSE [
               1  XSIFP=ALOG(A1440*Z**(-2./3.))/(ALOG(A183*Z**(-1./3.))-FCOULCP(Z));]
               0  RETURN;
               0  END;  "END OF FUNCTION XSIF"
               0
               0  "******************************************************************"
               0  "                                STANFORD LINEAR ACCELERATOR CENTER"
               0  $REAL4 FUNCTION ZTBL(IASYM);
               0  "                                VERSION 4.00  --  26 JAN 1986/1900"
               0  "******************************************************************"
               0
               0  ;
               0  implicit none;
               0  COMIN/ELEMTB,EGS-IO/;
               0  $TYPE IASYM,IA;
               0  $INTEGER ie;
               0  DATA IA/'A'/;
               0  save ia;
               0  IF (IASYM.EQ.IA)["ALTERNATE SYMBOL FOR ARGON" ZTBL=18.0;RETURN;]
               0  "     PUT IN THE REST LATER                                 "
               0  DO IE=1,NET[
               1  IF (IASYM.EQ.ASYMT(IE)) [ZTBL=IE; RETURN;]
               1  ]
               0  OUTPUT IASYM,NET;
               0  (1X,A2,' NOT AN ATOMIC SYMBOL FOR AN ELEMENT WITH Z LE ',I3);
               0  ZTBL=0.0;
               0  RETURN;
               0  "END OF FUNCTION ZTBL" END;
               0  %C80                                                                           ;
               0  "#############################################################################"
               0  "                                                                             "
               0  "  EGSnrc core source code                                                    "
               0  "  Copyright (C) 2015 National Research Council Canada                        "
               0  "                                                                             "
               0  "  This file is part of EGSnrc.                                               "
               0  "                                                                             "
               0  "  EGSnrc is free software: you can redistribute it and/or modify it under    "
               0  "  the terms of the GNU Affero General Public License as published by the     "
               0  "  Free Software Foundation, either version 3 of the License, or (at your     "
               0  "  option) any later version.                                                 "
               0  "                                                                             "
               0  "  EGSnrc is distributed in the hope that it will be useful, but WITHOUT ANY  "
               0  "  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS  "
               0  "  FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for   "
               0  "  more details.                                                              "
               0  "                                                                             "
               0  "  You should have received a copy of the GNU Affero General Public License   "
               0  "  along with EGSnrc. If not, see <http://www.gnu.org/licenses/>.             "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Authors:         Iwan Kawrakow, 2000                                       "
               0  "                   Dave Rogers, 2000                                         "
               0  "                                                                             "
               0  "  Contributors:    Ernesto Mainegra-Hing                                     "
               0  "                   Blake Walters                                             "
               0  "                   Frederic Tessier                                          "
               0  "                   Reid Townson                                              "
               0  "                                                                             "
               0  "#############################################################################"
               0  "                                                                             "
               0  "  Parts of the EGS code that originate from SLAC are distributed by NRC      "
               0  "  under the terms of the AGPL 3.0 licence, in agreement with SLAC.           "
               0  "                                                                             "
               0  "  The contributors named above are only those who could be identified from   "
               0  "  this file's revision history.                                              "
               0  "                                                                             "
               0  "  A large number of people have been involved with the development of EGS    "
               0  "  over the years. Many details are in the manual. The authors want to point  "
               0  "  out the central role of Ralph Nelson of SLAC in the development of EGS     "
               0  "  over decades. We all owe Ralph a huge debt of gratitude.  Similarly, the   "
               0  "  role of Alex Bielajew while he was at NRC was critical in many aspects of  "
               0  "  code development. Hideo Hirayama was involved with the development of EGS4 "
               0  "  while at SLAC and with Yosh Namito and Syuichi Ban at KEK has continued    "
               0  "  developments on EGS4. As well many others and users from around the world  "
               0  "  have assisted in developing and making available the code, in particular   "
               0  "  Robert D. Stewart.                                                         "
               0  "                                                                             "
               0  "#############################################################################"
               0
               0
               0  "Compiler directives"
               0  "==================="
               0  %Q1         "Automatically close comments at end of line                       ;
               0              "but NOTE, this doesn't happen inside a REPLACE macro
               0              "you must open and close within a REPLACE macro.
               0  %C80        "Allow 80 columns of source/line (default is 72)                   ;
               0  !INDENT M2; "Indent Mortran compile listing 2 spaces each nesting level
               0  !INDENT F2; "Indent fortran output 2 spaces each nesting level
               0  %L          "Turn on listing                                                   ;
               0
               0  %I4 "INDENT FOUR SPACES EACH LEVEL"                                            ;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE ANNIH;
               0  "                                                                  "
               0  "******************************************************************"
               0  "   GAMMA SPECTRUM FOR TWO GAMMA IN-FLIGHT POSITRON ANNIHILATION.  "
               0  "   USING SCHEME BASED ON HEITLER'S P269-27O FORMULAE.             "
               0  "                                                                  "
               0  "   If the user requests radiative splitting (via nbr_split > 1),  "
               0  "   this routine produces 2*nbr_split annihilation photons at once,"
               0  "   each carying the fraction 1/nbr_split of the weight of the     "
               0  "   incident positron.                                             "
               0  "                                                                  "
               0  "   Except for taking out the calculation of                       "
               0  "   LOG((1.0-EP0)/EP0) out of the sampling loop and using a        "
               0  "   rejection function normalized to its maximum, the sampling     "
               0  "   technique is the same as the original EGS4 implementation.     "
               0  "                                                                  "
               0  "   I. Kawrakow, January 2000                                      "
               0  "                                                                  "
               0  "******************************************************************"
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-ANNIH;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:      "
               0                   "COMIN/DEBUG,STACK,UPHIOT,USEFUL,RANDOM,          "
               0                   "EGS-VARIANCE-REDUCTION/;                         "
               0
               0  $DEFINE-LOCAL-VARIABLES-ANNIH;
               0  $INTEGER ip;
               0
               0  NPold = NP; "Set the old stack counter"
               0  IF( nbr_split <= 0 ) [ return; ]
               0  PAVIP=E(NP)+PRM; "PRECISE AVAILABLE ENERGY OF INCIDENT POSITRON,
               0                   "i.e. electron assumed to be at rest
               0  AVIP=PAVIP;      "AVAILABLE ENERGY OF INCIDENT POSITRON"
               0  A=AVIP/RM;
               0  "AI=1.0/A;  AI not necessary, IK Oct 97"
               0  G=A-1.0;
               0  T=G-1.0;
               0  P=SQRT(A*T);
               0  POT=P/T;
               0  EP0=1.0/(A+P);
               0  "   SAMPLE 1/EP FROM EP=EP0 TO 1.0-EP0"
               0  "Take the calculation of the logarithm out of the loop, IK Oct 97"
               0  WSAMP=LOG((1.0-EP0)/EP0);
               0
               0  aa = u(np); bb = v(np); cc = w(np);
               0  sinpsi = aa*aa + bb*bb;
               0  IF( sinpsi > 1e-20 ) [
               1     sinpsi = sqrt(sinpsi);
               1     sindel = bb/sinpsi; cosdel = aa/sinpsi;
               1  ]
               0
               0  IF( nbr_split > 1 ) [ wt(np) = wt(np)/nbr_split; ]
               0
               0  DO ibr = 1,nbr_split [  "nbr_split > 1 means we want splitting for any"
               1                          "radiative event                              "
               1
               1      IF( np+1 > $MXSTACK ) [
               2          $egs_fatal('(//a,i6,a//)',' Stack overflow in ANNIH! np = ',np+1,
               2                     ' Increase $MXSTACK and try again' );
               2      ]
               1
               1      LOOP[
               2          $RANDOMSET RNNO01;
               2          EP=EP0*EXP(RNNO01*WSAMP);
               2          "   NOW DECIDE WHETHER TO ACCEPT"
               2          $RANDOMSET RNNO02;
               2          "REJF=1.0-EP+AI*AI*(2.0*G-1.0/EP);"
               2          "The above rejection function has a maximum = 1 - 2/A**2"
               2          "For efficiency, it is better to divide by the maximum value, IK Oct 97"
               2          REJF = 1 - (EP*A-1)**2/(EP*(A*A-2));
               2      ] UNTIL (RNNO02 <= REJF);
               1
               1
               1      "   SET UP ENERGIES"
               1      ESG1=AVIP*EP; "ENERGY OF SECONDARY GAMMA 1"
               1      PESG1=ESG1; "PRECISE ENERGY OF SECONDARY GAMMA 1"
               1      E(NP)=PESG1; IQ(NP)=0;
               1      IF( ibr = 1 ) [ ip = npold; ] ELSE [ ip = np-1; ]
               1      $TRANSFER PROPERTIES TO (np) FROM (ip);
               1      COSTHE=MIN(1.0,(ESG1-RM)*POT/ESG1);
               1      SINTHE=SQRT(1.0-COSTHE*COSTHE);
               1      $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               1      IF( sinpsi >= 1e-10 ) [
               2          us = sinthe*cphi; vs = sinthe*sphi;
               2          u(np) = cc*cosdel*us - sindel*vs + aa*costhe;
               2          v(np) = cc*sindel*us + cosdel*vs + bb*costhe;
               2          w(np) = cc*costhe - sinpsi*us;
               2      ]
               1      ELSE [
               2          u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = cc*costhe;
               2      ]
               1      np = np + 1;
               1      PESG2=PAVIP-PESG1; esg2 = pesg2;
               1      e(np) = pesg2; iq(np) = 0;
               1      $TRANSFER PROPERTIES TO (np) FROM (np-1);
               1      COSTHE=MIN(1.0,(ESG2-RM)*POT/ESG2);
               1      SINTHE=-SQRT(1.0-COSTHE*COSTHE);
               1      IF( sinpsi >= 1e-10 ) [
               2          us = sinthe*cphi; vs = sinthe*sphi;
               2          u(np) = cc*cosdel*us - sindel*vs + aa*costhe;
               2          v(np) = cc*sindel*us + cosdel*vs + bb*costhe;
               2          w(np) = cc*costhe - sinpsi*us;
               2      ]
               1      ELSE [
               2          u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = cc*costhe;
               2      ]
               1      np = np + 1;
               1
               1  ]
               0  np = np-1;
               0
               0  RETURN;
               0  "END OF SUBROUTINE ANNIH"   END;
               0
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE ANNIH_AT_REST;
               0  "                                                                  "
               0  " It is handy to be able to initiate annihilation at rest from     "
               0  " places other than the electron discard section (e.g. AUSGAB)     "
               0  " Annihilation at rest takes a sufficent amount of time to not     "
               0  " have any real benefit from this code being inline in the         "
               0  " ELECTR subroutine.                                               "
               0  " I. Kawrakow, June 2005.                                          "
               0  "******************************************************************"
               0  $IMPLICIT-NONE;
               0  $COMIN-ANNIH-ATREST;
               0  $REAL costhe,sinthe,cphi,sphi;
               0  $INTEGER ibr,ip;
               0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
               0
               0  NPold = NP;
               0  $CHECK-STACK(np+2*nbr_split-1,'ANNIH_AT_REST');
               0  IF( nbr_split > 1 ) [ wt(np) = wt(np)/nbr_split; ]
               0      " nbr_split > 1 means user wants to use radiative "
               0      " splitting => produce 2*nbr_split annihilation   "
               0      " photons at once                                 "
               0  DO ibr = 1, nbr_split [
               1      "Pick random direction for first gamma
               1      $RANDOMSET costhe; costhe = 2*costhe-1;
               1      sinthe = sqrt(max(0.0,(1-costhe)*(1+costhe)));
               1      $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               1      e(np) = prm; iq(np) = 0;
               1      IF( ibr = 1 ) [ ip = npold; ] ELSE [ ip = np-1; ]
               1      $TRANSFER PROPERTIES TO (np) FROM (ip);
               1      u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = costhe;
               1      np = np+1;
               1      e(np) = prm; iq(np) = 0;
               1      $TRANSFER PROPERTIES TO (np) FROM (np-1);
               1      u(np) = -u(np-1); v(np) = -v(np-1); w(np) = -w(np-1);
               1      np = np+1;
               1  ]
               0  np = np-1;
               0  return; end;
               0
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE BHABHA;
               0  "                                                                  "
               0  "******************************************************************"
               0  "   DISCRETE BHABHA SCATTERING (A CALL TO THIS ROUTINE) HAS BEEN   "
               0  "   ARBITRARILY DEFINED AND CALCULATED TO MEAN BHABHA SCATTERINGS  "
               0  "   WHICH IMPART TO THE SECONDARY ELECTRON SUFFICIENT ENERGY THAT  "
               0  "   IT BE TRANSPORTED DISCRETELY, I.E. E=AE OR T=TE.  IT IS NOT    "
               0  "   GUARANTEED THAT THE FINAL POSITRON WILL HAVE THIS MUCH ENERGY  "
               0  "   HOWEVER.  THE EXACT BHABHA DIFFERENTIAL CROSS SECTION IS USED. "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-BHABHA;   "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:      "
               0                     "COMIN/DEBUG,EGS-VARIANCE-REDUCTION,STACK,"
               0                                  "THRESH,UPHIOT,USEFUL,RANDOM/;"
               0
               0  $DEFINE-LOCAL-VARIABLES-BHABHA;
               0
               0  NPold = NP;      "Set the old stack counter"
               0  PEIP=E(NP); "PRECISE ENERGY OF INCIDENT POSITRON"
               0  EIP=PEIP; "ENERGY OF INCIDENT POSITRON"
               0  PEKIN=PEIP-PRM;  "PRECISE K.E. OF INCIDENT POSITRON"
               0  EKIN=PEKIN;
               0  T0=EKIN/RM;
               0  E0=T0+1.;
               0  YY=1./(T0+2.);
               0  E02=E0*E0;
               0  "BETAI2=E02/(E02-1.);" "BLIF 96/2/1 -- not needed for Bhabha fix-up"
               0  BETA2=(E02-1.)/E02;    "BLIF 96/2/1 -- needed for Bhabha fix-up"
               0  EP0=TE(MEDIUM)/EKIN;
               0  EP0C=1.-EP0;
               0  Y2=YY*YY;
               0  YP=1.-2.*YY;
               0  YP2=YP*YP;
               0  B4=YP2*YP;
               0  B3=B4+YP2;
               0  B2=YP*(3.+Y2);
               0  B1=2.-Y2;
               0  "   SAMPLE BR FROM MINIMUM(EP0) TO 1."
               0  LOOP[$RANDOMSET RNNO03;
               1  BR=EP0/(1.-EP0C*RNNO03);
               1  "   APPLY REJECTION FUNCTION"
               1  $RANDOMSET RNNO04;
               1  "REJF2=EP0C*(BETAI2-BR*(B1-BR*(B2-BR*(B3-BR*B4))));BLIF 96/2/1 -- Bhabha fix-up"
               1  REJF2=(1.0-BETA2*BR*(B1-BR*(B2-BR*(B3-BR*B4)))); "BLIF 96/2/1 -- Bhabha fix-up"
               1  ]UNTIL RNNO04.LE.REJF2 ;
               0  "   IF E- GOT MORE THAN E+, MOVE THE E+ POINTER AND REFLECT B"
               0  $CHECK-STACK(np+1,'BHABHA');
               0  IF (BR.LT.0.5)[IQ(NP+1)=-1;]ELSE[IQ(NP)=-1;IQ(NP+1)=1;BR=1.-BR;]
               0  "THE ABOVE PUTS E+ ON TOP OF STACK IF IT HAS LESS ENERGY"
               0  "   DIVIDE UP THE ENERGY"
               0  BR=max(BR,0.0); "AVOIDS POSSIBLE NEGATIVE NUMBER DUE TO ROUND-OFF"
               0  PEKSE2=BR*EKIN; "PRECISE KINETIC ENERGY OF SECONDARY 'ELECTRON' 2"
               0  PESE1=PEIP-PEKSE2; "PRECISE ENERGY OF SECONDARY 'ELECTRON' 1"
               0  PESE2=PEKSE2+PRM;  "PRECISE ENERGY OF SECONDARY 'ELECTRON' 2"
               0  ESE1=PESE1;
               0  ESE2=PESE2;
               0  E(NP)=PESE1;
               0  E(NP+1)=PESE2;
               0  "   BHABHA ANGLES ARE UNIQUELY DETERMINED BY KINEMATICS"
               0  H1=(PEIP+PRM)/PEKIN;
               0  "   DIRECTION COSINE CHANGE FOR 'OLD' ELECTRON"
               0
               0  "AFB modified the following statement 92/10/28 to avoid"
               0  "numerical difficulties"
               0  "DCOSTH=H1*(PESE1-PRM)/(PESE1+PRM);"
               0  DCOSTH=MIN(1.0D0,H1*(PESE1-PRM)/(PESE1+PRM));
               0
               0  SINTHE=DSQRT(1.D0-DCOSTH);
               0  COSTHE=DSQRT(DCOSTH);
               0  CALL UPHI(2,1);
               0  NP=NP+1;
               0  DCOSTH=H1*(PESE2-PRM)/(PESE2+PRM);
               0  SINTHE=-DSQRT(1.D0-DCOSTH);
               0  COSTHE=DSQRT(DCOSTH);
               0  CALL UPHI(3,2);
               0  RETURN;
               0  "END OF SUBROUTINE BHABHA"  END;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE BREMS;
               0  "                                                                  "
               0  "******************************************************************"
               0  "   Samples bremsstrahlung energy using                            "
               0  "    - Coulomb corrected Bethe-Heitler above 50 MeV                "
               0  "    - Bethe-Heitler below 50 MeV                                  "
               0  "   if ibr_nist = 0, or                                            "
               0  "    - the NIST bremsstrahlung cross section data base             "
               0  "      (prepared in a form of an alias table for rapid sampling)   "
               0  "   if ibr_nist = 1  or                                            "
               0  "    - the NRC bremsstrahlung cross section data base, which is    "
               0  "      the same as the NIST database, but with corrections to      "
               0  "      the electron-electron contribution, which are mostly        "
               0  "      important for low Z and low k                               "
               0  "   if ibr_nist = 2                                                "
               0  "   and direction using                                            "
               0  "    - formula 2BS from from Koch and Motz if IBRDST=1             "
               0  "    - leading term of the brems angular dsstr. if IBRDST=0        "
               0  "    - photon direction = electron direction if IBRDST<0           "
               0  "                                                                  "
               0  "   This version replaces the original EGS4 implementation         "
               0  "   because of a bug discovered in the EGS4 brems routine          "
               0  "   In order to work properly, the parameter DL1,..,DL6            "
               0  "   are re-calculated in subroutine fix_brems which is called      "
               0  "   from HATCH                                                     "
               0  "   In addition, this version has the internal capability of       "
               0  "   bremsstrahlung splitting.                                      "
               0  "   To use bremsstrahlung splitting, set nbr_split (COMON/BREMPR/) "
               0  "   to the desired number > 1 (1 is the default)                   "
               0  "   Be aware that event-by-event energy conservation is NOT        "
               0  "   guaranteed, so don't use for calculations where this is        "
               0  "   important (e.g. calculation of detector response functions)    "
               0  "   The result will be nbr_split photons, all with the weight      "
               0  "   wt(npold)/nbr_split, and an electron with the original weight  "
               0  "   and energy given by the incident energy - energy of last photon"
               0  "                                                                  "
               0  " I. Kawrakow, January 2000                                        "
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-BREMS;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/DEBUG,BREMPR,EGS-VARIANCE-REDUCTION,   "
               0                             "STACK,THRESH,UPHIOT,USEFUL,RANDOM/;"
               0
               0  $DEFINE-LOCAL-VARIABLES-BREMS;
               0  $REAL z2max,z2maxi,aux1,aux3,aux4,aux5,aux2,weight;
               0
               0  IF( nbr_split < 1 ) return;  "i.e. the user can turn off brems production"
               0                               "by setting nbr_split to zero!"
               0
               0  NPold = NP;      "Set the old stack counter"
               0  PEIE=E(NP);      "PRECISE ENERGY OF INCIDENT 'ELECTRON'"
               0  EIE=PEIE;        "ENERGY OF INCIDENT 'ELECTRON'"
               0  weight = wt(np)/nbr_split;
               0
               0  "   DECIDE WHICH DISTRIBUTION TO USE (B-H COULOMB CORRECTED IS     "
               0  "   USED FROM 50 TO 20000 MEV, B-H IS USED 1.5 TO 50 MEV)          "
               0  IF (EIE.LT.50.0)[ L=1; ] ELSE [ L=3; ]
               0  L1 = L+1;
               0
               0  ekin = peie-prm;
               0  brmin = ap(medium)/ekin;
               0  "waux = -log(brmin);"
               0  waux = elke - log_ap(medium); "this saves the time consuming log evaluation"
               0                                "log_ap = log(ap(medium)) is calculated in   "
               0                                "fix_brems for each medium, elke is needed   "
               0                                "in electr to calculate the branching ratios "
               0                                "and therefore it must be known at this point"
               0
               0  IF( ibrdst >= 0 ) [ "inrdst >=0 means we will sample the photon emmision"
               1                      "angle from KM-2BS (ibrdst=1) or from the leading"
               1                      "term (ibrdst=0). If nbr_split > 1, we can re-use"
               1                      "the following quantities several time"
               1
               1      a = u(np); b = v(np); c = w(np);
               1      sinpsi = a*a + b*b;
               1      IF( sinpsi > 1e-20 ) [
               2         sinpsi = sqrt(sinpsi);
               2         sindel = b/sinpsi; cosdel = a/sinpsi;
               2      ]
               1
               1      ztarg = zbrang(medium);
               1      tteie = eie/rm;
               1      beta = sqrt((tteie-1)*(tteie+1))/tteie;
               1      y2max = 2*beta*(1+beta)*tteie*tteie;
               1      y2maxi = 1/y2max;
               1      IF( ibrdst = 1 ) [ z2max = y2max+1; z2maxi = sqrt(z2max); ]
               1
               1  ]
               0
               0  IF( ibr_nist >= 1 ) [
               1      ajj = 1 + (waux + log_ap(medium) - nb_lemin(medium))*nb_dlei(medium);
               1      jj = ajj; ajj = ajj - jj;
               1      IF( jj >  $MXBRES ) [ jj = $MXBRES; ajj = -1; ]
               1  ]
               0
               0  DO ibr = 1,nbr_split [
               1
               1      IF( ibr_nist >= 1 ) [ "use the NIST or NRC bremsstrahlung cross section"
               2                           "data base"
               2          IF( ekin > nb_emin(medium) ) [
               3              $RANDOMSET r1;
               3              IF( r1 < ajj ) [ j = jj+1; ] ELSE [ j = jj; ]
               3              br = alias_sample1($MXBRXS,nb_xdata(0,j,medium),
               3                                 nb_fdata(0,j,medium),
               3                                 nb_wdata(1,j,medium),nb_idata(1,j,medium));
               3          ]
               2          ELSE [ $RANDOMSET br; ]
               2          esg = ap(medium)*exp(br*waux); pesg = esg;
               2          pese = peie - pesg; ese = pese;
               2      ]
               1      ELSE [
               2
               2          LOOP [ "User wants to use Bethe-Heitler"
               3
               3              $RANDOMSET rnno06; $RANDOMSET rnno07;
               3              br = brmin*exp(rnno06*waux);
               3              esg = ekin*br; pesg = esg;
               3              pese = peie - pesg; ese = pese;
               3              delta = esg/eie/ese*delcm(medium); aux = ese/eie;
               3              IF( delta < 1 ) [
               4                  phi1 = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medium));
               4                  phi2 = dl1(l1,medium)+delta*(dl2(l1,medium)+
               4                          delta*dl3(l1,medium));
               4              ]
               3              ELSE [
               4                  phi1 = dl4(l,medium)+dl5(l,medium)*log(delta+dl6(l,medium));
               4                  phi2 = phi1;
               4              ]
               3              rejf = (1+aux*aux)*phi1 - 2*aux*phi2/3;
               3
               3          ] UNTIL (rnno07 < rejf);
               2      ]
               1
               1      "   SET UP THE NEW PHOTON                                          "
               1      np=np+1;
               1      IF( np > $MXSTACK ) [
               2          $egs_fatal('(//a,i6,a//)',' Stack overflow in BREMS! np = ',np+1,
               2                     ' Increase $MXSTACK and try again' );
               2      ]
               1      e(np) = pesg; iq(np) = 0;
               1      $TRANSFER PROPERTIES TO (np) FROM (np-1);
               1      wt(np) = weight;
               1      IF( ibrdst < 0 ) [  "The photon will inherit the direction from "
               2                          "the electron. This option is given so that "
               2                          "the user can implement their own brems angle "
               2                          "schemes via a call to ausgab"
               2          u(np) = u(npold); v(np) = v(npold); w(np) = w(npold);
               2      ]
               1      ELSE [
               2         IF( ibrdst = 1 ) [
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3             ttese = ese/rm; esedei = ttese/tteie;
               3             rjarg1 = 1+esedei*esedei;
               3             rjarg2 = rjarg1 + 2*esedei;
               3             aux = 2*ese*tteie/esg; aux = aux*aux; aux1 = aux*ztarg;
               3             IF( aux1 > 10 ) [ rjarg3 = lzbrang(medium) + (1-aux1)/aux1**2; ]
               3             ELSE [ rjarg3 = log(aux/(1+aux1)); ]
               3             rejmax = rjarg1*rjarg3-rjarg2;
               3             LOOP [
               4                 $RANDOMSET y2tst; $RANDOMSET rtest;
               4                 aux3 = z2maxi/(y2tst+(1-y2tst)*z2maxi);
               4                 rtest = rtest*aux3*rejmax;
               4                 y2tst = aux3**2-1; y2tst1 = esedei*y2tst/aux3**4;
               4                 aux4 = 16*y2tst1-rjarg2; aux5 = rjarg1-4*y2tst1;
               4                 IF( rtest < aux4 + aux5*rjarg3 ) EXIT;
               4                 aux2 = log(aux/(1+aux1/aux3**4));
               4                 rejtst = aux4+aux5*aux2;
               4             ] UNTIL (rtest < rejtst );
               3
               3         ]
               2         ELSE [
               3             $RANDOMSET y2tst; y2tst = y2tst/(1-y2tst+y2maxi);
               3         ]
               2         costhe = 1 - 2*y2tst*y2maxi;
               2         sinthe = sqrt(max((1-costhe)*(1+costhe),0.0));
               2         $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               2         IF( sinpsi >= 1e-10 ) [
               3             us = sinthe*cphi; vs = sinthe*sphi;
               3             u(np) = c*cosdel*us - sindel*vs + a*costhe;
               3             v(np) = c*sindel*us + cosdel*vs + b*costhe;
               3             w(np) = c*costhe - sinpsi*us;
               3         ]
               2         ELSE [
               3             u(np) = sinthe*cphi; v(np) = sinthe*sphi; w(np) = c*costhe;
               3         ]
               2      ]
               1  ]
               0
               0  e(npold) = pese;
               0
               0  RETURN;
               0  "END OF SUBROUTINE BREMS"   END;
               0
               0  "******************************************************************"
               0  "                                                          NRCC    "
               0  SUBROUTINE COMPT;
               0  "                                VERSION 1.00  --  12 JAN 1999     "
               0  "******************************************************************"
               0  "                                                                  "
               0  "   Subroutine for sampling incoherent (Compton) scattering        "
               0  "   If the flag ibcmp(region) is zero, Klein-Nishina is used.      "
               0  "   Otherwise scattering is modelled in the impulse approximation  "
               0  "   (see R.Ribberfors and K.F.Berggren, Phys.Rev.A26 (1982) 3325)  "
               0  "   As the total cross section from PEGS4 is not modified (and thus"
               0  "   calculated using Klein-Nishina), all rejections lead to an     "
               0  "   unscattered photon and a zero energy electron.                 "
               0  "   If a K,L1,L2,L3,M or N vacancy is created, the subsequent      "
               0  "   atomic relaxation is treated in RELAX. This has as a           "
               0  "   consequence that more than one particle can be created as a    "
               0  "   result of an incoherent scattering. The user should therefore  "
               0  "   check their user codes for possible inconsistencies.           "
               0  "                                                                  "
               0  "   I.Kawrakow, January 1999                                       "
               0  "                                                                  "
               0  "   I.Kawrakow, March 2008:                                        "
               0  "      If ibcmp = 2 or 3, the actual bound Compton scattering      "
               0  "      cross section is used and rejections lead to resampling     "
               0  "      instead of rejecting the entire interactions as stated above"
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-COMPT;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/COMPTON-DATA,DEBUG,STACK,THRESH,UPHIOT,USEFUL,RANDOM/;
               0
               0  $DEFINE-LOCAL-VARIABLES-COMPT;
               0  $LOGICAL first_time;
               0  $INTEGER ibcmpl;
               0
               0  NPold = NP;       "Set the old stack counter"
               0  peig=E(NP);       "PRECISE ENERGY OF INCIDENT GAMMA"
               0  ko = peig/rm;     "Gamma energy in units of electron rest energy"
               0  broi = 1 + 2*ko;  "Needed for scattering angle sampling"
               0
               0  $RADC_CHECK;
               0
               0  irl = ir(np); first_time = .true.; ibcmpl = ibcmp(irl);
               0
               0  :resample-compton:;
               0  IF( ibcmpl > 0 ) [ "User wants to take into account binding effects"
               1                     "=>first sample the shell and see whether an    "
               1                     "  interaction is possible                      "
               1      $RANDOMSET rnno17; rnno17 = 1 + rnno17*n_shell(medium);
               1      i = int(rnno17); "rnno17 = rnno17 - i;
               1      IF( rnno17 > eno_array(i,medium) ) i = eno_atbin_array(i,medium);
               1      j = shell_array(i,medium); "j is the shell number in the data list"
               1      Uj = be_array(j);          "Uj is the binding energy in units of rm"
               1
               1      " Binding energy rejection "
               1      IF( ko <= Uj ) [
               2          IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
               2          ELSE             [ goto :resample-compton:;     ]
               2      ]
               1      Jo = Jo_array(j);          "Jo is the Compton profile parameter"
               1
               1  ]
               0
               0  " We always sample the scattering angle from Klein-Nishina"
               0  :RESAMPLE:
               0  ;
               0  IF( ko > 2 ) [    "At high energies the original EGS4 method is most efficient"
               1      IF( first_time ) [
               2          broi2 = broi*broi;
               2          alph1 = Log(broi);
               2          bro   = 1/broi;
               2          alph2 = ko*(broi+1)*bro*bro;
               2          alpha = alph1+alph2;
               2      ]
               1      LOOP [
               2          $RANDOMSET rnno15; $RANDOMSET rnno16;
               2          IF( rnno15*alpha < alph1 ) [ "Use 1/br part"
               3              br = Exp(alph1*rnno16)*bro;
               3          ]
               2          ELSE [  "Use the br part."
               3              br = Sqrt(rnno16*broi2 + (1-rnno16))*bro;
               3          ]
               2          temp = (1-br)/(ko*br); sinthe = Max(0.,temp*(2-temp));
               2          aux = 1+br*br;
               2          rejf3 = aux - br*sinthe;
               2          $RANDOMSET rnno19;
               2      ] UNTIL rnno19*aux.le.rejf3;
               1  ]
               0  ELSE [ "At low energies it is faster to sample br uniformely"
               1      IF( first_time ) [
               2          bro = 1./broi; bro1 = 1 - bro;
               2          rejmax = broi + bro;
               2      ]
               1      LOOP [
               2          $RANDOMSET rnno15; $RANDOMSET rnno16;
               2          br = bro + bro1*rnno15;
               2          temp = (1-br)/(ko*br); sinthe = Max(0.,temp*(2-temp));
               2          rejf3 = 1 + br*br - br*sinthe;
               2      ] UNTIL rnno16*br*rejmax.le.rejf3;
               1  ]
               0  first_time = .false.;
               0
               0  IF(br < bro | br > 1)  [
               1      IF( br < 0.99999/broi | br > 1.00001 ) [
               2          $egs_warning(*,' sampled br outside of allowed range! ',ko,1./broi,br);
               2      ]
               1      goto :RESAMPLE: ;
               1  ]
               0
               0  $RADC_REJECTION;
               0
               0  costhe = 1 - temp;
               0  IF( ibcmp(irl) = 0 ) [ "User wants to use Klein-Nishina, so we are done"
               1      Uj = 0;
               1      goto :FINISHED-COMPTON-SAMPLING:;
               1  ]
               0
               0  " Check for rejection due to the limited range of pzmax "
               0  br2 = br*br;
               0  aux = ko*(ko-Uj)*temp;
               0  aux1 = 2*aux + Uj*Uj;
               0  pzmax = aux - Uj;
               0  IF( pzmax < 0 & pzmax*pzmax >= aux1 ) [
               1      IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
               1      ELSE             [ goto :resample-compton:; ]
               1  ]
               0  pzmax = pzmax/sqrt(aux1);
               0
               0
               0
               0
               0
               0
               0
               0  qc2 = 1 + br*br - 2*br*costhe;
               0  qc  = sqrt(qc2);
               0
               0  IF( pzmax > 1 ) [
               1      pzmax = 1; af = 0; Fmax = 1; fpz = 1;
               1      goto :RETRY-PZ:;
               1  ]
               0
               0  aux3 = 1 + 2*Jo*abs(pzmax);
               0  aux4 = 0.5*(1-aux3*aux3);
               0  fpz  = 0.5*exp(aux4);
               0  af   = qc*(1+br*(br-costhe)/qc2);
               0
               0  IF( af < 0 ) [
               1      IF( pzmax > 0 ) fpz = 1 - fpz;
               1      $RANDOMSET eta_incoh;
               1      IF( eta_incoh > fpz ) [
               2          IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
               2          ELSE             [ goto :resample-compton:; ]
               2      ]
               1      af = 0; Fmax = 1; goto :RETRY-PZ:;
               1  ]
               0
               0  IF( pzmax < -0.15 ) [
               1      Fmax = 1-af*0.15;
               1      fpz1 = fpz*Fmax*Jo;
               1  ]
               0  ELSE IF( pzmax < 0.15 ) [
               1      Fmax = 1 + af*pzmax;
               1      aux3 = 1/(1+0.33267252734*aux3);
               1              "0.33267252734 is p/sqrt(2), p is the parameter from Eq. 7.1.25"
               1              "of Abramowitz and Stegun, needed for approximating Erf        "
               1      aux4 = fpz*aux3*(0.3480242+aux3*(-0.0958798+aux3*0.7478556)) +
               1             erfJo_array(j);
               1      IF( pzmax > 0 ) [
               2          "fpz1 = 1 - Fmax*fpz - 0.31332853433*af/Jo_array(j)*aux4;"
               2            "missing factor 1/2 in the above found by Cerneliu Costescu"
               2            "0.62665706866 is sqrt(Pi/8)"
               2          fpz1 = (1 - Fmax*fpz)*Jo - 0.62665706866*af*aux4;
               2          fpz = 1 - fpz;
               2      ]
               1      ELSE [
               2          "fpz1 = Fmax*fpz - 0.31332853433*af/Jo_array(j)*aux4;"
               2            "missing factor 1/2 in the above found by Cerneliu Costescu"
               2            "0.62665706866 is sqrt(Pi/8)"
               2          fpz1 = Fmax*fpz*Jo - 0.62665706866*af*aux4;
               2      ]
               1  ]
               0  ELSE [
               1      Fmax = 1 + af*0.15;
               1      fpz1 = (1 - Fmax*fpz)*Jo;
               1      fpz = 1 - fpz;
               1  ]
               0  $RANDOMSET eta_incoh;
               0  IF(eta_incoh*Jo > fpz1 ) [
               1      IF( ibcmpl = 1 ) [ goto :INTERACTION-REJECTED:; ]
               1      ELSE             [ goto :resample-compton:; ]
               1  ]
               0
               0  "At this point, all rejections are handled, now we need to sample pz "
               0  "between -1 and pzmax using the Compton profile of the selected shell"
               0  "and F(pz,cos(theta)) as a rejection function                        "
               0
               0  :RETRY-PZ:;
               0  IF( ibcmpl ~= 2 ) [
               1    $RANDOMSET rnno18; rnno18 = rnno18*fpz;
               1    IF( rnno18 < 0.5 ) [
               2      rnno18 = Max(1e-30,2*rnno18);
               2      pz = 0.5*(1-Sqrt(1-2*Log(rnno18)))/Jo;
               2    ]
               1    ELSE [
               2      rnno18 = 2*(1-rnno18);
               2      pz = 0.5*(Sqrt(1-2*Log(rnno18))-1)/Jo;
               2    ]
               1    IF( abs(pz) > 1 ) goto :RETRY-PZ:;
               1        "Due to the non-relativistic approximation"
               1        "for pz, it has to be between -1 and 1    "
               1    IF( pz < 0.15  ) [
               2      IF( pz < -0.15 ) [ frej = 1 - af*0.15; ]
               2      ELSE             [ frej = 1 + af*pz;   ]
               2      $RANDOMSET eta;
               2      IF( eta*Fmax > frej ) goto :RETRY-PZ:;
               2    ]
               1    "If pz > 0.15, F is always 1 => no need for rejection"
               1  ]
               0  ELSE [ pz = 0; Uj = 0; "i.e., no Doppler broadenning and no binding energy" ]
               0
               0  " Calculate energy of scattered photon "
               0  pz2 = pz*pz;
               0  IF( abs(pz) < 0.01 ) [
               1      br = br*(1 + pz*(qc + (br2-costhe)*pz));
               1  ]
               0  ELSE [
               1      aux =  1 - pz2*br*costhe; aux1 = 1 - pz2*br2;
               1      aux2 = qc2 - br2*pz2*sinthe;
               1      IF( aux2 > 1e-10 ) [ br = br/aux1*(aux+pz*Sqrt(aux2)); ]
               1  ]
               0  Uj = Uj*prm;
               0
               0  :FINISHED-COMPTON-SAMPLING:
               0  pesg = br*peig; pese = peig - pesg - Uj + prm;
               0  sinthe = Sqrt(sinthe);
               0  call uphi(2,1); e(np) = pesg;
               0  aux = 1 + br*br - 2*br*costhe;
               0  IF( aux > 1e-8 ) [
               1      costhe = (1-br*costhe)/Sqrt(aux);
               1      sinthe = (1-costhe)*(1+costhe);
               1      IF( sinthe > 0 ) [ sinthe = -Sqrt(sinthe); ]
               1      ELSE [ sinthe = 0; ]
               1  ] ELSE [ costhe = 0; sinthe = -1; ]
               0  np = np + 1;
               0  $CHECK-STACK(np,'COMPT');
               0  call uphi(3,2);
               0  e(np) = pese; iq(np) = -1;
               0
               0  IF( ibcmpl = 1 | ibcmpl = 3 ) [
               1
               1      " Shell vacancy "
               1      IF( Uj > 1e-3 ) [
               2          edep = pzero;
               2
               2          call relax(Uj,shn_array(j),iz_array(j));
               2          "relax will put all particles with energies above ecut,pcut on the "
               2          "stack, the remaining energy will be scored in edep and deposited  "
               2          "locally (via the call to ausgab below)                            "
               2      ]
               1      ELSE [
               2          edep = Uj;
               2          edep_local = edep;
               2          $AUSCALL($SPHOTONA);
               2      ]
               1      IF( edep > 0 ) [ $AUSCALL($PHOTXAUS); "generates IARG = 4 call" ]
               1
               1  ]
               0
               0  " Now play Russian Roulette with resulting electrons if the user asked for it"
               0  $PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold+1; "TO NP"
               0
               0  return;
               0
               0  :INTERACTION-REJECTED:
               0  " Create here a zero energy electron if required (check user codes) "
               0  return;
               0  end;
               0
               0  "******************************************************************"
               0  "                                                          NRCC    "
               0  SUBROUTINE old_COMPT;
               0  "                                VERSION 1.00  --  12 JAN 1999     "
               0  "******************************************************************"
               0  "                                                                  "
               0  "   Subroutine for sampling incoherent (Compton) scattering        "
               0  "   If the flag ibcmp(region) is zero, Klein-Nishina is used.      "
               0  "   Otherwise scattering is modelled in the impuls approximation   "
               0  "    (see R.Ribberfors and K.F.Berggren, Phys.Rev.A26 (1982) 3325) "
               0  "   As the total cross section from PEGS4 is not modified (and thus"
               0  "   calculated using Klein-Nishina), all rejections leed to an     "
               0  "   unscattered photon and a zero energy electron.                 "
               0  "   If a K,L1,L2,L3,M or N vacancy is created, the subsequent      "
               0  "   atomic relaxation is treated in RELAX. This has as a           "
               0  "   consequence that more than one particle can be created as a    "
               0  "   result of an incoherent scattering. The user should therefore  "
               0  "   check their user codes for possible inconsistencies.           "
               0  "   This version ignores the function F(cos(theta),pz).            "
               0  "   This leads to a small error (at least compared to the cross    "
               0  "   section we want to sample) at low energies (say, below Z keV)  "
               0  "   The advantage is that it is substantially faster then the      "
               0  "   version with F taken into account.                             "
               0  "                                                                  "
               0  "                                                                  "
               0  "   I.Kawrakow, January 1999                                       "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-COMPT;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/COMPTON-DATA,EGS-VARIANCE-REDUCTION,DEBUG, "
               0                                 "STACK,THRESH,UPHIOT,USEFUL,RANDOM/;"
               0
               0  $DEFINE-LOCAL-VARIABLES-COMPT-old;
               0
               0  i_survived_RR = 0;"0=> all survived russian roulette if played"
               0                    "must set here since, if bound compton and event is"
               0                    "rejected, this wouldn't be set to the new 0 value"
               0  NPold = NP;       "Set the old stack counter"
               0  peig=E(NP);       "PRECISE ENERGY OF INCIDENT GAMMA"
               0  ko = peig/rm;     "Gamma energy in units of electron rest energy"
               0  broi = 1 + 2*ko;  "Needed for scattering angle sampling"
               0
               0  irl = ir(np);
               0  IF( ibcmp(irl) = 1 ) [ "User wants to take into account binding effects"
               1                         "=>first sample the shell and see whether an    "
               1                         "  interaction is possible                      "
               1      $RANDOMSET rnno17;
               1      DO i=1,n_shell(medium) [
               2          rnno17 = rnno17 - eno_array(i,medium);
               2          IF( rnno17 <= 0 ) EXIT;
               2      ]
               1      j = shell_array(i,medium); "j is the shell number in the data list"
               1      Uj = be_array(j);          "Uj is the binding energy in units of rm"
               1
               1      " Binding energy rejection "
               1      IF( ko <= Uj ) [ goto :INTERACTION-REJECTED-old:; ]
               1
               1  ]
               0
               0  " We always sample the scattering angle from Klein-Nishina"
               0  :RESAMPLE-old:
               0  ;
               0  IF( ko > 2 ) [    "At high energies the original EGS4 method is most efficient"
               1      broi2 = broi*broi;
               1      alph1 = Log(broi);
               1      alph2 = ko*(broi+1)/broi2;
               1      alpha = alph1/(alph1+alph2);
               1      LOOP [
               2          $RANDOMSET rnno15; $RANDOMSET rnno16;
               2          IF( rnno15 < alpha ) [ "Use 1/br part"
               3              br = Exp(alph1*rnno16)/broi;
               3          ]
               2          ELSE [  "Use the br part."
               3              br = Sqrt(rnno16 + (1-rnno16)/broi2);
               3          ]
               2          temp = (1-br)/ko/br; sinthe = Max(0.,temp*(2-temp));
               2          rejf3 = 1 - br*sinthe/(1+br*br);
               2          $RANDOMSET rnno19;
               2      ] UNTIL rnno19.le.rejf3;
               1  ]
               0  ELSE [ "At low energies it is faster to sample br uniformely"
               1      bro = 1./broi; bro1 = 1 - bro;
               1      rejmax = broi + bro;
               1      LOOP [
               2          $RANDOMSET rnno15; $RANDOMSET rnno16;
               2          br = bro + bro1*rnno15;
               2          temp = (1-br)/ko/br; sinthe = Max(0.,temp*(2-temp));
               2          rejf3 = (br + 1./br - sinthe)/rejmax;
               2      ] UNTIL rnno16.le.rejf3;
               1  ]
               0
               0  IF(br < 1./broi | br > 1)  [
               1      IF( br < 0.99999/broi | br > 1.00001 ) [
               2      $egs_warning(*,' sampled br outside of allowed range! ',ko,1./broi,br);
               2      ]
               1      goto :RESAMPLE-old: ;
               1  ]
               0
               0  IF( ibcmp(irl) = 0 ) [ "User wants to use Klein-Nishina, so we are done"
               1      Uj = 0; costhe = 1 - temp;
               1      goto :FINISHED-COMPTON-SAMPLING-old:;
               1  ]
               0
               0  " Sample Doppler broadening using the Compton profile of the selected shell"
               0  br2 = br*br;
               0  costhe = 1 - temp;
               0  aux = ko*(ko-Uj)*temp; aux1 = aux-Uj;
               0  pzmax2 = aux1*aux1/(2*aux+Uj*Uj);
               0  :RETRY-PZ-old:;
               0  $RANDOMSET rnno18;
               0  IF( rnno18 < 0.5 ) [
               1      rnno18 = Max(1e-30,2*rnno18);
               1      pz = 0.5*(1-Sqrt(1-2*Log(rnno18)))/Jo_array(j);
               1      pz2 = pz*pz;
               1      IF( (pz2 <= pzmax2) & (aux1 < 0) ) [goto :INTERACTION-REJECTED-old:; ]
               1  ]
               0  ELSE [
               1      IF( aux1 < 0 ) [goto :INTERACTION-REJECTED-old:; ]
               1      rnno18 = 2*(1-rnno18);
               1      pz = 0.5*(Sqrt(1-2*Log(rnno18))-1)/Jo_array(j);
               1      pz2 = pz*pz;
               1      IF( pz2 >= pzmax2 ) [goto :INTERACTION-REJECTED-old:; ]
               1  ]
               0  IF( abs(pz) > 1 ) goto :RETRY-PZ-old:;
               0
               0  " Calculate energy of scattered photon "
               0  aux =  1 - pz2*br*costhe; aux1 = 1 - pz2*br2;
               0  aux2 = 1-2*br*costhe+br2*(1-pz2*sinthe);
               0  IF( aux2 > 1e-10 ) [ br = br/aux1*(aux+pz*Sqrt(aux2)); ]
               0  Uj = Uj*prm;
               0
               0  :FINISHED-COMPTON-SAMPLING-old:
               0  pesg = br*peig; pese = peig - pesg - Uj + prm;
               0  sinthe = Sqrt(sinthe);
               0  call uphi(2,1); e(np) = pesg;
               0  aux = 1 + br*br - 2*br*costhe;
               0  IF( aux > 1e-8 ) [
               1      costhe = (1-br*costhe)/Sqrt(aux);
               1      sinthe = (1-costhe)*(1+costhe);
               1      IF( sinthe > 0 ) [ sinthe = -Sqrt(sinthe); ]
               1      ELSE [ sinthe = 0; ]
               1  ] ELSE [ costhe = 0; sinthe = -1; ]
               0  np = np + 1;
               0  $CHECK-STACK(np,'COMPT');
               0  call uphi(3,2);
               0  e(np) = pese; iq(np) = -1;
               0
               0  IF( ibcmp(irl) = 1 ) [
               1
               1      " Shell vacancy "
               1      IF( Uj > 1e-3 ) [
               2          edep = 0;
               2
               2          call relax(Uj,shn_array(j),iz_array(j));
               2            "relax will put all particles with energies above ecut,pcut on the "
               2            "stack, the remaining energy will be scored in edep and deposited  "
               2            "localy (via the call to ausgab below)                             "
               2      ]
               1      ELSE [ edep = Uj; ]
               1      IF( edep > 0 ) [ $AUSCALL($PHOTXAUS); "generates IARG = 4 call" ]
               1
               1  ]
               0
               0  " Now play Russian Roulette with resulting electrons if the user asked for it"
               0  $PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold+1; "TO NP"
               0
               0  return;
               0
               0  :INTERACTION-REJECTED-old:
               0  " Create here a zero energy electron if required (check user codes) "
               0  return;
               0  end;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               NATIONAL RESEARCH COUNCIL OF CANADA"
               0  SUBROUTINE ELECTR(IRCODE);
               0  "******************************************************************"
               0  "   This subroutine has been almost completely recoded to include  "
               0  "   the EGSnrc enhancements.                                       "
               0  "                                                                  "
               0  "   Version 1.0   Iwan Kawrakow       Complete recoding            "
               0  "   Version 1.1   Iwan Kawrakow       Corrected implementation of  "
               0  "                                     fictitious method (important "
               0  "                                     for low energy transport     "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $INTEGER IRCODE;
               0
               0  $COMIN-ELECTR; "default replacement produces the following:
               0                 "COMIN/DEBUG,BOUNDS,EGS-VARIANCE-REDUCTION, ELECIN,EPCONT,"
               0                          "ET-Control,MEDIA,MISC,STACK,THRESH,UPHIIN,"
               0                          "UPHIOT,USEFUL,USER,RANDOM/;"
               0  ;COMIN/EII-DATA/;
               0
               0  $REAL lambda_max, sigratio, u_tmp, v_tmp, w_tmp;
               0  LOGICAL random_tustep;
               0
               0  $DEFINE-LOCAL-VARIABLES-ELECTR;
               0
               0
               0
               0
               0
               0  data ierust/0/;         "To count negative ustep's"
               0
               0  save ierust;
               0
               0  $CALL-USER-ELECTRON;
               0
               0  ircode = 1; "Set up normal return-which means there is a photon
               0              "with less available energy than the lowest energy electron,
               0              "so return to shower so it can call photon to follow it.
               0              "(For efficiency's sake, we like to stay in this routine
               0              " as long as there are electrons to process. That's why this
               0              " apparently convoluted scheme of STACK contro is effected.)
               0
               0  irold = ir(np);    "Initialize previous region
               0                     "(ir() is an integer that is attached to the particle's
               0                     " phase space. It contains the region
               0                     " number that the current particle is in.
               0                     " Np is the stack pointer, it points to where on the
               0                     " stack the current particle is.)
               0  irl    = irold;    "region number in local variable
               0
               0
               0  $start_new_particle;
               0  " Default replacement for the above is medium = med(irl); "
               0  " This is made a macro so that it can be replaced with a call to a "
               0  " user provided function start_new_particle(); for the C/C++ interface "
               0
               0  :NEWELECTRON:LOOP
               0  [
               1      "Go once through this loop for each 'new' electron whose charge and
               1      "energy has not been checked
               1
               1      lelec = iq(np); "Save charge in local variable
               1                      "(iq = -1 for electrons, 0 for photons and 1 for positrons)
               1      qel   = (1+lelec)/2; " = 0 for electrons, = 1 for positrons "
               1      peie  = e(np);  "precise energy of incident electron (double precision)
               1      eie   = peie;   "energy incident electron (conversion to single)
               1
               1      IF(eie <= ecut(irl)) [go to :ECUT-DISCARD:;]
               1          "(Ecut is the lower transport threshold.)
               1
               1      "medium = med(irl);" "(This renders the above assignment redundant!)
               1      "The above assignment is unnecessary, IK, June 2003"
               1
               1      IF(WT(NP) = 0.0) [go to :USER-ELECTRON-DISCARD:;] "added May 01"
               1
               1      :TSTEP:LOOP
               1      [
               2          "Go through this loop each time we recompute distance to an interaction
               2
               2
               2
               2          compute_tstep = .true.; "MFP resampled => calculate distance to the
               2                                  "interaction in the USTEP loop
               2          eke = eie - rm; "moved here so that kinetic energy will be known"
               2                          "to user even for a vacuum step, IK January 2000"
               2          IF(medium ~= 0)
               2          [
               3              "Not vacuum. Must sample to see how far to next interaction.
               3
               3              $SELECT-ELECTRON-MFP;
               3                  " Default FOR $SELECT-ELECTRON-MFP; is: $RANDOMSET rnne1;
               3                  "                                       demfp = -log(rnne1);
               3                  "($RANDOMSET is a macro'ed random number generator)
               3                  "(demfp = differential electron mean free path)
               3
               3              elke = log(eke);
               3              "(eke = kinetic energy, rm = rest mass, all in units of MeV)
               3              $SET INTERVAL elke,eke; "Prepare to approximate cross section
               3
               3              $EVALUATE-SIG0;
               3                 "The fix up of the fictitious method uses cross section per"
               3                 "energy loss. Therefore, demfp/sig is sub-threshold energy loss"
               3                 "until the next discrete interaction occures (see below)"
               3                 "As this quantity is a single constant for a material,"
               3                 "$SET INTERVAL is not necessary at this point. However, to not"
               3                 "completely alter the logic of the TSTEP and USTEP loops,"
               3                 "this is left for now"
               3
               3          ] "end non-vacuum test
               2
               2          :USTEP:LOOP
               2          [
               3              "Here for each check with user geometry.
               3              "Compute size of maximum acceptable step, which is limited
               3              "by multiple scattering or other approximations.
               3              IF(medium = 0)
               3              [
               4                      "vacuum
               4                      tstep = vacdst; ustep = tstep; tustep = ustep;
               4                      callhowfar = .true.; "Always call HOWFAR for vacuum steps!"
               4
               4                      "(Important definitions:
               4                      " tstep  = total pathlength to the next discrete interaction
               4                      " vacdst = infinity (actually 10^8)
               4                      " tustep = total pathlength of the electron step
               4                      " ustep  = projected transport distance in the
               4                      "          direction of motion at the start of the step
               4                      " Note that tustep and ustep are modified below.
               4                      " The above provide defaults.)
               4
               4                      " EM field step size restriction in vacuum
               4                      $SET-TUSTEP-EM-FIELD;
               4                      ustep = tustep;
               4              ]
               3              ELSE
               3              [
               4                  "non-vacuum
               4                  $SET-RHOF;    "density ratio scaling template
               4                                "EGS allows the density to vary
               4                                "continuously (user option)
               4
               4                  $SCALE-SIG0;
               4                  IF(sig <= 0)
               4                  [
               5                      "This can happen if the threshold for brems,
               5                      "(ap + rm), is greater than ae.  Moller threshold is
               5                      "2*ae - rm. If sig is zero, we are below the
               5                      "thresholds for both bremsstrahlung and Moller.
               5                      "In this case we will just lose energy by
               5                      "ionization loss until we go below cut-off. Do not
               5                      "assume range is available, so just ask for step
               5                      "same as vacuum.  Electron transport will reduce
               5                      "into little steps.
               5                      "(Note: ae is the lower threshold for creation of a
               5                      "       secondary Moller electron, ap is the lower
               5                      "       threshold for creation of a brem.)
               5                      tstep = vacdst;
               5                      sig0 = 1.E-15;
               5                  ]
               4                  ELSE
               4                  [
               5                      $CALCULATE-TSTEP-FROM-DEMFP;
               5                  ] "end sig if-else
               4
               4                  "calculate stopping power"
               4                  IF(lelec < 0) [$EVALUATE dedx0 USING ededx(elke);] "e-"
               4                  ELSE          [$EVALUATE dedx0 USING pdedx(elke);] "e+"
               4                  dedx  = rhof*dedx0;
               4
               4                  "Determine maximum step-size (Formerly $SET-TUSTEP)
               4                  $EVALUATE tmxs USING tmxs(elke);
               4                  tmxs = tmxs/rhof;
               4
               4                  "Compute the range to E_min(medium) (e_min is the first
               4                  "energy in the table). Do not go more than range.
               4                  "Don't replace this macro and don't override range, because
               4                  "the energy loss evaluation below relies on the accurate
               4                  "(and self-consistent) evaluation of range!
               4                  $COMPUTE-RANGE;
               4
               4                  "The RANDOMIZE-TUSTEP option as coded by AFB forced the
               4                  "electrons to approach discrete events (Moller,brems etc.)
               4                  "only in a single scattering mode => waste of CPU time.
               4                  "Moved here and changed by IK Oct 22 1997
               4                  random_tustep = $RANDOMIZE-TUSTEP;
               4                  IF(random_tustep)
               4                  [
               5                      $RANDOMSET rnnotu;
               5                      tmxs = rnnotu*min(tmxs,smaxir(irl));
               5                  ]
               4                  ELSE
               4                  [
               5                      tmxs = min(tmxs,smaxir(irl));
               5                  ]
               4                  tustep = min(tstep,tmxs,range);
               4                  $SET-TUSTEP-EM-FIELD; "optional tustep restriction in EM field
               4
               4                  $CALL-HOWNEAR(tperp);
               4                  dnear(np) = tperp;
               4                  $RANGE-DISCARD;       "optional regional range rejection for"
               4                                        "particles below e_max_rr if i_do_rr set"
               4
               4                  $USER-RANGE-DISCARD;  "default is ;, but user may implement"
               4
               4                  $SET-SKINDEPTH(eke,elke);
               4                    "This macro sets the minimum step size for a condensed"
               4                    "history (CH) step. When the exact BCA is used, the minimum"
               4                    "CH step is determined by efficiency considerations only"
               4                    "At about 3 elastic MFP's single scattering becomes more"
               4                    "efficient than CH and so the algorithm switches off CH"
               4                    "If one of the various inexact BCA's is invoked, this macro"
               4                    "provides a simple way to include more sophisticated"
               4                    "decisions about the maximum acceptable approximated CH step"
               4
               4                  tustep = min(tustep,max(tperp,skindepth));
               4
               4                  "The transport logic below is determined by the logical
               4                  "variables callhhowfar, domultiple and dosingle
               4                  "
               4                  "There are the following possibilities:
               4                  "
               4                  "   callhowfar = .false.  This indicates that the
               4                  "   ====================  intended step is shorter than tperp
               4                  "                         independent of BCA used
               4                  "  - domultiple = .false. dosingle = .false. and
               4                  "                         callmsdist = .true.
               4                  "       ==> everything has been done in msdist
               4                  "  - domultiple = .true. and dosingle = .false.
               4                  "       ==> should happen only if exact_bca = .false.
               4                  "           indicates that MS remains to be done
               4                  "  - domultiple = .false. and dosingle = .true.
               4                  "       ==> should happen only if exact_bca = .true.
               4                  "           sampled distance to a single scattering event is
               4                  "           shorter than tperp ==> do single scattering at the
               4                  "           end of the step
               4                  "  - domultiple = .true. and dosingle = .true.
               4                  "       ==> error condition, something with the logic is wrong!
               4                  "
               4                  "   callhowfar = .true. This indicates that the intended step
               4                  "   =================== is longer than tperp and forces a
               4                  "                       call to hawfar which returns the
               4                  "                       straight line distance to the boundary
               4                  "                       in the initial direction of motion
               4                  "                       (via a modification of ustep)
               4                  "  - domultiple = .false. and dosingle = .false.
               4                  "       ==> should happen only of exact_bca=.true.
               4                  "           simply put the particle on the boundary
               4                  "  - domultiple = .false. and dosingle = .true.
               4                  "       ==> should happen only of exact_bca=.true.
               4                  "           single elastic scattering has to be done
               4                  "  - domultiple = .true. and dosingle = .false.
               4                  "       ==> should happen only of exact_bca=.false.
               4                  "           indicates that MS remains to be done
               4                  "  - domultiple = .true. and dosingle = .true.
               4                  "       ==> error condition, something with the logic is wrong!
               4
               4                  "IF(tustep <= tperp & tustep > skindepth)"
               4                  "This statement changed to be consistent with PRESTA-I"
               4                  count_all_steps = count_all_steps + 1;
               4                  is_ch_step = .false.;
               4                  IF((tustep <= tperp) & ((~exact_bca) | (tustep > skindepth)))
               4                  [
               5                      "We are further way from a boundary than a skindepth, so
               5                      "perform a normal condensed-history step
               5                      callhowfar = .false.; "Do not call HAWFAR
               5                      domultiple = .false.; "Multiple scattering done here
               5                      dosingle   = .false.; "MS => no single scattering
               5                      callmsdist = .true.;  "Remember that msdist has been called
               5
               5                      "Fourth order technique for de
               5                      $COMPUTE-ELOSS-G(tustep,eke,elke,lelke,de);
               5
               5                      tvstep = tustep; is_ch_step = .true.;
               5
               5                      IF (transport_algorithm = $PRESTA-II)
               5                      [
               6                        call msdist_pII
               6                        (
               6                          "Inputs
               6                          eke,de,tustep,rhof,medium,qel,spin_effects,
               6                          u(np),v(np),w(np),x(np),y(np),z(np),
               6                          "Outputs
               6                          uscat,vscat,wscat,xtrans,ytrans,ztrans,ustep
               6                        );
               6                      ]
               5                      ELSE
               5                      [
               6                        call msdist_pI
               6                        (
               6                          "Inputs
               6                          eke,de,tustep,rhof,medium,qel,spin_effects,
               6                          u(np),v(np),w(np),x(np),y(np),z(np),
               6                          "Outputs
               6                          uscat,vscat,wscat,xtrans,ytrans,ztrans,ustep
               6                        );
               6                      ]
               5                  ]
               4                  ELSE
               4                  [
               5                      "We are within a skindepth from a boundary, invoke
               5                      "one of the various boundary-crossing algorithms
               5                      callmsdist = .false.;
               5                           "Remember that msdist has not been called
               5                      IF (exact_bca)
               5                      [
               6                          "Cross the boundary in a single scattering mode
               6                          domultiple = .false.; "Do not do multiple scattering
               6                          "Sample the distance to a single scattering event
               6                          $RANDOMSET rnnoss;
               6                          IF( rnnoss < 1.e-30 ) [
               7                              rnnoss = 1.e-30;
               7                          ]
               6                          lambda = - Log(1 - rnnoss);
               6                          lambda_max = 0.5*blccl*rm/dedx*(eke/rm+1)**3;
               6                          IF( lambda >= 0 & lambda_max > 0 ) [
               7                              IF( lambda < lambda_max ) [
               8                                  tuss=lambda*ssmfp*(1-0.5*lambda/lambda_max);
               8                              ]
               7                              ELSE [
               8                                tuss = 0.5 * lambda * ssmfp;
               8                              ]
               7                              IF (tuss < tustep) [
               8                                  tustep = tuss;
               8                                  dosingle = .true.;
               8                              ]
               7                              ELSE [
               8                                  dosingle = .false.;
               8                              ]
               7                          ]
               6                          ELSE [
               7                            $egs_warning(*,' lambda > lambda_max: ',
               7                               lambda,lambda_max,' eke dedx: ',eke,dedx,
               7                               ' ir medium blcc: ',ir(np),medium,blcc(medium),
               7                               ' position = ',x(np),y(np),z(np));
               7                            dosingle = .false.;
               7                            np=np-1; return;
               7                          ]
               6                          ustep = tustep;
               6                      ]
               5                      ELSE
               5                      [
               6                          "Boundary crossing a la EGS4/PRESTA-I but using
               6                          "exact PLC
               6                          dosingle = .false.;
               6                          domultiple = .true.;
               6                          $SET-USTEP;
               6                      ]
               5                      IF(ustep < tperp)
               5                      [
               6                          callhowfar = .false.;
               6                      ]
               5                      ELSE
               5                      [
               6                          callhowfar = .true.;
               6                      ]
               5                  ]
               4              ] "end non-vacuum test
               3
               3              $SET-USTEP-EM-FIELD;  "additional ustep restriction in em field
               3                                    "default for $SET-USTEP-EM-FIELD; is ;(null)
               3              irold  = ir(np); "save current region
               3              irnew  = ir(np); "default new region is current region
               3              idisc  = 0; "default is no discard (this flag is initialized here)
               3              ustep0 = ustep; "Save the intended ustep."
               3
               3              "IF(callhowfar) [ call howfar; ]"
               3              $CALL-HOWFAR-IN-ELECTR; "The above is the default replacement"
               3
               3              "Now see if user requested discard
               3              IF(idisc > 0) "(idisc is returned by howfar)
               3              [
               4                  "User requested immediate discard
               4                  go to :USER-ELECTRON-DISCARD:;
               4              ]
               3
               3              $CHECK-NEGATIVE-USTEP;
               3
               3              IF(ustep = 0 | medium = 0)
               3              [
               4                  "Do fast step
               4                  IF(ustep ~= 0)
               4                  [
               5                      "Step in vacuum
               5                      vstep  = ustep;
               5                      tvstep = vstep;
               5                      "( vstep is ustep truncated (possibly) by howfar
               5                      " tvstep is the total curved path associated with vstep)
               5                      edep = pzero; "no energy loss in vacuum
               5                      $VACUUM-TRANSPORT-EM-FIELD;
               5                          "additional vacuum transport in em field
               5                      e_range = vacdst;
               5                      $AUSCALL($TRANAUSB);
               5                      "Transport the particle
               5                      x(np) = x(np) + u(np)*vstep;
               5                      y(np) = y(np) + v(np)*vstep;
               5                      z(np) = z(np) + w(np)*vstep;
               5                      dnear(np) = dnear(np) - vstep;
               5                          "(dnear is distance to the nearest boundary
               5                          " that goes along with particle stack and
               5                          " which the user's howfar can supply (option)
               5                      $SET-ANGLES-EM-FIELD;
               5                          "default for $SET-ANGLES-EM-FIELD; is ; (null)
               5                           "(allows for EM field deflection
               5                  ] "end of vacuum step
               4
               4                  IF(irnew ~= irold) [ $electron_region_change; ];
               4
               4                  IF(ustep ~= 0) [$AUSCALL($TRANAUSA);]
               4                  IF(eie <= ecut(irl)) [go to :ECUT-DISCARD:;]
               4                  IF(ustep ~= 0 & idisc < 0) [go to :USER-ELECTRON-DISCARD:;]
               4                  NEXT :TSTEP: ; "(Start again at :TSTEP:)
               4
               4              ] "Go try another big step in (possibly) new medium
               3
               3              vstep = ustep;
               3
               3              IF(callhowfar)
               3              [
               4                  IF(exact_bca)
               4                  [
               5                      "If callhowfar=.true. and exact_bca=.true. we are"
               5                      "in a single scattering mode"
               5                      tvstep = vstep;
               5                      IF(tvstep ~= tustep)
               5                      [
               6                         "Boundary was crossed. Shut off single scattering"
               6                          dosingle = .false.;
               6                      ]
               5                  ]
               4                  ELSE
               4                  [
               5                      "callhowfar=.true. and exact_bca=.false."
               5                      "=>we are doing an approximate CH step"
               5                      "calculate the average curved path-length corresponding"
               5                      "to vstep"
               5                      $SET-TVSTEP;
               5                  ]
               4                  "Fourth order technique for dedx
               4                  "Must be done for an approx. CH step or a
               4                  "single scattering step.
               4                  $COMPUTE-ELOSS-G(tvstep,eke,elke,lelke,de);
               4              ]
               3              ELSE
               3              [
               4                 "callhowfar=.false. => step has not been reduced due to
               4                 "                      boundaries
               4                 tvstep = tustep;
               4                 IF ( ~callmsdist )
               4                 [
               5                    "Second order technique for dedx
               5                    "Already done in a normal CH step with call to msdist
               5                    $COMPUTE-ELOSS-G(tvstep,eke,elke,lelke,de);
               5                 ]
               4              ]
               3
               3              $SET-TVSTEP-EM-FIELD; "additional path length correction in em field
               3                  "( Calculates tvstep given vstep
               3                  " default for $SET-TVSTEP-EM-FIELD; is ; (null)
               3
               3              save_de = de;     "the energy loss is used to calculate the number
               3                                "of MFP gone up to now. If energy loss
               3                                "fluctuations are implemented, de will be
               3                                "changed in $DE-FLUCTUATION; => save
               3
               3              "The following macro template allows the user to change the
               3              "ionization loss.
               3              "(Provides a user hook for Landau/Vavilov processes)
               3              $DE-FLUCTUATION;
               3                  "default for $DE-FLUCTUATION; is ; (null)
               3              edep = de; "energy deposition variable for user
               3              $ADD-WORK-EM-FIELD;  "e-loss or gain in em field
               3                  "Default for $ADD-WORK-EM-FIELD; is ; (null)
               3              ekef = eke - de;  "(final kinetic energy)
               3              eold = eie;       "save old value
               3              enew = eold - de; "energy at end of transport
               3
               3              "Now do multiple scattering
               3              IF ( ~callmsdist )   "everything done if callmsdist = .true.
               3              [
               4                  IF ( domultiple )
               4                  [
               5                      "Approximated CH step => do multiple scattering
               5                      "
               5                      "ekems, elkems, beta2 have been set in either $SET-TUSTEP
               5                      "or $SET-TVSTEP if spin_effects is .true., they are
               5                      "not needed if spin_effects is .false.
               5                      "
               5                      "chia2,etap,xi,xi_corr are also set in the above macros
               5                      "
               5                      "qel (0 for e-, 1 for e+) and medium are now also required
               5                      "(for the spin rejection loop)
               5                      "
               5                      lambda = blccl*tvstep/beta2/etap/(1+chia2);
               5                      xi = xi/xi_corr;
               5                      findindex = .true.; spin_index = .true.;
               5                      call mscat(lambda,chia2,xi,elkems,beta2,qel,medium,
               5                                 spin_effects,findindex,spin_index,
               5                                 costhe,sinthe);
               5                  ]
               4                  ELSE
               4                  [
               5                      IF(dosingle)
               5                      [
               6                         "Single scattering
               6
               6                         ekems = Max(ekef,ecut(irl)-rm);
               6                         p2 = ekems*(ekems + rmt2);
               6                         beta2 = p2/(p2 + rmsq);
               6                         chia2 = xcc(medium)/(4*blcc(medium)*p2);
               6                         IF( spin_effects ) [
               7                           elkems = Log(ekems);
               7                           $SET INTERVAL elkems,eke;
               7                           IF(lelec < 0) [$EVALUATE etap USING etae_ms(elkems);]
               7                           ELSE          [$EVALUATE etap USING etap_ms(elkems);]
               7                           chia2 = chia2*etap;
               7                         ]
               6                         call sscat(chia2,elkems,beta2,qel,medium,
               6                                    spin_effects,costhe,sinthe);
               6                      ]
               5                      ELSE
               5                      [
               6                         theta  = 0; "No deflection in single scattering model
               6                         sinthe = 0;
               6                         costhe = 1;
               6                      ]
               5                  ]
               4              ]
               3
               3              "We now know distance and amount of energy loss for this step,
               3              "and the angle by which the electron will be scattered. Hence,
               3              "it is time to call the user and inform him of this transport,
               3              "after which we will do it.
               3
               3              "Now transport, deduct energy loss, and do multiple scatter.
               3              e_range = range;
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3
               3              IF( callmsdist ) [
               4                 "Deflection and scattering have been calculated/sampled in msdist
               4                  u_final = uscat;
               4                  v_final = vscat;
               4                  w_final = wscat;
               4                  x_final = xtrans;
               4                  y_final = ytrans;
               4                  z_final = ztrans;
               4              ]
               3              ELSE
               3              [
               4                  x_final = x(np) + u(np)*vstep;
               4                  y_final = y(np) + v(np)*vstep;
               4                  z_final = z(np) + w(np)*vstep;
               4                  IF ( domultiple | dosingle )
               4                  [
               5                      u_tmp = u(np); v_tmp = v(np); w_tmp = w(np);
               5                      call uphi(2,1); "Apply the deflection, save call to uphi if
               5                                      "no deflection in a single scattering mode
               5                      u_final = u(np); v_final = v(np); w_final = w(np);
               5                      u(np) = u_tmp; v(np) = v_tmp; w(np) = w_tmp;
               5                  ]
               4                  ELSE [ u_final = u(np); v_final = v(np); w_final = w(np); ]
               4              ]
               3
               3              $AUSCALL($TRANAUSB);
               3
               3              "Transport the particle
               3
               3              x(np) = x_final; y(np) = y_final; z(np) = z_final;
               3              u(np) = u_final; v(np) = v_final; w(np) = w_final;
               3
               3              dnear(np) = dnear(np) - vstep;
               3              irold = ir(np); "save previous region
               3              $SET-ANGLES-EM-FIELD;
               3              "Default for $SET-ANGLES-EM-FIELD; is ; (null)
               3
               3
               3              "Now done with multiple scattering,
               3              "update energy and see if below cut
               3              "below subtracts only energy deposited"
               3              peie  = peie - edep;
               3              "below subtracts energy deposited + work due to E field"
               3              "peie = peie - de;"
               3              eie   = peie;
               3              e(np) = peie;
               3
               3              "IF( irnew ~= irl & eie <= ecut(irl)) [
               3              "IK: the above is clearly a bug. If the particle energy falls "
               3              "    below ecut, but the particle is actually entering a new "
               3              "    region, the discard will happen in the current region "
               3              "    instead the next. If the particle is a positron, all "
               3              "    resulting annihilation photons will have the new position "
               3              "    but the old region => confusion in the geometry routine "
               3              "    is very likely.      Jan 27 2004 "
               3              IF( irnew = irl & eie <= ecut(irl)) [
               4                 go to :ECUT-DISCARD:;
               4              ]
               3
               3              medold = medium;
               3              IF(medium ~= 0)
               3              [
               4                  ekeold = eke; eke = eie - rm; "update kinetic energy
               4                  elke   = log(eke);
               4                  $SET INTERVAL elke,eke; "Get updated interval
               4              ]
               3
               3              IF(irnew ~= irold) [ $electron_region_change; ]
               3
               3              "After transport call to user scoring routine
               3              $AUSCALL($TRANAUSA);
               3
               3              IF(eie <= ecut(irl)) [
               4                 go to :ECUT-DISCARD:;
               4              ]
               3
               3              "Now check for deferred discard request.  May have been set
               3              "by either howfar, or one of the transport ausgab calls
               3              IF(idisc < 0) [
               4                go to :USER-ELECTRON-DISCARD:;
               4              ]
               3
               3              IF(medium ~= medold) NEXT :TSTEP:;
               3
               3              $USER_CONTROLS_TSTEP_RECURSION;
               3                  "NRCC update 87/12/08--default is null
               3
               3              $UPDATE-DEMFP;
               3
               3          ] UNTIL(demfp < $EPSEMFP); "end ustep loop
               2
               2          "Compute final sigma to see if resample is needed.
               2          "this will take the energy variation of the sigma into
               2          "account using the fictitious sigma method.
               2
               2          $EVALUATE-SIGF;
               2
               2          sigratio = sigf/sig0;
               2
               2          $RANDOMSET rfict;
               2
               2      ] UNTIL (rfict <= sigratio) ; "end tstep loop
               1
               1      " Now sample electron interaction
               1
               1      IF(lelec < 0)
               1      [
               2          "e-,check branching ratio
               2          $EVALUATE-EBREM-FRACTION;
               2            "Default is $EVALUATE ebr1 USING ebr1(elke);"
               2          $RANDOMSET rnno24;
               2          IF(rnno24 <= ebr1)
               2          [
               3              "It was bremsstrahlung
               3              go to :EBREMS:;
               3          ]
               2          ELSE
               2          [
               3              "It was Moller, but first check the kinematics.
               3              "However, if EII is on, we should still permit an interaction
               3              "even if E<moller threshold as EII interactions go down to
               3              "the ionization threshold which may be less than thmoll.
               3              IF(e(np) <= thmoll(medium) & eii_flag = 0)
               3                   "(thmoll = lower Moller threshold)
               3              [
               4                  "Not enough energy for Moller, so
               4                  "force it to be a bremsstrahlung---provided ok kinematically.
               4                  IF(ebr1 <= 0) [go to :NEWELECTRON:;]
               4                      "Brems not allowed either.
               4                  go to :EBREMS:;
               4              ]
               3              $AUSCALL($MOLLAUSB);
               3              call moller;
               3              "The following macro template allows the user to change the
               3              "particle selection scheme (e.g., adding importance sampling
               3              "such as splitting, leading particle selection, etc.).
               3              "(Default macro is template '$PARTICLE-SELECTION-ELECTR'
               3              "which in turn has the 'null' replacement ';')
               3              $PARTICLE-SELECTION-MOLLER;
               3              $AUSCALL($MOLLAUSA);
               3              IF( iq(np) = 0 ) return;
               3          ]
               2
               2          go to :NEWELECTRON:; "Electron is lowest energy-follow it
               2      ]
               1
               1      "e+ interaction. pbr1 = brems/(brems + bhabha + annih
               1      $EVALUATE-PBREM-FRACTION;
               1         "Default is $EVALUATE pbr1 USING pbr1(elke);"
               1      $RANDOMSET rnno25;
               1      IF(rnno25 < pbr1) [go to :EBREMS:;] "It was bremsstrahlung
               1      "Decide between bhabha and annihilation
               1      "pbr2 is (brems + bhabha)/(brems + bhabha + annih)
               1      $EVALUATE-BHABHA-FRACTION;
               1         "Default is $EVALUATE pbr2 USING pbr2(elke);"
               1      IF(rnno25 < pbr2)
               1      [
               2          "It is bhabha
               2          $AUSCALL($BHABAUSB);
               2          call bhabha;
               2          "The following macro template allows the user to change the
               2          "particle selection scheme (e.g., adding importance sampling
               2          "such as splitting, leading particle selection, etc.).  (default
               2          "macro is template '$PARTICLE-SELECTION-ELECTR' which in turn
               2          "has the 'null' replacement ';')
               2          $PARTICLE-SELECTION-BHABHA;
               2          $AUSCALL($BHABAUSA);
               2          IF( iq(np) = 0 ) return;
               2      ]
               1      ELSE
               1      [
               2          "It is in-flight annihilation
               2          $AUSCALL($ANNIHFAUSB);
               2          call annih;
               2          "The following macro template allows the user to change the
               2          "particle selection scheme (e.g., adding importance sampling
               2          "such as splitting, leading particle selection, etc.).  (default
               2          "macro is template '$PARTICLE-SELECTION-ELECTR' which in turn
               2          "has the 'null' replacement ';')
               2          $PARTICLE-SELECTION-ANNIH;
               2          $AUSCALL($ANNIHFAUSA);
               2          EXIT :NEWELECTRON:; "i.e., in order to return to shower
               2          "After annihilation the gammas are bound to be the lowest energy
               2          "particles, so return and follow them.
               2      ] "end pbr2 else
               1
               1  ] REPEAT "newelectron
               0
               0  return; "i.e., return to shower
               0
               0
               0  "---------------------------------------------
               0  "Bremsstrahlung-call section
               0  "---------------------------------------------
               0  :EBREMS:
               0  $AUSCALL($BREMAUSB);
               0  call brems;
               0  "The following macro template allows the user to change the particle
               0  "selection scheme (e.g., adding importance sampling such as splitting,
               0  "leading particle selection, etc.).  (default macro is template
               0  "'$PARTICLE-SELECTION-ELECTR' which in turn has the 'null' replacement ';')
               0  $PARTICLE-SELECTION-BREMS;
               0  $AUSCALL($BREMAUSA);
               0  IF(iq(np) = 0)
               0  [
               1      "Photon was selected.
               1      return;
               1      "i.e., return to shower
               1  ]
               0  ELSE
               0  [
               1      "Electron was selected
               1      go to :NEWELECTRON:;
               1  ]
               0
               0  "---------------------------------------------
               0  "Electron cutoff energy discard section
               0  "---------------------------------------------
               0  :ECUT-DISCARD:
               0  IF( medium > 0 ) [
               1      IF(eie > ae(medium)) [
               2          idr = $EGSCUTAUS;
               2          IF(lelec < 0) [edep = e(np) - prm;] ELSE[$POSITRON-ECUT-DISCARD;]
               2      ]
               1      ELSE [ idr = $PEGSCUTAUS; edep = e(np) - prm; ]
               1  ] ELSE [idr = $EGSCUTAUS; edep = e(np) - prm; ]
               0
               0
               0  $ELECTRON-TRACK-END; "The default replacement for this macros is "
               0                       "          $AUSCALL(idr);                   "
               0                       "Use this macro if you wish to modify the   "
               0                       "treatment of track ends                    "
               0
               0  :POSITRON-ANNIHILATION:; "NRCC extension 86/9/12
               0
               0  IF(lelec > 0) [
               1      "It's a positron. Produce annihilation gammas if edep < peie
               1      IF(edep < peie) [
               2          $AUSCALL($ANNIHRAUSB);
               2          call annih_at_rest;
               2          $PARTICLE-SELECTION-ANNIHREST;
               2          $AUSCALL($ANNIHRAUSA);
               2          "Now discard the positron and take normal return to follow
               2          "the annihilation gammas.
               2          return; "i.e., return to shower
               2      ]
               1  ] "end of positron block
               0
               0  np = np - 1;
               0  ircode = 2; "tell shower an e- or un-annihilated
               0              "e+ has been discarded
               0
               0  return; "i.e., return to shower"
               0
               0  "---------------------------------------------
               0  "User requested electron discard section
               0  "---------------------------------------------
               0  :USER-ELECTRON-DISCARD:
               0
               0  idisc = abs(idisc);
               0
               0  IF((lelec < 0) | (idisc = 99))[edep = e(np) - prm;]
               0  ELSE                          [edep = e(np) + prm;]
               0
               0  $AUSCALL($USERDAUS);
               0
               0  IF(idisc = 99) goto :POSITRON-ANNIHILATION:;
               0
               0  np = np - 1; ircode = 2;
               0
               0  return; "i.e., return to shower
               0  end;    "End of subroutine electr
               0  "*******************************************************************************
               0
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE HATCH;
               0  "                                                                  "
               0  "******************************************************************"
               0  "   Setup which the user is expected to do before calling HATCH is:"
               0  "     1. SET 'NMED' TO THE NUMBER OF MEDIA TO BE USED."
               0  "     2. SET THE ARRAY 'MEDIA', WHICH CONTAINS THE NAMES OF THE"
               0  "        MEDIA THAT ARE DESIRED.  THE CHARACTER FORMAT IS A1, SO"
               0  "        THAT MEDIA(IB,IM) CONTAINS THE IB'TH BYTE OF THE NAME OF"
               0  "        THE IM'TH MEDIUM IN A1 FORMAT."
               0  "     3. SET 'DUNIT', THE DISTANCE UNIT TO BE USED."
               0  "        DUNIT.GT.0 MEANS VALUE OF DUNIT IS LENGTH OF DISTANCE UNIT"
               0  "        CENTIMETERS.  DUNIT.LT.0 MEANS USE THE RADIATION LENGTH OF"
               0  "        THE ABS(DUNIT)'TH MEDIUM FOR THE DISTANCE UNIT."
               0  "     4. FILL THE ARRAY 'MED' WITH THE MEDIUM INDICES FOR THE"
               0  "        REGIONS."
               0  "     5. FILL ARRAYS 'ECUT' AND 'PCUT' WITH THE ELECTRON AND PHOTON"
               0  "        CUT-OFF ENERGIES FOR EACH REGION RESPECTIVELY.  SETUP WILL"
               0  "        RAISE THESE IF NECESSARY TO MAKE THEM AT LEAST AS LARGE AS"
               0  "        THE REGION'S MEDIUM'S AE AND AP RESPECTIVELY."
               0  "     6. FILL 'MED' ARRAY.  MED(IR) IS THE MEDIUM INDEX FOR REGION"
               0  "        IR.  A ZERO MEDIUM INDEX MEANS THE REGION IS IN A VACUUM."
               0  "     7. FILL THE ARRAY 'IRAYLR' WITH 1 FOR EACH REGION IN WHICH"
               0  "        RAYLEIGH (COHERENT) SCATTERING IS TO BE INCLUDED."
               0  "
               0  "   KMPO = 8 and KMPI = 12 are set in BLOCK DATA"
               0  "   The echo to unit 8 has been removed since it is sent"
               0  "                                          to /dev/null anyway!"
               0  "           To put it back search $UOUTPUT  and $ECHO and uncomment"
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  character*512 toUpper;
               0  $COMIN-HATCH;    "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/DEBUG,BOUNDS,BREMPR,EGS-VARIANCE-REDUCTION,"
               0                        "ELECIN,MEDIA,MISC,PHOTIN,STACK,
               0                        "THRESH,UPHIIN,UPHIOT,USEFUL,USER,RANDOM/;
               0
               0  $DECLARE-PEGS4-COMMON-BLOCKS;
               0
               0  $DEFINE-LOCAL-VARIABLES-HATCH;
               0
               0  character*256 tmp_string;
               0  $INTEGER      lnblnk1;" in house lnblnk function becuase not all compilers"
               0                        " support this"
               0
               0  DATA MDLABL/$S' MEDIUM='/,LMDL/8/,LMDN/24/,DUNITO/1./;
               0  DATA I1ST/1/,NSINSS/37/,MXSINC/$MXSINC/,ISTEST/0/,NRNA/1000/;
               0
               0  $INIT-PEGS4-VARIABLES;
               0
               0  "   FORMAT STATEMENTS USED MULTIPLE TIMES IN SETUP"
               0  :INT:FORMAT(1X,14I5);
               0  :FLT:FORMAT(1X,1PE14.5,4E14.5);
               0  :BYTE:FORMAT(72A1);
               0
               0  IF (I1ST.NE.0)[ I1ST=0;"RESET FIRST TIME FLAG"
               1  "   DO FIRST TIME INITIALIZATION"
               1
               1  $HATCH-USER-INPUT-INIT;
               1
               1  "   NOW CONSTRUCT PIECEWISE LINEAR FIT TO SINE FUNCTION OVER THE"
               1  "   INTERVAL (0,5*PI/2).  DIVIDE THIS INTERVAL INTO MXSINC SUB-"
               1  "   INTERVALS.  EACH OF THESE SUBINTERVALS IS THEN SUBDIVIDED INTO"
               1  "   NSINSS SUB-SUB-INTERVALS.  THE ANGLES AT THE BOUNDARIES OF"
               1  "   THESE SUB-SUB-INTERVALS AND THEIR SINES ARE USED TO COMPUTE"
               1  "   LEAST SQUARES COEFFICIENTS FOR THE SUBINTERVAL.  AN EXTRA"
               1  "   SUBINTERVAL ON EACH SIDE OF THE INTERVAL (0,5*PI/2) IS INCLUDED"
               1  "   FOR GOOD MEASURE."
               1  NISUB=MXSINC-2;FNSSS=NSINSS;
               1  WID=PI5D2/FLOAT(NISUB);
               1  WSS=WID/(FNSSS-1.0);
               1  ZEROS(1)=0.;ZEROS(2)=PI; ZEROS(3)=TWOPI;
               1
               1  DO ISUB=1,MXSINC ["LOOP OVER SUBINTERVALS"
               2  SX=0.;SY=0.;SXX=0.;SXY=0.;"ZERO SUMS"
               2
               2  XS0=WID*FLOAT(ISUB-2);XS1=XS0+WID;"LOWER & UPPER LIMITS"
               2  "   NOW CHECK TO SEE IF ANY ZEROS ARE IN THE INTERVAL"
               2  IZ=0; DO IZZ=1,3 [
               3  IF ((XS0.LE.ZEROS(IZZ)).AND.(ZEROS(IZZ).LE.XS1))[IZ=IZZ;EXIT;]
               3  ] "END OF LOOP OVER ZEROS"
               2  IF (IZ.EQ.0)[XSI=XS0;]ELSE[XSI=ZEROS(IZ);]
               2  DO ISS=1,NSINSS ["LOOP OVER SUB-SUBINTERVALS"
               3  XS=WID*FLOAT(ISUB-2)+WSS*FLOAT(ISS-1)-XSI; "ANGLE VALUE"
               3  YS=SIN(XS+XSI); "SINE OF ANGLE"
               3  SX=SX+XS; "ACCUMULATE SUMS"
               3  SY=SY+YS;
               3  SXX=SXX+XS*XS;
               3  SXY=SXY+XS*YS;
               3  ] "END SUB-SUBINTERVAL LOOP"
               2
               2  "   NOW COMPUTE LEAST SQUARES COEFFICIENTS"
               2  IF (IZ.NE.0)["FORCE FIT THROUGH SINES' ZEROS,"
               3  "             FOR SMALL REL.ERR.&GOOD"
               3  "   VALUES OF SINTHE/THETA NEAR ZERO"
               3  SIN1(ISUB)=SXY/SXX;
               3  SIN0(ISUB)=-SIN1(ISUB)*XSI;]
               2  ELSE["DO FULL LEAST SQUARES"
               3  DEL=FNSSS*SXX-SX*SX;
               3  SIN1(ISUB)=(FNSSS*SXY-SY*SX)/DEL;
               3  SIN0(ISUB)=(SY*SXX-SX*SXY)/DEL - SIN1(ISUB)*XSI ; ]
               2  ] "END SUB-INTERVAL LOOP"
               1
               1  SINC0=2.0 ;"SET COEFFICIENTS WHICH DETERMINE INTERVAL"
               1  SINC1=1.0/WID;
               1
               1  "   NOW TEST FIT, IF REQUESTED"
               1  IF (ISTEST.NE.0)[
               2  "   FIRST TEST AT POINTS PREVIOUSLY COMPUTED, EXCLUDING"
               2  "   END SUBINTERVALS"
               2  ADEV=0.;RDEV=0.;S2C2MN=10.;S2C2MX=0.;
               2  DO ISUB=1,NISUB [ DO ISS=1,NSINSS [
               4  THETA=WID*FLOAT(ISUB-1)+WSS*FLOAT(ISS-1);
               4  CTHET=PI5D2-THETA;
               4  $SET INTERVAL THETA,SINC;$SET INTERVAL CTHET,SINC;
               4  $EVALUATE SINTHE USING SIN(THETA);
               4  $EVALUATE COSTHE USING SIN(CTHET);
               4  SINT=SIN(THETA); COST=COS(THETA);
               4  ASD=ABS(SINTHE-SINT); ACD=ABS(COSTHE-COST);
               4  ADEV=max(ADEV,ASD,ACD);
               4  IF (SINT.NE.0.0)RDEV=max(RDEV,ASD/ABS(SINT));
               4  IF (COST.NE.0.0)RDEV=max(RDEV,ACD/ABS(COST));
               4  S2C2=SINTHE**2+COSTHE**2;
               4  S2C2MN=min(S2C2MN,S2C2);
               4  S2C2MX=max(S2C2MX,S2C2);
               4  IF (ISUB.LT.11)[$egs_info('(1PE20.7,4E20.7)',THETA,SINTHE,SINT,COSTHE,COST);]
               4  ] ] "END OF FIXED INTERVAL TEST-OUTPUT RESULTS"
               2  $egs_info('(a,2i5)',' SINE TESTS,MXSINC,NSINSS=',MXSINC,NSINSS);
               2  $egs_info('(a,1PE16.8,3e16.8)',' ADEV,RDEV,S2C2(MN,MX) =',
               2                                   ADEV,RDEV,S2C2MN,S2C2MX);
               2  "   NOW DO RANDOM TEST"
               2  ADEV=0.;RDEV=0.;S2C2MN=10.;S2C2MX=0.;
               2  DO IRN=1,NRNA[ $RANDOMSET THETA;THETA=THETA*PI5D2;
               3  CTHET=PI5D2-THETA;
               3  $SET INTERVAL THETA,SINC;$SET INTERVAL CTHET,SINC;
               3  $EVALUATE SINTHE USING SIN(THETA);
               3  $EVALUATE COSTHE USING SIN(CTHET);
               3  SINT=SIN(THETA); COST=COS(THETA);
               3  ASD=ABS(SINTHE-SINT); ACD=ABS(COSTHE-COST);
               3  ADEV=max(ADEV,ASD,ACD);
               3  IF (SINT.NE.0.0)RDEV=max(RDEV,ASD/ABS(SINT));
               3  IF (COST.NE.0.0)RDEV=max(RDEV,ACD/ABS(COST));
               3  S2C2=SINTHE**2+COSTHE**2;
               3  S2C2MN=min(S2C2MN,S2C2);
               3  S2C2MX=max(S2C2MX,S2C2);
               3  ] "END RANDOM ANGLE LOOP"
               2  $egs_info('(a,i7,a)', ' TEST AT ',NRNA,' RANDOM ANGLES IN (0,5*PI/2)');
               2  $egs_info('(1PE16.8,3E16.8)',' ADEV,RDEV,S2C2(MN,MX) =',
               2                                 ADEV,RDEV,S2C2MN,S2C2MX);
               2  ] "END OF SINE TABLE TEST"
               1
               1  "   NOW FILL IN POWER OF TWO TABLE.  PWR2I(I)=1/2**(I-1)"
               1  P=1.; DO I=1,$MXPWR2I [PWR2I(I)=P; P=P/2.;]
               1
               1  ] "END OF FIRST TIME INITIALIZATION"
               0
               0  "FILL IRAYLM ARRAY BASED ON IRAYLR INPUTS"
               0  $need_rayleigh_data;
               0
               0  "Ali:photonuc, 2 lines"
               0  "FILL IPHOTONUCM ARRAY BASED ON IPHOTONUCR INPUTS"
               0  $need_photonuc_data;
               0  $egs_info('(a,i3)',' ===> Photonuclear flag: ', iphotonuc);
               0
               0  "   NOW SEARCH FILE FOR DATA FOR REQUESTED MATERIALS"
               0  IF(~is_pegsless) REWIND KMPI;
               0  "explicit file name for HP compiler  Nov 23, 1996   DR"
               0  IUECHO=KMPO;
               0  NM=0; "NUMBER OF MEDIA FOUND"
               0  DO IM=1,NMED [LOK(IM)=0;"SET FLAG TELLING WHICH MEDIA ARE OK"
               1    "NOW TELL USER IF RAYLEIGH OPTION HAS BEEN REQUESTED"
               1    IF(IRAYLM(IM).EQ.1) [
               2       $egs_info('(a,i3/)', ' RAYLEIGH OPTION REQUESTED FOR MEDIUM NUMBER',IM);
               2    ]
               1  ]
               0
               0  "Ali:photonuc, 1 block"
               0  DO IM=1,NMED [
               1    "TELL USER IF PHOTONUC HAS BEEN REQUESTED"
               1    IF(IPHOTONUCM(IM).EQ.1) [
               2       $egs_info('(a,i3/)', ' PHOTONUCLEAR REQUESTED FOR MEDIUM NUMBER',IM);
               2    ]
               1  ]
               0
               0  IF(~is_pegsless)[
               1  :MEDIUM:
               1  LOOP["MEDIUM SEARCH LOOP"
               2
               2  :MDLOOK:
               2  LOOP["MEDIUM HEADER SEARCH LOOP"
               3    "   FIRST LOOK FOR MEDIUM HEADER"
               3    READ(KMPI,:BYTE:,END=:MDNOMORE:)MBUF;
               3    DO IB=1,LMDL [IF (MBUF(IB).NE.MDLABL(IB))NEXT:MDLOOK:;]
               3    "   HEADER MATCHES. NOW SEE IF IT IS ONE OF REQUESTED MEDIA"
               3    :MDNAME:
               3    DO IM=1,NMED [
               4      DO IB=1,LMDN [IL=LMDL+IB; IF (MBUF(IL).NE.MEDIA(IB,IM))NEXT:MDNAME:;
               5      IF (IB.EQ.LMDN)EXIT:MDLOOK:; ]
               4    ] "END :MDNAME: DO"
               3    "   NOT IN NAME TABLE, SO IGNORE IT"
               3  ]REPEAT "MDLOOK"
               2
               2  "   'IM' IS THE INDEX OF THE MEDIUM READY TO BE READ"
               2  IF (LOK(IM).NE.0)GO TO :MDLOOK:;"WE ALREADY HAVE THIS ONE"
               2  LOK(IM)=1;NM=NM+1;"SET FOUND FLAG AND STEP MEDIUM COUNTER"
               2
               2  "   NOW READY TO READ IN DATA FOR THIS MEDIUM"
               2  "$UOUTPUT(KMPO)IM,MBUF;(' DATA FOR MEDIUM #',I3,', WHICH IS:',72A1);"
               2
               2  "   NOW PUT OUT LINES SHOWING COMPOSITION OF MEDIUM"
               2  "THE FOLLOWING LINE WAS CHANGED TO STORE THE ELEMENTAL COMPOSITION AFB 88/05/31"
               2  "$UINPUT(KMPI)(MBUF(I),I=1,5),RHO(IM),NE;"
               2  "The next two lines were line prior to Dec 89 mods to get IUNRST"
               2  "$UINPUT(KMPI)(MBUF(I),I=1,5),RHO(IM),NNE(IM);"
               2  "(5A1,5X,F11.0,4X,I2);"
               2  "following used to pick up IUNRST, IAPRIM and EPSTFL"
               2  "Problem is that GASP may or may not be printed, so we make"
               2  "a kludge which will work with all old data files"
               2  "FIRST WE ASSUME THERE IS NO GASP VALUE IN THE LINE"
               2  "Note that this reading scheme counts on there being an"
               2  "error when GASP does exist on the line--an error does"
               2  "occur on most compilers, however, we have found that on"
               2  "the rs6000 an error does not occur.  Instead, a warning"
               2  "is printed out and IUNRST,EPSTFL and IAPRIM are set to 0."
               2  "This will make no difference in simulations but will cause"
               2  "a problem when running EXAMIN"
               2
               2  " IK: backspace(kmpi) fails under windows using g77 with I/O error"
               2  "     therefore we read the line in a temporary string and then "
               2  "     use memoty I/O to try to read with and without gasp there. "
               2
               2  read(kmpi,'(a)',err=:hatch_read_error1:) tmp_string;
               2  goto :no_hatch_read_error1:;
               2  :hatch_read_error1:
               2  $egs_fatal(*,'Error while reading pegs4 file');
               2
               2  :no_hatch_read_error1:;
               2  read(tmp_string,1,ERR=:GASP-THERE:)
               2  "READ(KMPI,1,ERR=:GASP-THERE:)"
               2  (MBUF(I),I=1,5),RHO(IM),NNE(IM),IUNRST(IM),EPSTFL(IM),IAPRIM(IM);
               2  1   FORMAT(5A1,5X,F11.0,4X,I2,9X,I1,9X,I1,9X,I1);
               2  "IUNRST, EPSTFL AND IAPRIM ARE STORED IN COMIN ELECIN"
               2  GO TO :GASP-NOT-THERE:;
               2
               2  :GASP-THERE:;
               2  "WE MUST REREAD THE LINE WITH THE CORRECT FORMAT"
               2  "BACKSPACE(KMPI);""THIS BACKS UP ONE RECORD TO RE-READ IT"
               2  "READ(KMPI,2)"
               2
               2  "The following output is only there because without it"
               2  "code compiled with the new gfortran GNU compiler "
               2  "fails with run time error. Another bug in their "
               2  "pre-alpha quality I/O system ----IK, Oct 26 2005 "
               2  "write(6,*) 'Found medium with gas pressure';"
               2  $egs_info(*,'Found medium with gas pressure');
               2  read(tmp_string,2)
               2  (MBUF(I),I=1,5),RHO(IM),NNE(IM),IUNRST(IM),EPSTFL(IM),
               2  IAPRIM(IM);
               2  2     FORMAT(5A1,5X,F11.0,4X,I2,26X,I1,9X,I1,9X,I1);
               2
               2  :GASP-NOT-THERE:
               2
               2  "THE FOLLOWING LINE WAS CHANGED AS WELL AFB 88/05/31"
               2  "$UOUTPUT(KMPO)(MBUF(I),I=1,5),RHO(IM),NE;"
               2  ";$UOUTPUT(KMPO)(MBUF(I),I=1,5),RHO(IM),NNE(IM);"
               2  "(5A1,',RHO=',1PG11.4,',NE=',I2,',COMPOSITION IS :');"
               2  "THE FOLLOWING LINE WAS CHANGED AS WELL AFB 88/05/31"
               2  "DO IE=1,NE["
               2  DO IE=1,NNE(IM)[
               3      "THE FOLLOWING LINE, COMMENTED OUT, WAS THE OLD WAY OF READING IN "
               3      "THE ELEMENTAL COMPOSITION OF EACH MEDIUM. THE INFORMATION WAS NOT"
               3      "PASSED ON TO EGS. IN THE PRESENT VERSION IT IS READ IN AND STORED"
               3      "IN COMMON BREMPR. AFB 88/05/31.                                  "
               3      "READ(KMPI,:BYTE:)MBUF;WRITE(KMPO,:BYTE:)MBUF;"
               3      $UINPUT(KMPI)
               3      (MBUF(I),I=1,6),(ASYM(IM,IE,I),I=1,2),
               3      ZELEM(IM,IE),WA(IM,IE),PZ(IM,IE),RHOZ(IM,IE);
               3      (6A1,2A1,3X,F3.0,3X,F9.0,4X,F12.0,6X,F12.0);
               3      "$UOUTPUT(KMPO)"
               3      "(MBUF(I),I=1,6),(ASYM(IM,IE,I),I=1,2),"
               3      "ZELEM(IM,IE),WA(IM,IE),PZ(IM,IE),RHOZ(IM,IE);"
               3      "(6A1,2A1,',Z=',F3.0,',A=',F9.3,',PZ=',1PE12.5,',RHOZ=',1PE12.5);"
               3      ]
               2
               2  "   MEDIA AND THRESH"
               2  "$ECHO" READ(KMPI,:FLT:) $LGN(RLC,AE,AP,UE,UP(IM));
               2  TE(IM)=AE(IM)-RM; THMOLL(IM)=TE(IM)*2. + RM ;
               2
               2  "   ACTUAL ARRAY SIZES FROM PEGS"
               2  "$ECHO" READ(KMPI,:INT:)
               2  $LGN(MSGE,MGE,MSEKE,MEKE,MLEKE,MCMFP,MRANGE(IM)),IRAYL;
               2  NSGE=MSGE(IM);NGE=MGE(IM);NSEKE=MSEKE(IM);NEKE=MEKE(IM);
               2  NLEKE=MLEKE(IM);NCMFP=MCMFP(IM);NRANGE=MRANGE(IM);
               2
               2  "   BREMPR"
               2  "$ECHO" READ(KMPI,:FLT:)($LGN(DL(I,IM)/1,2,3,4,5,6/),I=1,6);
               2  "$ECHO" READ(KMPI,:FLT:)DELCM(IM),($LGN(ALPHI,BPAR,
               2     DELPOS(I,IM)),I=1,2);
               2
               2  "   ELECIN"
               2  "$ECHO" READ(KMPI,:FLT:)$LGN(XR0,TEFF0,BLCC,XCC(IM));
               2  "$ECHO" READ(KMPI,:FLT:)$LGN(EKE(IM)/0,1/);
               2  "$ECHO" READ(KMPI,:FLT:)
               2  ($LGN(ESIG,PSIG,EDEDX,PDEDX,EBR1,PBR1,PBR2,
               2     TMXS(I,IM)/0,1/),I=1,NEKE);
               2
               2  "   PHOTIN"
               2  "$ECHO" READ(KMPI,:FLT:)EBINDA(IM),$LGN(GE(IM)/0,1/);
               2  "$ECHO" READ(KMPI,:FLT:)($LGN(GMFP,GBR1,GBR2(I,IM)/0,1/),I=1,NGE);
               2
               2  "   PHOTIN (CONTINUED)---OPTIONAL RAYLEIGH SCATTERING INPUT"
               2
               2
               2  IF (IRAYL.EQ.1) [
               3  "$ECHO" READ(KMPI,:INT:) NGR(IM);
               3  NGRIM=NGR(IM);
               3  "$ECHO" READ(KMPI,:FLT:)$LGN(RCO(IM)/0,1/);
               3  "$ECHO" READ(KMPI,:FLT:)($LGN(RSCT(I,IM)/0,1/),I=1,NGRIM);
               3  "$ECHO" READ(KMPI,:FLT:)($LGN(COHE(I,IM)/0,1/),I=1,NGE);
               3   "IF(IRAYLM(IM).NE.1) ["
               3   $egs_info('(a,i3,a)', ' Rayleigh data available for medium',
               3            IM, ' in PEGS4 data set.');
               3   "]"
               3  ]
               2
               2
               2
               2
               2
               2  IF(IRAYLM(IM).EQ.1) ["Rayleigh data requested for medium IM"
               3    IF(IRAYL.NE.1) ["No data in PEGS4"
               4      IF(toUpper($cstring(photon_xsections))='PEGS4')
               4      ["Rayleigh not possible"
               5       $egs_fatal('(a,i3 /,a /,a)',
               5       ' IN HATCH: REQUESTED RAYLEIGH OPTION FOR MEDIUM',
               5       IM,' BUT RAYLEIGH DATA NOT INCLUDED IN PEGS4 FILE.',
               5       ' YOU WILL NOT BE ABLE TO USE THE PEGS4 DATA WITH RAYLEIGH ON!');
               5      ]
               4      ELSE["Data will be taken from elsewhere (si,epdl,xcom,custom)"
               5       $egs_warning('(a,i3 /,a)',
               5       ' IN HATCH: REQUESTED RAYLEIGH OPTION FOR MEDIUM',
               5       IM,' BUT RAYLEIGH DATA NOT INCLUDED IN PEGS4 FILE.');
               5      ]
               4    ]
               3   ELSE["Rayleigh data in PEGS4"
               4      IF(toUpper($cstring(photon_xsections))='PEGS4')
               4      ["PEGS4 data selected"
               5        "***********************************************************"
               5        "Preparing data for new Rayleigh angular sampling when using"
               5        "the pegs4 data set,                                        "
               5        "***********************************************************"
               5         call egs_init_rayleigh_sampling(IM);
               5      ]
               4      "ELSE[Taking photon data from either si,epdl,xcom or user]"
               4    ]
               3  ]
               2
               2
               2  "   THAT'S ALL FOR THIS MEDIUM"
               2  ]UNTIL NM.GE.NMED; "LOOP UNTIL WE HAVE ENOUGH.  END :MEDIUM: LOOP"
               1
               1  CLOSE (UNIT=KMPI);
               1
               1  "   WE NOW HAVE DATA FOR ALL MEDIA REQUESTED.  NOW DO DISTANCE UNIT"
               1  "   CHANGE.  DATA FROM PEGS IS IN UNITS OF RADIATION LENGTHS."
               1  "   EGS IS RUN IN UNITS OF 'DUNIT' CENTIMETERS, IF DUNIT.GT.0 "
               1  "   OR IN UNITS OF RLC(-DUNIT) CENTIMETERS IF DUNIT.LT.0."
               1  "   THAT IS, A NEGATIVE DUNIT MEANS UNIT IS TO BE THE RADIATION"
               1  "   LENGTH OF THE MEDIUM WHOSE INDEX IS -DUNIT"
               1  DUNITR=DUNIT; "SAVE REQUESTED"
               1  IF(DUNIT.LT.0.0)[ID=MAX0(1,MIN0($MXMED,int(-DUNIT)));
               2     DUNIT=RLC(ID);]
               1  IF(DUNIT.NE.1.0) [
               2  $egs_info('(a,1PE14.5,E14.5,a)',' DUNIT REQUESTED&USED ARE: ',
               2           DUNITR,DUNIT,'(CM.)' );
               2  ]
               1  DO IM=1,NMED [
               2  DFACT=RLC(IM)/DUNIT; "CONVERTS RL TO DUNITS"
               2  DFACTI=1.0/DFACT;    "CONVERT RL**-1 TO DUNITS**-1"
               2
               2  FOR I=1 TO MEKE(IM) [
               3  $SCALE $LGN(ESIG,PSIG,EDEDX,PDEDX(I,IM)/0,1/) BY DFACTI;
               3  $SCALE $LGN(TMXS(I,IM)/0,1/) BY DFACT;]
               2  $SCALE TEFF0(IM) BY DFACT;
               2  $SCALE BLCC(IM) BY DFACTI;
               2  $SCALE XCC(IM) BY SQRT(DFACTI);
               2  RLDU(IM)=RLC(IM)/DUNIT;
               2  FOR I=1 TO MGE(IM) [$SCALE $LGN(GMFP(I,IM)/0,1/) BY DFACT; ]
               2  ] "END IM DO"
               1
               1  "   SCALE VACDST.  UNDO PREVIOUS SCALE, THEN DO NEW."
               1  VACDST=VACDST*DUNITO/DUNIT;
               1  DUNITO=DUNIT; "SAVE OLD DUNIT"
               1
               1  ]"end regular pegs4 intake"
               0  ELSE["pegsless intake of medium data"
               1
               1  $egs_info(*,' PEGSLESS INPUT.  CALCULATING ELECTRON CROSS-SECTIONS.');
               1
               1  $GET-PEGSLESS-XSECTIONS;
               1
               1  ]
               0
               0  "   NOW MAKE SURE ECUT AND PCUT ARE NOT LOWER THAN ANY AE OR AP"
               0  "   ALSO SET DEFAULT DENSITIES"
               0  $adjust_rhor_ecut_pcut;
               0
               0  "BREMSSTRAHLUNG ANGULAR DISTRIBUTION INITIALIZATION - DEFAULT IS NULL"
               0  "NEXT LINE ADDED AFB 88/05/31"
               0  $INITIALIZE-BREMS-ANGLE;
               0
               0  "PAIR ANGULAR DISTRIBUTION INITIALIZATION - DEFAULT IS NULL"
               0  "NEXT LINE ADDED AFB 91/05/29"
               0  $INITIALIZE-PAIR-ANGLE;
               0
               0  " See if user has requested PEGS4 photon cross section data "
               0  IF(toUpper($cstring(photon_xsections)) = 'PEGS4')[
               1    $egs_warning('(6(a/))','Using photon data from PEGS4 file!!!',
               1    'However, the new Rayleigh angular sampling will be used.',
               1    'The original EGS4 angular sampling undersamples large scattering ',
               1    'angles. This may have little impact as Rayleigh scattering ',
               1    'is forward peaked.',
               1    '*********************************************************');
               1
               1  ]
               0  ELSE["re-calculates photon xsections using available or user data"
               1  "Ali:photonuc, 2 lines"
               1      call egs_init_user_photon(photon_xsections,comp_xsections,
               1      photonuc_xsections,xsec_out);
               1  "    call egs_init_user_photon(photon_xsections,comp_xsections,xsec_out);"
               1  ]
               0
               0  call mscati;       "Initialize new MS, step-sizes, etc, IK Oct 97"
               0
               0  "Calling order of the subroutines below is important when using"
               0  "detailed atomic relaxation in order to use the binding energies"
               0  "corresponding to the requested photon cross section library"
               0  IF ( eadl_relax & photon_xsections = 'xcom' )[
               1     call init_compton; "Initialize bound Compton scattering"
               1     call EDGSET(1,1);  "Initialize relaxations and photo-absorption data"
               1  ]
               0  ELSE[
               1     call EDGSET(1,1);  "Initialize relaxations and photo-absorption data,"
               1                        "if requested
               1     call init_compton; "Initialize bound compton scattering, IK, Jan 99"
               1                        "if requested
               1  ]
               0
               0  IF( xsec_out = 1 & eadl_relax) [
               1    call egs_print_binding_energies;
               1  ]
               0
               0  call fix_brems;    "Re-calculate dl1,... for the different technique"
               0                     "employed in BREMS. Note that the old EGS sampling"
               0                     "technique for BREMS had a bug that shows up only"
               0                     "if AP is not much smaller than electron kinetic energy"
               0
               0  IF( ibr_nist >= 1 ) [ call init_nist_brems; ]
               0                     "initializes the sampling tables and modifies the total"
               0                     "brems cross sections if the NIST brems data base is to"
               0                     "be used                                               "
               0
               0  IF( pair_nrc = 1 ) [ call init_nrc_pair; ]
               0
               0  " Load and initialize EII data if needed. "
               0  call eii_init;
               0
               0  " Load and initialize the triplet data if needed "
               0  call init_triplet;
               0
               0  "   SETUP IS NOW COMPLETE"
               0  IF (NMED.EQ.1)[
               1     $egs_info(*,'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ONE MEDIUM.');
               1  ]
               0  ELSE[
               1     $egs_info('(a,i5,a)',
               1               'EGSnrc SUCCESSFULLY ''HATCHED'' FOR ',NMED,' MEDIA.');
               1  ]
               0
               0  RETURN;
               0
               0  :MDNOMORE:
               0  $egs_info('(a,i2//,a/,a/)', ' END OF FILE ON UNIT ',KMPI,
               0    ' PROGRAM STOPPED IN HATCH BECAUSE THE',
               0    ' FOLLOWING NAMES WERE NOT RECOGNIZED:');
               0  DO IM=1,NMED [
               1     IF(LOK(IM).NE.1) [
               2        $egs_info('(40x,a,24a1,a)','''',(MEDIA(I,IM),I=1,LMDN),'''');
               2     ]
               1  ]
               0  STOP;
               0  "END OF SUBROUTINE HATCH"   END;
               0
               0  subroutine fix_brems;
               0  "******************************************************************"
               0  "
               0  " Calculates the parameter for the rejection function used in
               0  " the current implementation of bremsstrahlung sampling
               0  "
               0  " I Kawrakow, January 2000
               0  "
               0  "*******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0  $declare_max_medium;
               0  ;COMIN/BREMPR,MEDIA,NIST-BREMS,THRESH/;
               0
               0  $INTEGER medium,i;
               0  $REAL    Zt,Zb,Zf,Zg,Zv,fmax1,fmax2,Zi,pi,fc,xi,aux,
               0           XSIF,FCOULC;
               0
               0  DO medium = 1,nmed [
               1
               1      log_ap(medium) = log(ap(medium));
               1      Zt = 0; Zb = 0; Zf = 0;
               1      DO i=1, NNE(medium) [
               2          Zi = ZELEM(medium,i); pi = PZ(medium,i);
               2          fc = FCOULC(Zi); xi = XSIF(Zi);
               2          aux = pi*Zi*(Zi + xi);
               2          Zt = Zt + aux;
               2          Zb = Zb - aux*Log(Zi)/3;
               2          Zf = Zf + aux*fc;
               2      ]
               1      Zv = (Zb - Zf)/Zt; Zg = Zb/Zt;
               1      fmax1 = 2*(20.863 + 4*Zg) - 2*(20.029 + 4*Zg)/3;
               1      fmax2 = 2*(20.863 + 4*Zv) - 2*(20.029 + 4*Zv)/3;
               1
               1      "These are used in BREMS"
               1      dl1(1,medium) = (20.863 + 4*Zg)/fmax1;
               1      dl2(1,medium) = -3.242/fmax1;
               1      dl3(1,medium) = 0.625/fmax1;
               1      dl4(1,medium) = (21.12+4*Zg)/fmax1;
               1      dl5(1,medium) = -4.184/fmax1;
               1      dl6(1,medium) = 0.952;
               1      dl1(2,medium) = (20.029+4*Zg)/fmax1;
               1      dl2(2,medium) = -1.93/fmax1;
               1      dl3(2,medium) = -0.086/fmax1;
               1      dl4(2,medium) = (21.12+4*Zg)/fmax1;
               1      dl5(2,medium) = -4.184/fmax1;
               1      dl6(2,medium) = 0.952;
               1      dl1(3,medium) = (20.863 + 4*Zv)/fmax2;
               1      dl2(3,medium) = -3.242/fmax2;
               1      dl3(3,medium) = 0.625/fmax2;
               1      dl4(3,medium) = (21.12+4*Zv)/fmax2;
               1      dl5(3,medium) = -4.184/fmax2;
               1      dl6(3,medium) = 0.952;
               1      dl1(4,medium) = (20.029+4*Zv)/fmax2;
               1      dl2(4,medium) = -1.93/fmax2;
               1      dl3(4,medium) = -0.086/fmax2;
               1      dl4(4,medium) = (21.12+4*Zv)/fmax2;
               1      dl5(4,medium) = -4.184/fmax2;
               1      dl6(4,medium) = 0.952;
               1
               1      "and these in PAIR"
               1      dl1(5,medium) = (3*(20.863 + 4*Zg) - (20.029 + 4*Zg));
               1      dl2(5,medium) = (3*(-3.242) - (-1.930));
               1      dl3(5,medium) = (3*(0.625)-(-0.086));
               1      dl4(5,medium) = (2*21.12+8*Zg);
               1      dl5(5,medium) = (2*(-4.184));
               1      dl6(5,medium) = 0.952;
               1      dl1(6,medium) = (3*(20.863 + 4*Zg) + (20.029 + 4*Zg));
               1      dl2(6,medium) = (3*(-3.242) + (-1.930));
               1      dl3(6,medium) = (3*0.625+(-0.086));
               1      dl4(6,medium) = (4*21.12+16*Zg);
               1      dl5(6,medium) = (4*(-4.184));
               1      dl6(6,medium) = 0.952;
               1      dl1(7,medium) = (3*(20.863 + 4*Zv) - (20.029 + 4*Zv));
               1      dl2(7,medium) = (3*(-3.242) - (-1.930));
               1      dl3(7,medium) = (3*(0.625)-(-0.086));
               1      dl4(7,medium) = (2*21.12+8*Zv);
               1      dl5(7,medium) = (2*(-4.184));
               1      dl6(7,medium) = 0.952;
               1      dl1(8,medium) = (3*(20.863 + 4*Zv) + (20.029 + 4*Zv));
               1      dl2(8,medium) = (3*(-3.242) + (-1.930));
               1      dl3(8,medium) = (3*0.625+(-0.086));
               1      dl4(8,medium) = (4*21.12+16*Zv);
               1      dl5(8,medium) = (4*(-4.184));
               1      dl6(8,medium) = 0.952;
               1
               1      bpar(2,medium) = dl1(7,medium)/(3*dl1(8,medium) + dl1(7,medium));
               1      bpar(1,medium) = 12*dl1(8,medium)/(3*dl1(8,medium) + dl1(7,medium));
               1
               1  ]
               0  return;
               0  end;
               0
               0
               0  $REAL function FCOULC(Z);
               0  "************************"
               0  $IMPLICIT-NONE;
               0  $REAL Z;
               0  $REAL fine,asq;
               0  data fine/137.03604/;
               0  asq = Z/fine; asq = asq*asq;
               0  FCOULC = asq*(1.0/(1.0+ASQ)+0.20206+ASQ*(-0.0369+ASQ*(0.0083+ASQ*(-0.002))));
               0  return;
               0  end;
               0
               0  $REAL function XSIF(Z);
               0  "**********************"
               0  $IMPLICIT-NONE;
               0  $REAL    Z;
               0  $INTEGER iZ;
               0  $REAL    alrad(4),alradp(4),a1440,a183,FCOULC;
               0  data     alrad/5.31,4.79,4.74,4.71/;
               0  data     alradp/6.144,5.621,5.805,5.924/;
               0  data     a1440/1194.0/,A183/184.15/;
               0  IF( Z <= 4 ) [ iZ = Z; xsif = alradp(iZ)/(alrad(iZ) - FCOULC(Z)); ]
               0  ELSE [ xsif = Log(A1440*Z**(-0.666667))/(Log(A183*Z**(-0.33333))-FCOULC(Z)); ]
               0  return;
               0  end;
               0
               0  "******************************************************************"
               0  subroutine init_compton;
               0  "
               0  "  Reads in bound Compton scattering data from unit $INCOHUNIT
               0  "  and performs necessary initializations
               0  "
               0  "  See definitions of variables in egsnrc.macros with definition
               0  "  of COMIN/COMPTON-DATA/
               0  "
               0  "  I.Kawrakow, January 99
               0  "******************************************************************"
               0
               0  implicit none;
               0
               0  $COMIN-INIT-COMPT;
               0
               0  $INTEGER i,j,iz,nsh,j_l,j_h;
               0  $REAL    aux,pztot,atav;
               0  $REAL    aux_erf,erf1;  "using erf1, provided with EGSnrc, because some"
               0                          "compiler don't have an intrinsic error function"
               0  $LOGICAL getd;
               0
               0  " Initialize radiative Compton corrections, if needed "
               0  $RADC_HATCH;
               0
               0  $need_bound_compton_data(getd);
               0  IF( ~getd ) [
               1      IF( eadl_relax & photon_xsections = 'xcom' )[
               2          $egs_fatal('(a,/a,/a)',
               2                     'You must turn ON Compton binding corrections when using',
               2                     'a detailed atomic relaxation (eadl_relax=true) since ',
               2                     'binding energies taken from incoh.data below 1 keV!');
               2      ]
               1      $egs_info('(a/)',' Bound Compton scattering not requested! ');
               1      return;
               1  ]
               0
               0  $egs_info('(/a$)','Bound Compton scattering requested, reading data ......');
               0  rewind($INCOHUNIT);
               0  DO j=1,18 [ read($INCOHUNIT,*); ]  "skip 1st 18 lines of comments"
               0  iz = 0;
               0  DO j=1,$MXTOTSH [
               1      read($INCOHUNIT,*) iz_array(j),shn_array(j),ne_array(j),
               1                         Jo_array(j),be_array(j);
               1      Jo_array(j) = Jo_array(j)*137.;
               1      be_array(j) = be_array(j)*1e-6/PRM;
               1      aux_erf = 0.70710678119*(1+0.3*Jo_array(j));
               1      erfJo_array(j) = 0.82436063535*(erf1(aux_erf)-1);
               1                      "0.82436063535 is exp(0.5)/2"
               1
               1      "For detailed atomic relaxations set shell type
               1      "to actual shell number and update binding energies
               1      "with values from the photo-electric cross sections
               1      IF (eadl_relax)[
               2         IF (iz_array(j) ~= iz)[
               3            shn_array(j) = 1; iz = iz_array(j);
               3         ]
               2         ELSE[
               3            shn_array(j) = shn_array(j-1)+1;
               3         ]
               2         IF(binding_energies(shn_array(j),iz_array(j)) > 0)[
               3           be_array(j) = binding_energies(shn_array(j),iz_array(j))/PRM;
               3         ]
               2         ELSE IF(photon_xsections = 'xcom') [
               3           "Use binding energies from incoh.data below 1 keV"
               3           binding_energies(shn_array(j),iz_array(j)) = be_array(j)*PRM;
               3         ]
               2      ]
               1
               1  ]
               0  $egs_info(*,' Done');
               0  $egs_info('(/a)',' Initializing Bound Compton scattering ......');
               0  DO medium = 1,nmed [
               1      pztot = 0; nsh = 0;
               1      DO i = 1, nne(medium) [
               2          iz = int(zelem(medium,i));
               2          DO j = 1, $MXTOTSH [
               3              IF( iz = iz_array(j) ) [
               4                  nsh = nsh + 1;
               4                  IF( nsh > $MXMDSH ) [
               5                      $egs_fatal('(/a,i3,a,i4,a/,a)',' For medium ',medium,
               5                                ' the number of shells is > ',$MXMDSH,'!',
               5                                ' Increase the parameter $MXMDSH! ');
               5                  ]
               4                  shell_array(nsh,medium) = j;
               4                  aux = pz(medium,i)*ne_array(j);
               4                  eno_array(nsh,medium) = aux;
               4                  pztot = pztot + aux;
               4              ]
               3          ]
               2      ]
               1      IF( nsh = 0 ) [
               2          $egs_fatal('(a,i3,a)', ' Medium ',medium,' has zero shells! ');
               2      ]
               1      n_shell(medium) = nsh;
               1      $egs_info('(a,i3,a,i3,a)', ' Medium ',medium,' has ',nsh,' shells: ');
               1      DO i=1,nsh [
               2          j = shell_array(i,medium);
               2          eno_array(i,medium) = eno_array(i,medium)/pztot;
               2          $egs_info('(i4,i5,i4,f9.5,e10.3,f10.3)',
               2                    i,j,shn_array(j),eno_array(i,medium),
               2                    Jo_array(j),be_array(j)*PRM*1000.);
               2          eno_array(i,medium) = -eno_array(i,medium);
               2          eno_atbin_array(i,medium) = i;
               2      ]
               1      atav = 1./nsh;
               1      DO i=1,nsh-1 [
               2          DO j_h = 1,nsh-1 [
               3              IF( eno_array(j_h,medium) < 0 ) [
               4                  IF( abs(eno_array(j_h,medium)) > atav ) EXIT;
               4              ]
               3          ]
               2          DO j_l = 1,nsh-1 [
               3              IF( eno_array(j_l,medium) < 0 ) [
               4                  IF( abs(eno_array(j_l,medium)) < atav ) EXIT;
               4              ]
               3          ]
               2          aux = atav - abs(eno_array(j_l,medium));
               2          eno_array(j_h,medium) = eno_array(j_h,medium) + aux;
               2          eno_array(j_l,medium) = -eno_array(j_l,medium)/atav + j_l;
               2          eno_atbin_array(j_l,medium) = j_h;
               2          IF( i = nsh-1 ) eno_array(j_h,medium) = 1 + j_h;
               2      ]
               1      DO i=1,nsh [
               2          IF( eno_array(i,medium) < 0 ) [ eno_array(i,medium) = 1 + i; ]
               2      ]
               1  ]
               0
               0  $egs_info('(a/)',' ...... Done.');
               0
               0  $need_relaxation_data(getd);
               0  IF( getd ) return;
               0  $egs_fatal('(/a,/a,/a,/a)',
               0  ' In subroutine init_compton: ',
               0  '   Scattering off bound electrons creates atomic vacancies,',
               0  '   potentially starting an atomic relaxation cascade. ',
               0  '   Please turn ON atomic relaxations.');
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  return;
               0  end;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE MOLLER;
               0  "                                                                  "
               0  "******************************************************************"
               0  "   DISCRETE MOLLER SCATTERING (A CALL TO THIS ROUTINE) HAS BEEN   "
               0  "   ARBITRARILY DEFINED AND CALCULATED TO MEAN MOLLER SCATTERINGS  "
               0  "   WHICH IMPART TO THE SECONDARY ELECTRON SUFFICIENT ENERGY THAT  "
               0  "   IT BE TRANSPORTED DISCRETELY.  THE THRESHOLD TO TRANSPORT AN   "
               0  "   ELECTRON DISCRETELY IS A TOTAL ENERGY OF AE OR A KINETIC ENERGY"
               0  "   OF TE=AE-RM.  SINCE THE KINETIC ENERGY TRANSFER IS ALWAYS, BY  "
               0  "   DEFINITION, LESS THAN HALF OF THE INCIDENT KINETIC ENERGY, THIS"
               0  "   IMPLIES THAT THE INCIDENT ENERGY, EIE, MUST BE LARGER THAN     "
               0  "   THMOLL=TE*2+RM.  THE REST OF THE COLLISION CONTRIBUTION IS     "
               0  "   SUBTRACTED CONTINUOUSLY FROM THE ELECTRON AS IONIZATION        "
               0  "   LOSS DURING TRANSPORT.                                         "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-MOLLER;   "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "  COMIN/EGS-VARIANCE-REDUCTION, DEBUG,STACK,THRESH,"
               0                                            "UPHIOT,USEFUL,RANDOM/;"
               0  ;COMIN/EII-DATA,ELECIN,EPCONT,EDGE,BREMPR/;
               0
               0  $DEFINE-LOCAL-VARIABLES-MOLLER;
               0
               0  $REAL sigm,pbrem,rsh,Uj,sig_j;
               0  $INTEGER lelke,iele,ish,nsh,ifirst,i,jj,iZ,iarg;
               0
               0  "IRCODE=1;  appears to be unused, IK Oct 97"
               0  NPold = NP;      "Set the old stack counter"
               0  PEIE=E(NP);"PRECISE ENERGY OF INCIDENT ELECTRON"
               0  EIE=PEIE; "ENERGY OF INCIDENT ELECTRON"
               0  PEKIN=PEIE-PRM;  "PRECISE K.E. OF INCIDENT ELECTRON"
               0  EKIN=PEKIN;
               0
               0  IF( eii_flag > 0 & eii_nsh(medium) > 0 ) [
               1      "The EII flag is set and this medium has shells for which we want to"
               1      "simulate EII => sample if the interaction is with a EII shell"
               1      $SET INTERVAL elke,eke;
               1      $EVALUATE sigm USING esig(elke);
               1      $EVALUATE pbrem USING ebr1(elke);
               1      sigm = sigm*(1 - pbrem);
               1      $RANDOMSET rsh; rsh = sigm*rsh;
               1      DO iele=1,nne(medium) [
               2          iZ = int(zelem(medium,iele)+0.5);
               2          nsh = eii_no(medium,iele);
               2          IF( nsh > 0 ) [
               3              ifirst = eii_first(medium,iele);
               3              DO ish = 1,nsh [
               4                  Uj = binding_energies(ish,iZ);
               4                  IF( ekin > Uj & (Uj > te(medium) | Uj > ap(medium)) ) [
               5                      jj = ifirst + ish - 1;
               5                      i = eii_a(jj)*elke + eii_b(jj) + (jj-1)*$N_EII_BINS;
               5                      sig_j = eii_xsection_a(i)*elke + eii_xsection_b(i);
               5                      sig_j = sig_j*pz(medium,iele)*eii_cons(medium);
               5                      rsh = rsh - sig_j;
               5                      IF( rsh < 0 ) [
               6                          $AUSCALL($EIIB);
               6                          call eii_sample(ish,iZ,Uj);
               6                          $AUSCALL($EIIA);
               6                          return;
               6                      ]
               5                  ]
               4              ]
               3          ]
               2      ]
               1  ]
               0  IF( ekin <= 2*te(medium) ) return;
               0  T0=EKIN/RM;
               0  E0=T0+1.0;
               0  EXTRAE = EIE - THMOLL(MEDIUM);
               0  E02=E0*E0;
               0  "BETAI2=E02/(E02-1.0); " "BLIF 96/2/1 -- not needed for Moller fix-up"
               0  EP0=TE(MEDIUM)/EKIN;
               0  "G1=(1.-2.*EP0)*BETAI2;" "BLIF 96/2/1 -- not needed for Moller fix-up"
               0  G2=T0*T0/E02;
               0  G3=(2.*T0+1.)/E02;
               0  "   H.H.NAGEL HAS CONSTRUCTED A FACTORIZATION OF THE FREQUENCY"
               0  "   DISTRIBUTION FUNCTION FOR THE MOLLER DIFFERENTIAL CROSS"
               0  "   SECTION USED AS SUGGESTED BY BUTCHER AND MESSEL."
               0  "   (H.H.NAGEL, OP.CIT., P. 53-55)                                 "
               0  "   HOWEVER, A MUCH SIMPLER SAMPLING METHOD WHICH DOES NOT BECOME  "
               0  "   VERY INEFFICIENT NEAR THMOLL IS THE FOLLOWING. . .             "
               0  "   LET BR=EKS/EKIN,  WHERE EKS IS KINETIC ENERGY TRANSFERED TO THE"
               0  "   SECONDARY ELECTRON AND EKIN IS THE INCIDENT KINETIC ENERGY.    "
               0
               0  "   MODIFIED (7 FEB 1974) TO USE THE TRUE MOLLER CROSS SECTION."
               0  "   THAT IS, INSTEAD OF THE E+ E- AVERAGE GIVEN IN THE ROSSI"
               0  "   FORMULA USED BY NAGEL.  THE SAMPLING SCHEME IS THAT"
               0  "   USED BY MESSEL AND CRAWFORD (EPSDF 1970 P.13)"
               0  "   FIRST SAMPLE (1/BR**2) OVER (TE/EKIN,1/2) . . .            "
               0
               0  GMAX=(1.+1.25*G2); "BLIF 96/2/1 -- Moller fix-up"
               0  LOOP[" TO RETRY IF REJECTED"
               1  $RANDOMSET RNNO27;
               1  BR = TE(MEDIUM)/(EKIN-EXTRAE*RNNO27);
               1
               1  "   USE MESSEL AND CRAWFORDS REJECTION FUNCTION."
               1  R=BR/(1.-BR);
               1  $RANDOMSET RNNO28;
               1  REJF4="G1*"(1.+G2*BR*BR+R*(R-G3)); "BLIF 96/2/1 -- Moller fix-up"
               1  RNNO28=GMAX*RNNO28; "BLIF 96/2/1 -- Moller fix-up"
               1  ]UNTIL RNNO28.LE.REJF4; "TRY UNTIL ACCEPTED. END REJECTION LOOP"
               0
               0  PEKSE2=BR*EKIN; "PRECISE KINETIC ENERGY OF SECONDARY ELECTRON #2"
               0  PESE1=PEIE-PEKSE2; "PRECISE ENERGY OF SECONDARY ELECTRON #1"
               0  PESE2=PEKSE2+PRM; "PRECISE ENERGY OF SECONDARY ELECTRON #2"
               0  ESE1=PESE1; "ENERGY OF SECONDARY ELECTRON 1"
               0  ESE2=PESE2; "ENERGY OF SECONDARY ELECTRON 2"
               0  E(NP)=PESE1;
               0  $CHECK-STACK(np+1,'MOLLER');
               0  E(NP+1)=PESE2;
               0  "   SINCE BR.LE.0.5, E(NP+1) MUST BE .LE. E(NP). "
               0  "   MOLLER ANGLES ARE UNIQUELY DETERMINED BY KINEMATICS            "
               0
               0  " One possible way of dealing with double counting of angular      "
               0  " deflections in inelastic scattering would be to                  "
               0  " not deflect the 'old' electron as these deflections are          "
               0  " already taken into account in the multiple elastic scattering    "
               0  " This approach has the disadvantage of loosing correlations       "
               0  " between big energy losses and strong angular deflections         "
               0  " The advantage of such an approach is its simplicity.             "
               0  " If spin effects for multiple elastic scattering are turned on,   "
               0  " the double counting is taken into account by the appropriate     "
               0  " modification of the scattering power (which depends on AE)       "
               0  "                                                                  "
               0  "                                                                  "
               0  " IK, June 1999                                                    "
               0
               0  H1=(PEIE+PRM)/PEKIN;
               0  "   DIRECTION COSINE CHANGE FOR 'OLD' ELECTRON                     "
               0  DCOSTH=H1*(PESE1-PRM)/(PESE1+PRM);
               0  SINTHE=DSQRT(1.D0-DCOSTH);
               0  COSTHE=DSQRT(DCOSTH);
               0
               0  "sinthe = 0; costhe = 1; <- this will turn off the Moller ang. deflections"
               0
               0  CALL UPHI(2,1);
               0
               0  "   RELATED CHANGE AND (X,Y,Z) SETUP FOR 'NEW' ELECTRON            "
               0  NP=NP+1;
               0  IQ(NP)=-1;
               0  DCOSTH=H1*(PESE2-PRM)/(PESE2+PRM);
               0  SINTHE=-DSQRT(1.D0-DCOSTH);
               0  COSTHE=DSQRT(DCOSTH);
               0  CALL UPHI(3,2);
               0  RETURN;
               0  "END OF SUBROUTINE MOLLER"  END;
               0
1              0  %E
               0
               0  subroutine mscati;
               0  "**********************************************************************"
               0
               0  " Subroutine to read the pre-calculated q^(2+)-surface, prepare data
               0  " required by the mscat and msdist subroutines, initialize spin effect
               0  " corrections
               0  "
               0  " I.Kawrakow, NRC
               0  "**********************************************************************"
               0
               0  implicit none;
               0
               0  $REAL ededx,ei,eil,eip1,eip1l,si,sip1,eke,elke,aux,ecutmn,tstbm,tstbmn;
               0  $REAL p2,beta2,dedx0,ekef,elkef,estepx,ektmp,elktmp,chi_a2;
               0  $INTEGER
               0      i,leil,leip1l,neke,lelke,lelkef,lelktmp;
               0  $LOGICAL  ise_monoton, isp_monoton;
               0
               0  $declare_write_buffer;
               0
               0  "cross section per energy loss"
               0  $REAL sigee,sigep,sig,sige_old,sigp_old;
               0
               0  "entry mscat variables
               0  "======================
               0
               0  $COMIN-MSCATI;
               0
               0  " moved the following from prestaII_inputs, "
               0  " if transport_algorithm = presta-I, exact_bca = .false. and
               0  " skin_depth_for_bca <= 1  ==> calculate default presta-I tmin for bca"
               0
               0  IF( bca_algorithm = 0 ) [ exact_bca = .true.; ]
               0  ELSE                    [ exact_bca = .false.; ]
               0  IF( estepe <= 0 | estepe >= 1) [ estepe = $MAX-ELOSS; ]
               0  IF( ximax <= 0  | ximax >= 1 ) [
               1      IF( exact_bca ) [ ximax = $EXACT-BCA-XIMAX;   ]
               1      ELSE            [ ximax = $INEXACT-BCA-XIMAX; ]
               1  ]
               0  IF (transport_algorithm ~= $PRESTA-II &
               0      transport_algorithm ~= $PRESTA--I &
               0      transport_algorithm ~= $VMC ) [transport_algorithm = $PRESTA-II;]
               0  IF( skindepth_for_bca <= 1e-4 ) [
               1      "IF( transport_algorithm = $PRESTA--I & ~exact_bca ) ["
               1      IF( ~exact_bca ) [
               2          $egs_info(*,' old PRESTA calculates default min. step-size for BCA: ');
               2          $set_ecutmn;
               2          $egs_info(*,'     minimum ECUT found: ',ecutmn);
               2          tstbmn = 1e30;
               2          DO medium = 1,nmed [
               3              tstbm = (ecutmn-prm)*(ecutmn+prm)/ecutmn**2;
               3              tstbm = blcc(medium)*tstbm*(ecutmn/xcc(medium))**2;
               3              aux = Log(tstbm);
               3              IF( aux > 300 ) $egs_info(*,'aux > 300 ? ',aux);
               3              tstbm = Log(tstbm/aux);
               3              "Changed the following to the above so that the Intel compiler"
               3              " does not vectorize the loop with -xK. Vectorizing this loop"
               3              " on an Athlon CPU results in segmentation fault."
               3              " IK, Jan 29 2004."
               3              "tstbm = Log(tstbm/Log(tstbm));"
               3              tstbmn = Min(tstbmn,tstbm);
               3          ]
               2          $egs_info(*,'     default BLCMIN is: ',tstbmn);
               2          skindepth_for_bca = Exp(tstbmn);
               2          $egs_info(*,'     this corresponds to ',skindepth_for_bca,
               2           ' elastic MFPs ');
               2      ]
               1      ELSE [ skindepth_for_bca = $SKIN-DEPTH-FOR-BCA; ]
               1  ]
               0
               0  " read MS data for screened Rutherford scattering "
               0  call init_ms_SR;
               0
               0  DO medium = 1,nmed
               0  [
               1      "Absorb Euler constant into the multiple scattering parameter
               1      "1.16699413758864573 = Exp[2 EulerGamma - 1]
               1      blcc(medium) = 1.16699413758864573*blcc(medium);
               1
               1      "Take its square as this is employed throughout
               1      xcc(medium)  = xcc(medium)**2;
               1  ]
               0
               0  IF( spin_effects ) [ call init_spin; ]
               0
               0  "Determine maximum cross section per energy loss for every medium
               0  $egs_info(*,' ');
               0  esige_max = 0;
               0  psige_max = 0;
               0  DO medium = 1,nmed
               0  [
               1
               1    sigee = 1E-15; sigep = 1E-15;
               1    neke = meke(medium); "Number of elements in storage array
               1    ise_monoton = .true.; isp_monoton = .true.;
               1    sige_old = -1; sigp_old = -1;
               1    DO i = 1,neke
               1    [
               2
               2      ei   = exp((float(i) - eke0(medium))/eke1(medium));
               2      eil  = log(ei);
               2      leil = i;
               2      $EVALUATE ededx USING ededx(eil);
               2      $EVALUATE sig USING esig(eil);
               2      sig = sig/ededx;
               2      IF (sig > sigee) sigee = sig;
               2      IF( sig < sige_old ) ise_monoton = .false.;
               2      sige_old = sig;
               2      $EVALUATE ededx USING pdedx(eil);
               2      $EVALUATE sig USING psig(eil);
               2      sig = sig/ededx;
               2      IF (sig > sigep) sigep = sig;
               2      IF( sig < sigp_old ) isp_monoton = .false.;
               2      sigp_old = sig;
               2
               2    ]
               1    $egs_info(*,' Medium ',medium,' sige = ',sigee,sigep,' monotone = ',
               1            ise_monoton,isp_monoton);
               1    sig_ismonotone(0,medium) = ise_monoton;
               1    sig_ismonotone(1,medium) = isp_monoton;
               1    esig_e(medium) = sigee; psig_e(medium) = sigep;
               1    IF( sigee > esige_max ) esige_max = sigee;
               1    IF( sigep > psige_max ) psige_max = sigep;
               1  ]
               0  $egs_info(*,' ');
               0
               0  $egs_info(*,' Initializing tmxs for estepe = ',estepe,' and ximax = ',ximax);
               0  $egs_info(*,' ');
               0
               0  "Determine upper limit in step size for multiple scattering
               0  DO medium = 1,nmed
               0  [
               1      " Calculate range array first "
               1      " =========================== "
               1      ei   = exp((1 - eke0(medium))/eke1(medium)); "Energy of first table entry
               1      eil  = log(ei);
               1      leil = 1;
               1      E_array(1,medium) = ei;
               1      expeke1(medium) = Exp(1./eke1(medium))-1;
               1      range_ep(0,1,medium) = 0; range_ep(1,1,medium) = 0;
               1      neke = meke(medium); "Number of elements in storage array
               1      DO i = 1,neke - 1
               1      [
               2          eip1   = exp((float(i + 1) - eke0(medium))/eke1(medium)); "Energy at i+1
               2          E_array(i+1,medium) = eip1;
               2          " Calculate range. The following expressions result from the"
               2          " logarithmic interpolation for the (restricted) stopping power "
               2          " and a power power series expansion of the integral "
               2          eke = 0.5*(eip1+ei); elke = Log(eke);
               2          $SET INTERVAL elke,eke;
               2          $EVALUATE ededx USING pdedx(elke);
               2          aux = pdedx1(i,medium)/ededx;
               2          range_ep(1,i+1,medium) = range_ep(1,i,medium) +
               2            (eip1-ei)/ededx*(1+aux*(1+2*aux)*((eip1-ei)/eke)**2/24);
               2          $EVALUATE ededx USING ededx(elke);
               2          aux = ededx1(i,medium)/ededx;
               2          range_ep(0,i+1,medium) = range_ep(0,i,medium) +
               2            (eip1-ei)/ededx*(1+aux*(1+2*aux)*((eip1-ei)/eke)**2/24);
               2          ei = eip1;
               2      ]
               1
               1      " Now tmxs "
               1      " ======== "
               1
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      ei  = Exp(eil); leil = 1; " As in $SET INTERVAL but avoids roundoff
               1      p2  = ei*(ei+2*rm); beta2 = p2/(p2+rm*rm);
               1      chi_a2 = Xcc(medium)/(4*p2*blcc(medium));
               1      $EVALUATE dedx0 USING ededx(eil);
               1      estepx = 2*p2*beta2*dedx0/ei/Xcc(medium)/(Log(1+1./chi_a2)*(1+chi_a2)-1);
               1      estepx = estepx*ximax;
               1      IF( estepx > estepe ) [ estepx = estepe; ]
               1      si = estepx*ei/dedx0;
               1
               1      DO i = 1,neke - 1
               1      [
               2
               2          elke = (i + 1 - eke0(medium))/eke1(medium);
               2          eke  = Exp(elke); lelke = i+1;
               2          p2  = eke*(eke+2*rm); beta2 = p2/(p2+rm*rm);
               2          chi_a2 = Xcc(medium)/(4*p2*blcc(medium));
               2          $EVALUATE ededx USING ededx(elke);
               2          estepx = 2*p2*beta2*ededx/eke/
               2                    Xcc(medium)/(Log(1+1./chi_a2)*(1+chi_a2)-1);
               2          estepx = estepx*ximax;
               2          IF( estepx > estepe ) [ estepx = estepe; ]
               2          ekef = (1-estepx)*eke;
               2          IF( ekef <= E_array(1,medium) )
               2          [
               3              sip1 = (E_array(1,medium) - ekef)/dedx0;
               3              ekef = E_array(1,medium);
               3              elkef = (1 - eke0(medium))/eke1(medium);
               3              lelkef = 1;
               3          ]
               2          ELSE
               2          [
               3              elkef = Log(ekef);
               3              $SET INTERVAL elkef,eke;
               3              leip1l = lelkef + 1;
               3              eip1l  = (leip1l - eke0(medium))/eke1(medium);
               3              eip1   = E_array(leip1l,medium);
               3              aux    = (eip1 - ekef)/eip1;
               3              elktmp = 0.5*(elkef+eip1l+0.25*aux*aux*(1+aux*(1+0.875*aux)));
               3              ektmp  = 0.5*(ekef+eip1);
               3              lelktmp = lelkef;
               3              $EVALUATE ededx USING ededx(elktmp);
               3              aux = ededx1(lelktmp,medium)/ededx;
               3              sip1 = (eip1 - ekef)/ededx*(
               3                       1+aux*(1+2*aux)*((eip1-ekef)/ektmp)**2/24);
               3          ]
               2          sip1 = sip1 + range_ep(0,lelke,medium) - range_ep(0,lelkef+1,medium);
               2
               2          "Now solve these equations
               2          "  si   = tmxs1 * eil   + tmxs0
               2          "  sip1 = tmxs1 * eip1l + tmxs0
               2
               2          tmxs1(i,medium) = (sip1 - si)*eke1(medium);
               2          tmxs0(i,medium) = sip1 - tmxs1(i,medium)*elke;
               2
               2          si  = sip1;
               2      ]
               1
               1      "Now pick up last table entry which applies only to last energy
               1      tmxs0(neke,medium) = tmxs0(neke - 1,medium);
               1      tmxs1(neke,medium) = tmxs1(neke - 1,medium);
               1
               1  ]
               0
               0  return;
               0  end;
               0
1              0  %E
               0  ; "buffer flush
               0
               0  subroutine mscat(lambda,chia2,q1,elke,beta2,qel,medium,
               0                   spin_effects,find_index,spin_index,
               0                   cost,sint);
               0  "========================================================================="
               0  "                                                                         "
               0  " Subroutine to sample multiple electron scattering angles from the exact "
               0  " distribution resulting from elastic scattering described by the screened"
               0  " Rutherford cross section (spin_effects=.false.) or by the screened      "
               0  " Rutherford cross times Mott correction (spin_effects=.true.)            "
               0  "                                                                         "
               0  " I.Kawrakow, NRC                                                         "
               0  "========================================================================="
               0
               0  implicit none;
               0
               0  $REAL    lambda, chia2,q1,elke,beta2,cost,sint;
               0  $INTEGER qel,medium;
               0  $LOGICAL spin_effects,find_index,spin_index;
               0
               0  COMIN/MS-Data,RANDOM,EGS-IO/;
               0
               0  $declare_write_buffer;
               0
               0  $REAL    sprob,explambda,wsum,wprob,xi,rejf,spin_rejection,
               0           cosz,sinz,phi,omega2,llmbda,ai,aj,ak,a,u,du,x1,rnno;
               0  $INTEGER icount,i,j,k;
               0
               0  save     i,j,omega2;
               0
               0  $TURN_OFF_SCATTERING;
               0  " default of above is ';' See definition in egsnrc.macros for example"
               0  " of how to turn off all scattering    DR April 2012"
               0
               0  IF(lambda <= 13.8)
               0  [
               1      "Test only for lambda = 13.8 implies a 1e-6 error, ie large-lambda cases
               1      "that contribute to the forward no-scattering amplitude.
               1      $RANDOMSET sprob;
               1      explambda = Exp(-lambda);
               1      IF (sprob < explambda)
               1      [
               2          "It was a no scattering event
               2          cost = 1; sint = 0;
               2          return;
               2      ]
               1      wsum = (1+lambda)*explambda;
               1      IF ( sprob < wsum )
               1      [
               2        :RETRY_1:;
               2        $RANDOMSET xi;
               2        xi  = 2*chia2*xi/(1 - xi + chia2);
               2        cost = 1 - xi;
               2        IF( spin_effects ) [
               3            rejf = spin_rejection(qel,medium,elke,beta2,q1,cost,
               3                                  spin_index,.false.);
               3            $RANDOMSET rnno;
               3            IF( rnno > rejf ) [ GOTO :RETRY_1:; ]
               3        ]
               2        sint = sqrt(xi*(2 - xi));
               2        return;
               2      ]
               1      IF ( lambda <= 1 )      "IK introduced this portion because with
               1                              "alternative BCAs mscat can be called with
               1                              " lambda < 1 where there are no pre-calculated
               1                              "data
               1      [
               2          wprob = explambda; wsum = explambda;
               2          cost = 1; sint = 0;
               2          icount = 0;
               2          LOOP
               2          [
               3              icount = icount + 1;
               3              IF (icount > 20) EXIT; "To avoid underflow if sprob very close to 1
               3              wprob = wprob*lambda/icount;
               3              wsum = wsum + wprob;
               3              :RETRY_2:;
               3              $RANDOMSET xi;
               3              xi  = 2*chia2*xi/(1 - xi + chia2);
               3              cosz = 1 - xi;
               3              IF( spin_effects ) [
               4                  rejf = spin_rejection(qel,medium,elke,beta2,q1,cosz,
               4                                        spin_index,.false.);
               4                  $RANDOMSET rnno;
               4                  IF( rnno > rejf ) [ GOTO :RETRY_2:; ]
               4              ]
               3              sinz = xi*(2 - xi);
               3              IF ( sinz > 1.e-20 )
               3              [
               4                 sinz = Sqrt(sinz);
               4                 $RANDOMSET xi;
               4                 phi = xi*6.2831853;
               4                 cost = cost*cosz - sint*sinz*Cos(phi);
               4                 sint = Sqrt(Max(0.0,(1-cost)*(1+cost)));
               4               ]
               3          ] UNTIL ( wsum > sprob);
               2          return;
               2      ]
               1  ]
               0
               0  "It was a multiple scattering event
               0  "Sample the angle from the q^(2+) surface
               0
               0  IF (lambda <= $LAMBMAX_MS ) [
               1
               1      IF (find_index)
               1      [
               2          llmbda = log(lambda);
               2
               2          " First fix lambda bin
               2          ai = llmbda*dllambi; i = ai; ai = ai - i;
               2          $RANDOMSET xi;
               2          IF(xi < ai) i = i + 1;
               2
               2          " fix now q1 bin
               2          IF( q1 < $QMIN_MS ) [ j = 0; ]
               2          ELSE IF( q1 < $QMAX_MS ) [
               3              aj = q1*dqmsi; j = aj; aj = aj - j;
               3              $RANDOMSET xi;
               3              IF( xi < aj ) j = j + 1;
               3          ]
               2          ELSE [ j = $MAXQ_MS; ]
               2
               2          " Calculate omega2 "
               2          IF(llmbda < 2.2299) [
               3            omega2 = chia2*(lambda + 4)*(1.347006 + llmbda*(
               3              0.209364 - llmbda*(0.45525 - llmbda*(0.50142 - 0.081234*llmbda))));
               3          ]
               2          ELSE [
               3            omega2 = chia2*(lambda + 4)*(-2.77164 + llmbda*(2.94874 -
               3                     llmbda*(0.1535754 - llmbda*0.00552888)));
               3          ]
               2
               2          find_index = .false.;
               2      ]
               1      "If this is a re-iteration with the same lambda, then omega2, i, and k
               1      "should have been defined in the previous iteration
               1
               1  :RETRY_3:;
               1      $RANDOMSET xi;
               1      ak = xi*$MAXU_MS; k = ak; ak = ak - k;
               1      IF( ak > wms_array(i,j,k) ) k = ims_array(i,j,k);
               1      a = fms_array(i,j,k); u = ums_array(i,j,k);
               1      du = ums_array(i,j,k+1) - u;
               1      $RANDOMSET xi;
               1      IF( abs(a) < 0.2 ) [
               2          x1 = 0.5*(1-xi)*a;
               2          u  = u + xi*du*(1+x1*(1-xi*a));
               2      ]
               1      ELSE [ u = u - du/a*(1-Sqrt(1+xi*a*(2+a))); ]
               1
               1      xi      = omega2*u/(1 + 0.5*omega2 - u);
               1      IF( xi > 1.99999 ) [ xi = 1.99999; ]
               1        "some machines have trouble when xi is very close to 2 in subsequent"
               1        "calculations. IK, April 25 2002"
               1      cost    = 1 - xi;
               1      IF( spin_effects ) [
               2          rejf=spin_rejection(qel,medium,elke,beta2,q1,cost,spin_index,.false.);
               2          $RANDOMSET rnno;
               2          IF( rnno > rejf ) [ GOTO :RETRY_3:; ]
               2      ]
               1      sint    = sqrt(xi*(2-xi));
               1      return;
               1  ]
               0
               0  "This is an error condition
               0
               0  $egs_info(*,' ');
               0  $egs_info(*,' *************************************');
               0  $egs_info(*,' Maximum step size in mscat exceeded! ');
               0  $egs_info(*,' Maximum step size initialized: 100000');
               0  $egs_info(*,' Present lambda: ',lambda);
               0  $egs_info(*,' chia2: ',chia2);
               0  $egs_info(*,' q1 elke beta2: ',q1,elke,beta2);
               0  $egs_info(*,' medium: ',medium);
               0  $egs_fatal(*,' Stopping execution');
               0
               0  end;
               0
1              0  %E
               0  ; "buffer flush
               0
               0  $REAL function spin_rejection(qel,medium,elke,beta2,q1,cost,
               0                                spin_index,is_single);
               0  "============================================================================="
               0  "                                                                             "
               0  " Determines the rejection function due to spin effects for                   "
               0  "   charge        qel (=0 for e-, =1 for e+)                                  "
               0  "   log(energy)   elke                                                        "
               0  "   speed         beta2                                                       "
               0  "   1. MS moment  q1                                                          "
               0  "   cos(theta)    cost                                                        "
               0  "                                                                             "
               0  " I.Kawrakow, NRC                                                             "
               0  "============================================================================="
               0
               0  implicit none;
               0
               0  $REAL      elke,beta2,q1,cost;
               0  $INTEGER   qel,medium;
               0  $LOGICAL   spin_index,is_single;
               0  $declare_max_medium;
               0  COMIN/Spin-Data,RANDOM/;
               0
               0  $REAL      rnno,ai,qq1,aj,xi,ak;
               0  $INTEGER   i,j,k;
               0
               0  save       i,j;
               0
               0  IF( spin_index ) [  "Determine the energy and q1 index
               1      spin_index = .false.;
               1      IF( beta2 >= b2spin_min ) [
               2          ai = (beta2 - b2spin_min)*dbeta2i;
               2          i = ai; ai = ai - i; i = i + $MAXE_SPIN + 1;
               2      ]
               1      ELSE IF( elke > espml ) [
               2          ai = (elke - espml)*dleneri; i = ai; ai = ai - i;
               2      ]
               1      ELSE [ i = 0; ai = -1; ]
               1      $RANDOMSET rnno;
               1      IF( rnno < ai ) i = i + 1;
               1      IF( is_single ) [ j = 0; ]
               1      ELSE [
               2          qq1 = 2*q1; qq1 = qq1/(1 + qq1);
               2          aj = qq1*dqq1i; j = aj;
               2          IF( j >= $MAXQ_SPIN ) [ j = $MAXQ_SPIN; ]
               2          ELSE [  aj = aj - j;
               3                  $RANDOMSET rnno;
               3                  IF( rnno < aj ) j = j + 1;
               3          ]
               2      ]
               1  ]
               0  xi = Sqrt(0.5*(1-cost));
               0  ak = xi*$MAXU_SPIN; k = ak; ak = ak - k;
               0  spin_rejection = (1-ak)*spin_rej(medium,qel,i,j,k) +
               0                       ak*spin_rej(medium,qel,i,j,k+1);
               0  return;
               0  end;
               0
1              0  %E
               0  ; "buffer flush
               0
               0
               0  subroutine sscat(chia2,elke,beta2,qel,medium,spin_effects,cost,sint);
               0  "============================================================================"
               0  "                                                                            "
               0  " single elastic scattering                                                  "
               0  "                                                                            "
               0  " I.Kawrakow, NRC                                                            "
               0  "============================================================================"
               0
               0  implicit none;
               0
               0  $REAL    chia2,elke,beta2,cost,sint;
               0  $INTEGER qel,medium;
               0  $LOGICAL spin_effects;
               0
               0  COMIN/RANDOM/;
               0
               0  $REAL    xi,rnno,rejf,spin_rejection,qzero;
               0  $LOGICAL spin_index;
               0
               0  $TURN_OFF_SCATTERING;
               0  " default of above is ';' See definition in egsnrc.macros for example"
               0  " of how to turn off all scattering    DR April 2012"
               0
               0  spin_index = .true.;
               0  :RETRY-SPIN:;
               0  $RANDOMSET xi;
               0  xi  = 2*chia2*xi/(1 - xi + chia2);
               0  cost = 1 - xi;
               0  IF( spin_effects ) [
               1      qzero=0;
               1      rejf = spin_rejection(qel,medium,elke,beta2,qzero,cost,spin_index,.true.);
               1      $RANDOMSET rnno;
               1      IF( rnno > rejf ) goto :RETRY-SPIN:;
               1  ]
               0  sint = sqrt(xi*(2 - xi));
               0  return;
               0  end;
               0
1              0  %E
               0  ; "buffer flush
               0
               0  subroutine init_ms_SR;
               0  "================================================================"
               0  "                                                                "
               0  " Reads in pre-calculated screened Rutherford multiple elastic   "
               0  " scattering data                                                "
               0  "                                                                "
               0  " I. Kawrakow, NRC                                               "
               0  "================================================================"
               0
               0  implicit none;
               0
               0  COMIN/MS-Data,EGS-IO/;
               0  $declare_write_buffer;
               0
               0  integer*4 i,j,k;
               0
               0  $egs_info('(/a,$)','Reading screened Rutherford MS data ............... ');
               0  rewind($MSCAT-DATAFILE);
               0  DO i=0,$MAXL_MS [
               1      DO j=0,$MAXQ_MS [
               2          read($MSCAT-DATAFILE,*) (ums_array(i,j,k),k=0,$MAXU_MS);
               2          read($MSCAT-DATAFILE,*) (fms_array(i,j,k),k=0,$MAXU_MS);
               2          read($MSCAT-DATAFILE,*) (wms_array(i,j,k),k=0,$MAXU_MS-1);
               2          read($MSCAT-DATAFILE,*) (ims_array(i,j,k),k=0,$MAXU_MS-1);
               2          DO k=0,$MAXU_MS-1 [
               3             fms_array(i,j,k) = fms_array(i,j,k+1)/fms_array(i,j,k)-1;
               3             ims_array(i,j,k) = ims_array(i,j,k)-1;
               3          ]
               2          fms_array(i,j,$MAXU_MS)=fms_array(i,j,$MAXU_MS-1);
               2      ]
               1  ]
               0  $egs_info('(a)',' done ');
               0
               0  llammin = Log($LAMBMIN_MS); llammax = Log($LAMBMAX_MS);
               0  dllamb  = (llammax-llammin)/$MAXL_MS; dllambi = 1./dllamb;
               0  dqms    = $QMAX_MS/$MAXQ_MS; dqmsi = 1./dqms;
               0
               0  return;
               0  end;
               0
1              0  %E
               0  ; "buffer flush
               0
               0  subroutine init_spin;
               0  "======================================================================="
               0  "                                                                       "
               0  " Reads in spin rejection data for multiple elastic scattering and      "
               0  " initializes interpolation arrays for the screening parameter,         "
               0  " elastic cross section, first and second MS moments                    "
               0  "                                                                       "
               0  " I. Kawrakow, NRC                                                      "
               0  "======================================================================="
               0
               0  implicit none;
               0  $declare_max_medium;
               0  COMIN/Spin-Data,ELECIN,MEDIA,BREMPR,THRESH,USEFUL,EGS-IO/;
               0                              "BREMPR is needed for the elemental composition"
               0
               0  $REAL         eta_array(0:1,$0-MAXE_SPI1),
               0                c_array(0:1,$0-MAXE_SPI1),g_array(0:1,$0-MAXE_SPI1),
               0                earray($0-MAXE_SPI1),tmp_array($0-MAXE_SPI1),
               0                sum_Z2,sum_Z,sum_A,sum_pz,Z,tmp,Z23,g_m,g_r,sig,dedx,
               0                tau,tauc,beta2,eta,gamma,fmax,
               0                eil,e,si1e,si2e,si1p,si2p,aae,etap,
               0                elarray($0-MAXE_SPI1),farray($0-MAXE_SPI1),
               0                af($0-MAXE_SPI1),bf($0-MAXE_SPI1),cf($0-MAXE_SPI1),
               0                df($0-MAXE_SPI1),spline,dloge,eloge;
               0
               0  real*4        dum1,dum2,dum3,aux_o; " These must be 32 bit floats!!!!!"
               0
               0  real*4        fmax_array(0:$MAXQ_SPIN);
               0  integer*2     i2_array(512),ii2;
               0
               0  $INTEGER      iq,i,j,k,i_ele,iii,iZ,iiZ,n_ener,n_q,n_point,je,neke,
               0                ndata,leil,length,ii4,irec;
               0
               0  character     spin_file*256;
               0  character*6   string;
               0  integer*4     lnblnk1; "used to be lnblnk but changed for compilers that
               0                         "do not have lnblnk, we supply lnblnk1 in this file
               0
               0  $INTEGER      spin_unit, rec_length, want_spin_unit;
               0  integer       egs_get_unit;
               0  character     data_version*32,endianess*4;
               0  $LOGICAL      swap;
               0
               0  $declare_write_buffer;
               0
               0  $REAL        fine,TF_constant;
               0  parameter    (fine=137.03604, TF_constant=0.88534138);
               0
               0  " stupid GNU compiler complains that the arguments to egs_swap_ are of "
               0  " one kind here, but of some other kind there => need character arrays and "
               0  " equivalence statements"
               0  real*4        tmp_4;
               0  character     c_2(2), c_4(4);
               0  equivalence   (ii2,c_2), (tmp_4,c_4);
               0
               0  " First construct the path to the spin dbase directory "
               0  $set_string(spin_file,' ');
               0  spin_file = $cstring(hen_house) // 'data' // $file_sep // 'spinms.data';
               0  want_spin_unit = 61;
               0  spin_unit = egs_get_unit(want_spin_unit);
               0  IF( spin_unit < 1 ) [
               1      $egs_fatal(*,'init_spin: failed to get a free fortran unit');
               1  ]
               0  rec_length = 276*$RECL-FACTOR;
               0  open(spin_unit,file=spin_file,form='unformatted',access='direct',
               0       status='old',recl=rec_length,err=:spin-open-error:);
               0  read(spin_unit,rec=1,err=:spin-read-error:) data_version,endianess,
               0                        espin_min,espin_max,b2spin_min,b2spin_max;
               0  swap = endianess.ne.$BYTE_ORDER;
               0  IF( swap ) [
               1      tmp_4 = espin_min; call egs_swap_4(c_4); espin_min = tmp_4;
               1      tmp_4 = espin_max; call egs_swap_4(c_4); espin_max = tmp_4;
               1      tmp_4 = b2spin_min; call egs_swap_4(c_4); b2spin_min = tmp_4;
               1      tmp_4 = b2spin_max; call egs_swap_4(c_4); b2spin_max = tmp_4;
               1  ]
               0  $egs_info('(//a,a)','Reading spin data base from ',$cstring(spin_file));
               0  $egs_info('(a)',data_version);
               0  $egs_info('(a,a,a)','Data generated on a machine with ',endianess,
               0          ' endianess');
               0  $egs_info('(a,a)','The endianess of this CPU is ',$BYTE_ORDER);
               0  IF( swap ) $egs_info('(a)','=> will need to do byte swaping');
               0  $egs_info('(a,2f9.2,2f9.5,//)','Ranges: ',espin_min,espin_max,
               0          b2spin_min,b2spin_max);
               0  n_ener = $MAXE_SPIN; n_q = $MAXQ_SPIN; n_point = $MAXU_SPIN;
               0  dloge = log(espin_max/espin_min)/n_ener;
               0  eloge = log(espin_min); earray(0) = espin_min;
               0  $FOOL-INTEL-OPTIMIZER(25) 'Energy grid:';
               0  DO i=1,n_ener [
               1      eloge = eloge + dloge; earray(i) = exp(eloge);
               1      $FOOL-INTEL-OPTIMIZER(25) i,earray(i);
               1  ]
               0  dbeta2 = (b2spin_max - b2spin_min)/n_ener;
               0  beta2 = b2spin_min; earray(n_ener+1) = espin_max;
               0  DO i=n_ener+2,2*n_ener+1 [
               1      beta2 = beta2 + dbeta2;
               1      IF( beta2 < 0.999 ) [ earray(i) = prm*1000.0*(1/sqrt(1-beta2)-1); ]
               1      ELSE [ earray(i) = 50585.1; ]
               1      $FOOL-INTEL-OPTIMIZER(25) i,earray(i);
               1  ]
               0
               0  " Convert to MeV and set interpolation interavals"
               0
               0
               0
               0
               0  espin_min = espin_min/1000; espin_max = espin_max/1000;
               0  dlener = Log(espin_max/espin_min)/$MAXE_SPIN; dleneri = 1/dlener;
               0  espml = Log(espin_min);
               0  dbeta2 = (b2spin_max-b2spin_min)/$MAXE_SPIN; dbeta2i = 1/dbeta2;
               0  dqq1 = 0.5/$MAXQ_SPIN; dqq1i = 1/dqq1;
               0
               0  DO medium = 1,NMED [
               1      $egs_info('(a,i4,a,$)','  medium ',medium,' ..................... ');
               1      DO iq=0,1 [
               2          DO i=0,$MAXE_SPI1 [
               3              /eta_array(iq,i),c_array(iq,i),g_array(iq,i)/=0;
               3              DO j=0,$MAXQ_SPIN [
               4                  DO k=0,$MAXU_SPIN [
               5                      spin_rej(medium,iq,i,j,k) = 0;
               5                  ]
               4              ]
               3          ]
               2      ]
               1      /sum_Z2,sum_A,sum_pz,sum_Z/=0;
               1      DO i_ele=1,NNE(medium) [
               2          Z = ZELEM(medium,i_ele);
               2          iZ = int(Z+0.5);
               2          $FOOL-INTEL-OPTIMIZER(25) ' Z = ',iZ;
               2          tmp = PZ(medium,i_ele)*Z*(Z+1);
               2                "For now, we take into account the contribution of atomic"
               2                "electrons to elastic scattering by replacing Z**2 with  "
               2                "Z*(Z+1). The part of the scattering power that is taken "
               2                "into account by discrete Moller/Bhabha events is        "
               2                "substracted below => bc is energy dependent. We will    "
               2                "worry about better approaches in the future (a realistic"
               2                "inelastic scattering model is needed first)             "
               2          sum_Z2 = sum_Z2 + tmp;
               2          sum_Z  = sum_Z  + PZ(medium,i_ele)*Z;
               2          sum_A  = sum_A  + PZ(medium,i_ele)*WA(medium,i_ele);
               2          sum_pz = sum_pz + PZ(medium,i_ele);
               2          Z23    = Z**0.6666667;
               2          DO iq=0,1 [
               3              DO i=0,$MAXE_SPI1 [
               4                  irec = 1 + (iz-1)*4*(n_ener+1) + 2*iq*(n_ener+1) + i+1;
               4                  $FOOL-INTEL-OPTIMIZER(25) '**** energy ',i,earray(i),irec;
               4                  read(spin_unit,rec=irec,err=:spin-read-error:)
               4                    dum1,dum2,dum3,aux_o,fmax_array,i2_array;
               4                  IF( swap ) [
               5                    tmp_4 = dum1; call egs_swap_4(c_4); dum1 = tmp_4;
               5                    tmp_4 = dum2; call egs_swap_4(c_4); dum2 = tmp_4;
               5                    tmp_4 = dum3; call egs_swap_4(c_4); dum3 = tmp_4;
               5                    tmp_4 = aux_o; call egs_swap_4(c_4); aux_o = tmp_4;
               5                  ]
               4                  eta_array(iq,i)=eta_array(iq,i)+tmp*Log(Z23*aux_o);
               4                  tau = earray(i)/prm*0.001;  "energy in the file is in keV"
               4                  beta2 = tau*(tau+2)/(tau+1)**2;
               4                  eta = Z23/(fine*TF_constant)**2*aux_o/4/tau/(tau+2);
               4                  c_array(iq,i)=c_array(iq,i)+
               4                    tmp*(Log(1+1/eta)-1/(1+eta))*dum1*dum3;
               4                  g_array(iq,i)=g_array(iq,i)+tmp*dum2;
               4                  DO j=0,$MAXQ_SPIN [
               5                      tmp_4 = fmax_array(j);
               5                      IF( swap ) call egs_swap_4(c_4);
               5                      DO k=0,$MAXU_SPIN [
               6                          ii2 = i2_array((n_point+1)*j + k+1);
               6                          IF( swap ) call egs_swap_2(c_2);
               6                          ii4 = ii2;
               6                          IF( ii4 < 0 ) ii4 = ii4 + 65536;
               6                          dum1 = ii4; dum1 = dum1*tmp_4/65535;
               6                          spin_rej(medium,iq,i,j,k) =
               6                            spin_rej(medium,iq,i,j,k) + tmp*dum1;
               6                      ]
               5                  ]
               4              ]
               3          ]
               2      ]
               1
               1      " spin_rej will be used as a rejection function in MS sampling, "
               1      " so scale maximum to unity"
               1      DO iq=0,1 [
               2          DO i=0,$MAXE_SPI1 [
               3              DO j=0,$MAXQ_SPIN [
               4                  fmax = 0;
               4                  DO k=0,$MAXU_SPIN [
               5                      IF( spin_rej(medium,iq,i,j,k) > fmax )
               5                         [ fmax = spin_rej(medium,iq,i,j,k); ]
               5                  ]
               4                  DO k=0,$MAXU_SPIN [
               5                      spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)/fmax;
               5                  ]
               4              ]
               3          ]
               2      ]
               1
               1      " Process eta_array, c_array and g_array to their final form "
               1      $FOOL-INTEL-OPTIMIZER(25) 'Spin corrections as read in from file';
               1      DO i=0,$MAXE_SPI1 [
               2          tau = earray(i)/prm*0.001; beta2 = tau*(tau+2)/(tau+1)**2;
               2          DO iq=0,1 [
               3              aux_o = Exp(eta_array(iq,i)/sum_Z2)/(fine*TF_constant)**2;
               3              eta_array(iq,i) = 0.26112447*aux_o*blcc(medium)/xcc(medium);
               3              eta = aux_o/4/tau/(tau+2);
               3              gamma = 3*(1+eta)*(Log(1+1/eta)*(1+2*eta)-2)/
               3                        (Log(1+1/eta)*(1+eta)-1);
               3              g_array(iq,i) = g_array(iq,i)/sum_Z2/gamma;
               3              c_array(iq,i) = c_array(iq,i)/sum_Z2/(Log(1+1/eta)-1/(1+eta));
               3          ]
               2          $FOOL-INTEL-OPTIMIZER(25) i,earray(i),eta_array(0,i),eta_array(1,i),
               2            c_array(0,i),c_array(1,i),g_array(0,i),g_array(1,i);
               2      ]
               1
               1      " Prepare interpolation table for the screening parameter "
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      e = Exp(eil);
               1      IF( e <= espin_min ) [
               2          si1e = eta_array(0,0); si1p = eta_array(1,0);
               2      ]
               1      ELSE [
               2          IF( e <= espin_max ) [
               3              aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
               3          ]
               2          ELSE [
               3              tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
               3              aae = (beta2 - b2spin_min)*dbeta2i;
               3              je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
               3          ]
               2          si1e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
               2          si1p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
               2      ]
               1      neke = meke(medium);
               1      $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for eta correction';
               1      DO i = 1,neke - 1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium); e = Exp(eil);
               2          IF( e <= espin_min ) [
               3              si2e = eta_array(0,0); si2p = eta_array(1,0);
               3          ]
               2          ELSE [
               3              IF( e <= espin_max ) [
               4                  aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
               4              ]
               3              ELSE [
               4                  tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
               4                  aae = (beta2 - b2spin_min)*dbeta2i;
               4                  je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
               4              ]
               3              si2e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
               3              si2p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
               3          ]
               2          etae_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          etae_ms0(i,medium) = si2e - etae_ms1(i,medium)*eil;
               2          etap_ms1(i,medium) = (si2p - si1p)*eke1(medium);
               2          etap_ms0(i,medium) = si2p - etap_ms1(i,medium)*eil;
               2          $FOOL-INTEL-OPTIMIZER(25) i,e,si2e,si2p,etae_ms1(i,medium),
               2           etae_ms0(i,medium),etap_ms1(i,medium),etap_ms0(i,medium);
               2          si1e = si2e; si1p = si2p;
               2      ]
               1      etae_ms1(neke,medium) = etae_ms1(neke-1,medium);
               1      etae_ms0(neke,medium) = etae_ms0(neke-1,medium);
               1      etap_ms1(neke,medium) = etap_ms1(neke-1,medium);
               1      etap_ms0(neke,medium) = etap_ms0(neke-1,medium);
               1
               1      "Prepare correction to the first MS moment due to spin effects"
               1      "first electrons"
               1      $FOOL-INTEL-OPTIMIZER(25) 'elarray:';
               1      DO i=0,$MAXE_SPIN [
               2          elarray(i) = Log(earray(i)/1000);
               2          farray(i) = c_array(0,i);
               2          $FOOL-INTEL-OPTIMIZER(25) elarray(i),earray(i);
               2      ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [
               2          elarray(i) = Log(earray(i+1)/1000);
               2          farray(i) = c_array(0,i+1);
               2          $FOOL-INTEL-OPTIMIZER(25) elarray(i),earray(i+1);
               2      ]
               1      ndata = $MAXE_SPI1+1;
               1      IF( ue(medium) > 1e5 ) [ elarray(ndata-1) = Log(ue(medium)); ]
               1      ELSE [ elarray(ndata-1) = Log(1e5); ]
               1      farray(ndata-1) = 1;
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q1 correction (e-)';
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q1ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q1ce_ms0(i,medium) = si2e - q1ce_ms1(i,medium)*eil;
               2          $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q1ce_ms1(i,medium),
               2            q1ce_ms0(i,medium);
               2          si1e = si2e;
               2      ]
               1      q1ce_ms1(neke,medium) = q1ce_ms1(neke-1,medium);
               1      q1ce_ms0(neke,medium) = q1ce_ms0(neke-1,medium);
               1      "now positrons"
               1      $FOOL-INTEL-OPTIMIZER(25) 'Postrons:';
               1      DO i=0,$MAXE_SPIN [ farray(i) = c_array(1,i); ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = c_array(1,i+1); ]
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q1 correction (e+)';
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q1cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q1cp_ms0(i,medium) = si2e - q1cp_ms1(i,medium)*eil;
               2          $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q1cp_ms1(i,medium),
               2            q1cp_ms0(i,medium);
               2          si1e = si2e;
               2      ]
               1      q1cp_ms1(neke,medium) = q1cp_ms1(neke-1,medium);
               1      q1cp_ms0(neke,medium) = q1cp_ms0(neke-1,medium);
               1
               1      "prepare interpolation table for the second MS moment correction"
               1      "e-"
               1      DO i=0,$MAXE_SPIN [ farray(i) = g_array(0,i); ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(0,i+1); ]
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q2 correction (e-)';
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q2ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q2ce_ms0(i,medium) = si2e - q2ce_ms1(i,medium)*eil;
               2          $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q2ce_ms1(i,medium),
               2            q2ce_ms0(i,medium);
               2          si1e = si2e;
               2      ]
               1      q2ce_ms1(neke,medium) = q2ce_ms1(neke-1,medium);
               1      q2ce_ms0(neke,medium) = q2ce_ms0(neke-1,medium);
               1      "e+"
               1      DO i=0,$MAXE_SPIN [ farray(i) = g_array(1,i); ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(1,i+1); ]
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      $FOOL-INTEL-OPTIMIZER(25) 'Interpolation table for q2 correction (e+)';
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q2cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q2cp_ms0(i,medium) = si2e - q2cp_ms1(i,medium)*eil;
               2          $FOOL-INTEL-OPTIMIZER(25) Exp(eil),si2e,q2cp_ms1(i,medium),
               2            q2cp_ms0(i,medium);
               2          si1e = si2e;
               2      ]
               1      q2cp_ms1(neke,medium) = q2cp_ms1(neke-1,medium);
               1      q2cp_ms0(neke,medium) = q2cp_ms0(neke-1,medium);
               1
               1      "Now substract scattering power that is already taken into account in"
               1      "discrete Moller/Bhabha events"
               1      tauc = te(medium)/prm;
               1      si1e = 1;
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          e = Exp(eil); leil=i+1; tau=e/prm;
               2          IF( tau > 2*tauc ) [
               3              $EVALUATE sig USING esig(eil);
               3              $EVALUATE dedx USING ededx(eil);
               3              sig = sig/dedx;
               3              IF( sig > 1e-6 ) [ "To be sure that this is not a CSDA calc."
               4                  $EVALUATE etap USING etae_ms(eil);
               4                  eta = 0.25*etap*xcc(medium)/blcc(medium)/tau/(tau+2);
               4                  g_r = (1+2*eta)*Log(1+1/eta)-2;
               4                  g_m = Log(0.5*tau/tauc)+
               4                   (1+((tau+2)/(tau+1))**2)*Log(2*(tau-tauc+2)/(tau+4))-
               4                   0.25*(tau+2)*(tau+2+2*(2*tau+1)/(tau+1)**2)*
               4                      Log((tau+4)*(tau-tauc)/tau/(tau-tauc+2))+
               4                   0.5*(tau-2*tauc)*(tau+2)*(1/(tau-tauc)-1/(tau+1)**2);
               4                  IF( g_m < g_r ) [ g_m = g_m/g_r; ] ELSE [ g_m = 1; ]
               4                  si2e = 1 - g_m*sum_Z/sum_Z2;
               4              ] ELSE [ si2e = 1; ]
               3          ] ELSE [ si2e = 1; ]
               2          blcce1(i,medium) = (si2e - si1e)*eke1(medium);
               2          blcce0(i,medium) = si2e - blcce1(i,medium)*eil;
               2          si1e = si2e;
               2      ]
               1      blcce1(neke,medium) = blcce1(neke-1,medium);
               1      blcce0(neke,medium) = blcce0(neke-1,medium);
               1
               1      "We will not bother to do the same for positrons at this time"
               1
               1      $egs_info('(a)',' done');
               1  ]
               0  close(spin_unit);
               0  return;
               0
               0  :spin-open-error:
               0  $egs_fatal('(a,a)','Failed to open spin data file ',$cstring(spin_file));
               0
               0  :spin-read-error:
               0  $egs_fatal(*,'Error while reading spin data file for element',iZ);
               0
               0  return; end;
1              0  %E
               0
               0  subroutine init_spin_old;
               0  "======================================================================="
               0  "                                                                       "
               0  " Reads in spin rejection data for multiple elastic scattering and      "
               0  " initializes interpolation arrays for the screening parameter,         "
               0  " elastic cross section, first and second MS moments                    "
               0  "                                                                       "
               0  " This version uses the old EGSnrc ASCII spin data format.              "
               0  " If the installation failed to figure out the byte order of your       "
               0  " machine, rename this subroutine to init_spin, the current init_spin   "
               0  " to init_spin_new (or whatever) and download the old spinms data       "
               0  " directory.
               0  "                                                                       "
               0  " I. Kawrakow, NRC                                                      "
               0  "======================================================================="
               0
               0  implicit none;
               0  $declare_max_medium;
               0  COMIN/Spin-Data,ELECIN,MEDIA,BREMPR,THRESH,USEFUL,EGS-IO/;
               0                              "BREMPR is needed for the elemental composition"
               0
               0  $REAL         eta_array(0:1,$0-MAXE_SPI1),
               0                c_array(0:1,$0-MAXE_SPI1),g_array(0:1,$0-MAXE_SPI1),
               0                earray($0-MAXE_SPI1),tmp_array($0-MAXE_SPI1),
               0                sum_Z2,sum_Z,sum_A,sum_pz,Z,tmp,Z23,g_m,g_r,sig,dedx,
               0                dum1,dum2,dum3,aux_o,tau,tauc,beta2,eta,gamma,fmax,
               0                eil,e,si1e,si2e,si1p,si2p,aae,etap,
               0                elarray($0-MAXE_SPI1),farray($0-MAXE_SPI1),
               0                af($0-MAXE_SPI1),bf($0-MAXE_SPI1),cf($0-MAXE_SPI1),
               0                df($0-MAXE_SPI1),spline;
               0
               0  $INTEGER      iq,i,j,k,i_ele,iii,iZ,iiZ,n_ener,n_q,n_point,je,neke,
               0                ndata,leil,length,want_spin_unit,spin_unit,egs_get_unit;
               0
               0  character     spin_file*256;
               0  character*6   string;
               0  integer*4     lnblnk1; "used to be lnblnk but changed for compilers that
               0                         "do not have lnblnk, we supply lnblnk1 in this file
               0  $declare_write_buffer;
               0
               0  $REAL        fine,TF_constant;
               0  parameter    (fine=137.03604, TF_constant=0.88534138);
               0
               0  " First construct the path to the spin dbase directory "
               0  $set_string(spin_file,' ');
               0  spin_file = $cstring(hen_house) // 'data' // $file_sep // 'spinms' //
               0               $file_sep // 'z000';
               0  length = lnblnk1(spin_file);
               0
               0  DO medium = 1,NMED [
               1      $egs_info('(a,i4,a,$)','  Initializing spin data for medium ',medium,
               1                            ' ..................... ');
               1      DO iq=0,1 [
               2          DO i=0,$MAXE_SPI1 [
               3              /eta_array(iq,i),c_array(iq,i),g_array(iq,i)/=0;
               3              DO j=0,$MAXQ_SPIN [
               4                  DO k=0,$MAXU_SPIN [
               5                      spin_rej(medium,iq,i,j,k) = 0;
               5                  ]
               4              ]
               3          ]
               2      ]
               1      /sum_Z2,sum_A,sum_pz,sum_Z/=0;
               1      DO i_ele=1,NNE(medium) [
               2          Z = ZELEM(medium,i_ele);
               2          iZ = int(Z+0.5);
               2          tmp = PZ(medium,i_ele)*Z*(Z+1);
               2                "For now, we take into account the contribution of atomic"
               2                "electrons to elastic scattering by replacing Z**2 with  "
               2                "Z*(Z+1). The part of the scattering power that is taken "
               2                "into account by discrete Moller/Bhabha events is        "
               2                "substracted below => bc is energy dependent. We will    "
               2                "worry about better approaches in the future (a realistic"
               2                "inelastic scattering model is needed first)             "
               2          iii = iZ/100; spin_file(length-2:length-2) = char(iii+48);
               2          iiZ = iZ - iii*100;
               2          iii = iiZ/10; spin_file(length-1:length-1) = char(iii+48);
               2          iiZ = iiZ - 10*iii;
               2          spin_file(length:length) = char(iiZ+48);
               2          want_spin_unit = 61;
               2          spin_unit = egs_get_unit(want_spin_unit);
               2          IF( spin_unit < 1 ) [
               3              $egs_fatal(*,'init_spin: failed to get a free fortran unit');
               3          ]
               2          open(spin_unit,file=spin_file,status='old',err=:SPIN-DBASE-ERROR:);
               2          read(spin_unit,*) espin_min,espin_max,b2spin_min,b2spin_max;
               2          read(spin_unit,*) n_ener,n_q,n_point;
               2          IF( n_ener ~= $MAXE_SPIN | n_q ~= $MAXQ_SPIN | n_point ~= $MAXU_SPIN) [
               3              $egs_fatal(*,' Wrong spin file for Z = ',iZ);
               3          ]
               2          sum_Z2 = sum_Z2 + tmp;
               2          sum_Z  = sum_Z  + PZ(medium,i_ele)*Z;
               2          sum_A  = sum_A  + PZ(medium,i_ele)*WA(medium,i_ele);
               2          sum_pz = sum_pz + PZ(medium,i_ele);
               2          Z23    = Z**0.6666667;
               2          DO iq=0,1 [
               3              read(spin_unit,*); read(spin_unit,*);
               3              DO i=0,$MAXE_SPI1 [
               4                  read(spin_unit,'(a,g14.6)') string,earray(i);
               4                  read(spin_unit,*) dum1,dum2,dum3,aux_o;
               4                  eta_array(iq,i)=eta_array(iq,i)+tmp*Log(Z23*aux_o);
               4                  tau = earray(i)/prm*0.001;  "energy in the file is in keV"
               4                  beta2 = tau*(tau+2)/(tau+1)**2;
               4                  eta = Z23/(fine*TF_constant)**2*aux_o/4/tau/(tau+2);
               4                  c_array(iq,i)=c_array(iq,i)+
               4                    tmp*(Log(1+1/eta)-1/(1+eta))*dum1*dum3;
               4                  g_array(iq,i)=g_array(iq,i)+tmp*dum2;
               4                  DO j=0,$MAXQ_SPIN [
               5                      read(spin_unit,*) tmp_array;
               5                      DO k=0,$MAXU_SPIN [
               6                          spin_rej(medium,iq,i,j,k) =
               6                            spin_rej(medium,iq,i,j,k) + tmp*tmp_array(k);
               6                      ]
               5                  ]
               4              ]
               3          ]
               2          close(spin_unit);
               2      ]
               1
               1      " spin_rej will be used as a rejection function in MS sampling, "
               1      " so scale maximum to unity"
               1      DO iq=0,1 [
               2          DO i=0,$MAXE_SPI1 [
               3              DO j=0,$MAXQ_SPIN [
               4                  fmax = 0;
               4                  DO k=0,$MAXU_SPIN [
               5                      IF( spin_rej(medium,iq,i,j,k) > fmax )
               5                         [ fmax = spin_rej(medium,iq,i,j,k); ]
               5                  ]
               4                  DO k=0,$MAXU_SPIN [
               5                      spin_rej(medium,iq,i,j,k) = spin_rej(medium,iq,i,j,k)/fmax;
               5                  ]
               4              ]
               3          ]
               2      ]
               1
               1      " Process eta_array, c_array and g_array to their final form "
               1      DO i=0,$MAXE_SPI1 [
               2          tau = earray(i)/prm*0.001; beta2 = tau*(tau+2)/(tau+1)**2;
               2          DO iq=0,1 [
               3              aux_o = Exp(eta_array(iq,i)/sum_Z2)/(fine*TF_constant)**2;
               3              eta_array(iq,i) = 0.26112447*aux_o*blcc(medium)/xcc(medium);
               3              eta = aux_o/4/tau/(tau+2);
               3              gamma = 3*(1+eta)*(Log(1+1/eta)*(1+2*eta)-2)/
               3                        (Log(1+1/eta)*(1+eta)-1);
               3              g_array(iq,i) = g_array(iq,i)/sum_Z2/gamma;
               3              c_array(iq,i) = c_array(iq,i)/sum_Z2/(Log(1+1/eta)-1/(1+eta));
               3          ]
               2      ]
               1
               1      " Convert to MeV and set interpolation interavals"
               1      espin_min = espin_min/1000; espin_max = espin_max/1000;
               1      dlener = Log(espin_max/espin_min)/$MAXE_SPIN; dleneri = 1/dlener;
               1      espml = Log(espin_min);
               1      dbeta2 = (b2spin_max-b2spin_min)/$MAXE_SPIN; dbeta2i = 1/dbeta2;
               1      dqq1 = 0.5/$MAXQ_SPIN; dqq1i = 1/dqq1;
               1
               1      " Prepare interpolation table for the screening parameter "
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      e = Exp(eil);
               1      IF( e <= espin_min ) [
               2          si1e = eta_array(0,0); si1p = eta_array(1,0);
               2      ]
               1      ELSE [
               2          IF( e <= espin_max ) [
               3              aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
               3          ]
               2          ELSE [
               3              tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
               3              aae = (beta2 - b2spin_min)*dbeta2i;
               3              je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
               3          ]
               2          si1e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
               2          si1p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
               2      ]
               1      neke = meke(medium);
               1      DO i = 1,neke - 1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium); e = Exp(eil);
               2          IF( e <= espin_min ) [
               3              si2e = eta_array(0,0); si2p = eta_array(1,0);
               3          ]
               2          ELSE [
               3              IF( e <= espin_max ) [
               4                  aae = (eil-espml)*dleneri; je = aae; aae = aae - je;
               4              ]
               3              ELSE [
               4                  tau = e/prm; beta2 = tau*(tau+2)/(tau+1)**2;
               4                  aae = (beta2 - b2spin_min)*dbeta2i;
               4                  je = aae; aae = aae - je; je = je + $MAXE_SPIN + 1;
               4              ]
               3              si2e = (1-aae)*eta_array(0,je) + aae*eta_array(0,je+1);
               3              si2p = (1-aae)*eta_array(1,je) + aae*eta_array(1,je+1);
               3          ]
               2          etae_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          etae_ms0(i,medium) = si2e - etae_ms1(i,medium)*eil;
               2          etap_ms1(i,medium) = (si2p - si1p)*eke1(medium);
               2          etap_ms0(i,medium) = si2p - etap_ms1(i,medium)*eil;
               2          si1e = si2e; si1p = si2p;
               2      ]
               1      etae_ms1(neke,medium) = etae_ms1(neke-1,medium);
               1      etae_ms0(neke,medium) = etae_ms0(neke-1,medium);
               1      etap_ms1(neke,medium) = etap_ms1(neke-1,medium);
               1      etap_ms0(neke,medium) = etap_ms0(neke-1,medium);
               1
               1      "Prepare correction to the first MS moment due to spin effects"
               1      "first electrons"
               1      DO i=0,$MAXE_SPIN [
               2          elarray(i) = Log(earray(i)/1000);
               2          farray(i) = c_array(0,i);
               2      ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [
               2          elarray(i) = Log(earray(i+1)/1000);
               2          farray(i) = c_array(0,i+1);
               2      ]
               1      ndata = $MAXE_SPI1+1;
               1      IF( ue(medium) > 1e5 ) [ elarray(ndata-1) = Log(ue(medium)); ]
               1      ELSE [ elarray(ndata-1) = Log(1e5); ]
               1      farray(ndata-1) = 1;
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q1ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q1ce_ms0(i,medium) = si2e - q1ce_ms1(i,medium)*eil;
               2          si1e = si2e;
               2      ]
               1      q1ce_ms1(neke,medium) = q1ce_ms1(neke-1,medium);
               1      q1ce_ms0(neke,medium) = q1ce_ms0(neke-1,medium);
               1      "now positrons"
               1      DO i=0,$MAXE_SPIN [ farray(i) = c_array(1,i); ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = c_array(1,i+1); ]
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q1cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q1cp_ms0(i,medium) = si2e - q1cp_ms1(i,medium)*eil;
               2          si1e = si2e;
               2      ]
               1      q1cp_ms1(neke,medium) = q1cp_ms1(neke-1,medium);
               1      q1cp_ms0(neke,medium) = q1cp_ms0(neke-1,medium);
               1
               1      "prepare interpolation table for the second MS moment correction"
               1      "e-"
               1      DO i=0,$MAXE_SPIN [ farray(i) = g_array(0,i); ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(0,i+1); ]
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q2ce_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q2ce_ms0(i,medium) = si2e - q2ce_ms1(i,medium)*eil;
               2          si1e = si2e;
               2      ]
               1      q2ce_ms1(neke,medium) = q2ce_ms1(neke-1,medium);
               1      q2ce_ms0(neke,medium) = q2ce_ms0(neke-1,medium);
               1      "e+"
               1      DO i=0,$MAXE_SPIN [ farray(i) = g_array(1,i); ]
               1      DO i=$MAXE_SPIN+1,$MAXE_SPI1-1 [ farray(i) = g_array(1,i+1); ]
               1      call set_spline(elarray,farray,af,bf,cf,df,ndata);
               1      eil = (1 - eke0(medium))/eke1(medium);
               1      si1e = spline(eil,elarray,af,bf,cf,df,ndata);
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          si2e = spline(eil,elarray,af,bf,cf,df,ndata);
               2          q2cp_ms1(i,medium) = (si2e - si1e)*eke1(medium);
               2          q2cp_ms0(i,medium) = si2e - q2cp_ms1(i,medium)*eil;
               2      ]
               1      q2cp_ms1(neke,medium) = q2cp_ms1(neke-1,medium);
               1      q2cp_ms0(neke,medium) = q2cp_ms0(neke-1,medium);
               1
               1      "Now substract scattering power that is already taken into account in"
               1      "discrete Moller/Bhabha events"
               1      tauc = te(medium)/prm;
               1      si1e = 1;
               1      DO i=1,neke-1 [
               2          eil = (i+1 - eke0(medium))/eke1(medium);
               2          e = Exp(eil); leil=i+1; tau=e/prm;
               2          IF( tau > 2*tauc ) [
               3              $EVALUATE sig USING esig(eil);
               3              $EVALUATE dedx USING ededx(eil);
               3              sig = sig/dedx;
               3              IF( sig > 1e-6 ) [ "To be sure that this is not a CSDA calc."
               4                  $EVALUATE etap USING etae_ms(eil);
               4                  eta = 0.25*etap*xcc(medium)/blcc(medium)/tau/(tau+2);
               4                  g_r = (1+2*eta)*Log(1+1/eta)-2;
               4                  g_m = Log(0.5*tau/tauc)+
               4                   (1+((tau+2)/(tau+1))**2)*Log(2*(tau-tauc+2)/(tau+4))-
               4                   0.25*(tau+2)*(tau+2+2*(2*tau+1)/(tau+1)**2)*
               4                      Log((tau+4)*(tau-tauc)/tau/(tau-tauc+2))+
               4                   0.5*(tau-2*tauc)*(tau+2)*(1/(tau-tauc)-1/(tau+1)**2);
               4                  IF( g_m < g_r ) [ g_m = g_m/g_r; ] ELSE [ g_m = 1; ]
               4                  si2e = 1 - g_m*sum_Z/sum_Z2;
               4              ] ELSE [ si2e = 1; ]
               3          ] ELSE [ si2e = 1; ]
               2          blcce1(i,medium) = (si2e - si1e)*eke1(medium);
               2          blcce0(i,medium) = si2e - blcce1(i,medium)*eil;
               2          si1e = si2e;
               2      ]
               1      blcce1(neke,medium) = blcce1(neke-1,medium);
               1      blcce0(neke,medium) = blcce0(neke-1,medium);
               1
               1      "We will not bother to do the same for positrons at this time"
               1
               1      $egs_info('(a)',' done');
               1  ]
               0  return;
               0
               0  :SPIN-DBASE-ERROR:
               0  $egs_info(*,' ******************** Error in init_spin ******************* ');
               0  $egs_info('(a,a)','  could not open file ',spin_file);
               0  $egs_fatal(*,' terminating execution ');
               0
               0  end;
1              0  %E
               0  ; "buffer flush
               0
               0  "======================================================================"
               0  "                 subroutine msdist_pII                                "
               0  "                 =====================                                "
               0  "                                                                      "
               0  "  This subroutine models multiple elastic scattering and spatial      "
               0  "  deflections for a given path-length tustep.                         "
               0  "  For description of input and output variables see below             "
               0  "                                                                      "
               0  "  September 1996      Iwan Kawrakow        Initial coding (in fortran)"
               0  "  March 1997          Alex Bielajew        Adaption for EGS4          "
               0  "  April/Mai 1997      Iwan Kawrakow        Debuging of the EGS4       "
               0  "                                           mortran version by Bielajew"
               0  "  June 1997           Iwan Kawrakow        Improved energy loss       "
               0  "                                           corrections                "
               0  "  June 1999           Iwan Kawrakow        spin effects, removed      "
               0  "                                           $SUBSTEP-ELOSS-EVALUATION  "
               0  "                                                                      "
               0  "======================================================================"
               0  "                                                                      "
               0  subroutine msdist_pII
               0  (
               0      e0,eloss,tustep,rhof,med,qel,spin_effects,u0,v0,w0,x0,y0,z0, "Inputs
               0      us,vs,ws,xf,yf,zf,ustep                                         "Outputs
               0  );
               0
               0  $IMPLICIT-NONE;
               0
               0  " Input variables
               0  " ===============
               0  $REAL
               0      e0,     "electron kinetic energy at the beginning of step
               0      eloss,  "energy loss for this step
               0      rhof,   "density scaling template (as in EGS)
               0      tustep, "total pathlength of the step,
               0      u0,     "x-direction cosine before scattering
               0      v0,     "y-direction cosine before scattering
               0      w0,     "z-direction cosine before scattering
               0      x0,     "initial x-position
               0      y0,     "initial y-position
               0      z0      "initial z-position
               0  ;
               0  $INTEGER
               0      med,"medium number
               0      qel    "=0 for e-, =1 for e+, needed for spin effects
               0  ;
               0  $LOGICAL
               0      spin_effects;
               0  ;
               0
               0  " Output variables
               0  " ================
               0  $REAL
               0      us,    "x-direction cosine after scattering
               0      vs,    "y-direction cosine after scattering
               0      ws,    "z-direction cosine after scattering
               0      xf,    "final x-position after transport
               0      yf,    "final y-position after transport
               0      zf,    "final z-position after transport
               0      ustep  "straight line distance between the initial and final position
               0  ;
               0
               0  " Local variables
               0  " ===============
               0  $REAL
               0      b,         "substep transport distance,
               0      blccc,     "multiple scattering parameter
               0      xcccc,     "multiple scattering parameter
               0      c,         "substep transport distance,
               0      eta,eta1,  "randomization of the substep transport distances
               0      chia2,     "screening angle, note: our chia2 is Moliere's chia2/4
               0      chilog,    "log(1+1/chia2)
               0      cphi0,     "cosine of the azimuthal angle of the initial particle relative
               0                 "to its coordinates
               0      cphi1,     "cosine of the first azimuthal angle
               0      cphi2,     "cosine of the second azimuthal angle
               0      w1,        "cosine of the first substep polar scattering angle
               0      w2,        "cosine of the second substep polar scattering angle
               0      w1v2,      "w1*v2;
               0      delta,     "transport parameter (see paper)
               0      e,         "average kinetic energy over the step
               0      elke,      "Log(e)"
               0      beta2,     "speed at e in units of c, squared"
               0      etap,      "correction to the screening parameter derived from PWA
               0      xi_corr,   "correction to the first MS moments due to spin
               0      ms_corr,
               0      tau,       "average kinetic energy over the step divided by electron mass
               0      tau2,      "tau squared
               0      epsilon,   "fractional energy loss
               0      epsilonp,  "fractional energy loss
               0      temp,temp1,"auxilarity variables for energy loss corrections
               0      temp2,     "
               0      factor,    "intermediate factor employed in the energy-loss calculations
               0      gamma,     "q2/q1
               0      lambda,    "distance in number of elastic scattering mean free paths
               0                 "for each sample of the multiple scattering angle
               0      p2,        "average momentum over the step
               0      p2i,       "inverse of ap2
               0      q1,        "first moment of the single scattering cross section
               0      rhophi2,   "xphi**2 + yphi**2 or its inverse
               0      sint0,     "sine of the initial particle relative to its coordinates
               0      sint02,    "sint0**2
               0      sint0i,    "1/sint0
               0      sint1,     "sine   of the first substep polar scattering angle
               0      sint2,     "sine   of the second substep polar scattering angle
               0      sphi0,     "sine of the azimuthal angle of the initial particle relative
               0                 "to its coordinates
               0      sphi1,     "sine   of the first azimuthal angle
               0      sphi2,     "sine   of the second azimuthal angle
               0      u2p,       "intermediate scatter or transport direction cosine
               0      u2,        "sint2*cphi2;
               0      v2,        "sint2*sphi2;
               0      ut,        "x-direction cosine for transport
               0      vt,        "y-direction cosine for transport
               0      wt,        "z-direction cosine for transport
               0      xi,        "first GS - moment
               0      xphi,      "x - used to calculated azimuthal angles
               0      xphi2,     "xphi**2
               0      yphi,      "y - used to calculated azimuthal angles
               0      yphi2      "yphi**2
               0  ;
               0  $LOGICAL
               0     find_index,  "needed to save locating the q2 index in the 2. call to mscat"
               0     spin_index   "saves locating the spin rejection index in 2. call to mscat"
               0  ;
               0  $INTEGER
               0     lelke
               0  ;
               0  $declare_max_medium;
               0  ;COMIN/ELECIN,THRESH,UPHIOT,RANDOM,CH-Steps,USEFUL/;
               0
               0  medium  = med;
               0
               0  count_pII_steps = count_pII_steps + 1;
               0  blccc   = blcc(medium);
               0  xcccc   = xcc(medium);
               0
               0  "Commonly used factors
               0  e       = e0 - 0.5*eloss;
               0  tau     = e/prm;
               0  tau2    = tau*tau;
               0  epsilon = eloss/e0;
               0  epsilonp= eloss/e;
               0  "e       = e * (1 - epsilonp*epsilonp*((6+tau*(10+5*tau))/(tau+1)/(tau+2))/24);
               0  e       = e * (1 - epsilonp*epsilonp*(6+10*tau+5*tau2)/(24*tau2+72*tau+48));
               0  p2      = e*(e + rmt2);
               0  "p2i     = 1/p2;
               0  beta2   = p2/(p2 + rmsq);
               0  "chia2   = xcccc*p2i/(4*blccc);
               0  chia2   = xcccc/(4*p2*blccc);
               0  lambda  = 0.5*tustep*rhof*blccc/beta2; "The 0.5 implies a half-step
               0
               0  temp2  = 0.166666*(4+tau*(6+tau*(7+tau*(4+tau))))*
               0               (epsilonp/((tau+1)*(tau+2)))**2;
               0  lambda = lambda*(1 - temp2);
               0
               0  IF ( spin_effects ) [
               1     elke = Log(e);
               1     $SET INTERVAL elke,eke;
               1     IF ( lelke < 1 ) [ "This should normally not happen"
               2         lelke = 1; elke = (1 - eke0(medium))/eke1(medium);
               2     ]
               1     IF( qel = 0 ) [
               2         $EVALUATE etap USING etae_ms(elke);
               2         $EVALUATE xi_corr USING q1ce_ms(elke);
               2         $EVALUATE gamma USING q2ce_ms(elke);
               2     ]
               1     ELSE [
               2         $EVALUATE etap USING etap_ms(elke);
               2         $EVALUATE xi_corr USING q1cp_ms(elke);
               2         $EVALUATE gamma USING q2cp_ms(elke);
               2     ]
               1     $EVALUATE ms_corr USING blcce(elke);
               1  ]
               0  ELSE [ etap = 1; xi_corr = 1; gamma = 1; ms_corr = 1; ]
               0
               0  chia2  = chia2*etap;
               0  lambda = lambda/(etap*(1+chia2))*ms_corr;
               0  chilog = Log(1 + 1/chia2);
               0  q1     = 2*chia2*(chilog*(1 + chia2) - 1);
               0  gamma  = 6*chia2*(1 + chia2)*(chilog*(1 + 2*chia2) - 2)/q1*gamma;
               0  xi     = q1*lambda;
               0
               0  "Sample first substep scattering angle
               0  find_index = .true.; spin_index = .true.;
               0  call mscat(lambda,chia2,xi,elke,beta2,qel,medium,
               0             spin_effects,find_index,spin_index,
               0             w1,sint1);
               0  $SELECT-AZIMUTHAL-ANGLE(cphi1,sphi1);
               0
               0  "Sample second substep scattering angle
               0  call mscat(lambda,chia2,xi,elke,beta2,qel,medium,
               0             spin_effects,find_index,spin_index,
               0             w2,sint2);
               0  $SELECT-AZIMUTHAL-ANGLE(cphi2,sphi2);
               0
               0  "Final direction of motion, relative to z-axis motion
               0  u2  = sint2*cphi2;
               0  v2  = sint2*sphi2;
               0  u2p = w1*u2 + sint1*w2;
               0  us  = u2p*cphi1 - v2*sphi1;
               0  vs  = u2p*sphi1 + v2*cphi1;
               0  ws  = w1*w2 - sint1*u2;
               0
               0  "Calculate delta, b, c
               0
               0  xi = 2*xi*xi_corr;  "xi was for half step, xi_corr corrects for spin effects
               0
               0  $RANDOMSET eta; eta = Sqrt(eta); eta1 = 0.5*(1 - eta);
               0  delta  = 0.9082483-(0.1020621-0.0263747*gamma)*xi;
               0
               0  "Correct the coefficients for energy loss
               0  temp1 = 2 + tau;
               0  temp = (2+tau*temp1)/((tau+1)*temp1);
               0  "Take logarithmic dependence into account as well
               0  temp = temp - (tau+1)/((tau+2)*(chilog*(1+chia2)-1));
               0  temp = temp * epsilonp;
               0  temp1 = 1 - temp;
               0  delta = delta + 0.40824829*(epsilon*(tau+1)/((tau+2)*
               0            (chilog*(1+chia2)-1)*(chilog*(1+2*chia2)-2)) - 0.25*temp*temp);
               0             "0.40824829 is 1/Sqrt(6)"
               0  b      = eta*delta;
               0  c      = eta*(1-delta);
               0
               0  "Calculate transport direction cosines
               0  w1v2 = w1*v2;
               0  ut   = b*sint1*cphi1 + c*(cphi1*u2 - sphi1*w1v2) + eta1*us*temp1;
               0  vt   = b*sint1*sphi1 + c*(sphi1*u2 + cphi1*w1v2) + eta1*vs*temp1;
               0  wt   = eta1*(1+temp) +        b*w1 +  c*w2       + eta1*ws*temp1;
               0
               0  "Calculate transport distance
               0  ustep  = tustep*sqrt(ut*ut + vt*vt + wt*wt);
               0
               0  "Rotate into the final direction of motion and transport
               0  "relative to original direction of motion
               0  sint02 = u0**2 + v0**2;
               0  IF (sint02 > 1e-20)
               0  [
               1      sint0  = sqrt(sint02);
               1      sint0i = 1/sint0;
               1      cphi0  = sint0i*u0;
               1      sphi0  = sint0i*v0;
               1
               1      "Scattering angles
               1      u2p    = w0*us + sint0*ws;
               1      ws     = w0*ws - sint0*us;
               1      us     = u2p*cphi0 - vs*sphi0;
               1      vs     = u2p*sphi0 + vs*cphi0;
               1
               1      "Transport angles
               1      u2p    = w0*ut + sint0*wt;
               1      wt     = w0*wt - sint0*ut;
               1      ut     = u2p*cphi0 - vt*sphi0;
               1      vt     = u2p*sphi0 + vt*cphi0;
               1  ]
               0  ELSE [ wt = w0*wt; ws = w0*ws; ]
               0
               0  "Transport
               0  xf = x0 + tustep*ut;
               0  yf = y0 + tustep*vt;
               0  zf = z0 + tustep*wt;
               0
               0  return;
               0  end;
               0
               0  ;
               0
               0  "                 subroutine msdist_pI                                 "
               0  "                 ====================                                 "
               0  "                                                                      "
               0  "  This subroutine models multiple elastic scattering and spatial      "
               0  "  deflections for a given path-length tustep                          "
               0  "  resampling PRESTA-I behaviour.                                      "
               0  "                                                                      "
               0  "  October 1997        Iwan Kawrakow        Initial coding             "
               0  "  June    1999        Iwan Kawrakow        spin effects               "
               0  "                                                                      "
               0  "======================================================================"
               0  "                                                                      "
               0  subroutine msdist_pI
               0  (
               0      e0,eloss,tustep,rhof,medium,qel,spin_effects,u0,v0,w0,x0,y0,z0, "Inputs
               0      us,vs,ws,xf,yf,zf,ustep                                         "Outputs
               0  );
               0
               0  $IMPLICIT-NONE;
               0
               0  " Input variables
               0  " ===============
               0  $REAL
               0      e0,     "electron kinetic energy at the beginning of step
               0      eloss,  "energy loss for this step
               0      rhof,   "density scaling template (as in EGS)
               0      tustep, "total pathlength of the step,
               0      u0,     "x-direction cosine before scattering
               0      v0,     "y-direction cosine before scattering
               0      w0,     "z-direction cosine before scattering
               0      x0,     "initial x-position
               0      y0,     "initial y-position
               0      z0      "initial z-position
               0  ;
               0  $INTEGER
               0      medium,"medium number
               0      qel    "=0 for e-, =1 for e+, needed for spin effects
               0  ;
               0  $LOGICAL
               0      spin_effects
               0  ;
               0
               0  " Output variables
               0  " ================
               0  $REAL
               0      us,    "x-direction cosine after scattering
               0      vs,    "y-direction cosine after scattering
               0      ws,    "z-direction cosine after scattering
               0      xf,    "final x-position after transport
               0      yf,    "final y-position after transport
               0      zf,    "final z-position after transport
               0      ustep  "straight line distance between the initial and final position
               0  ;
               0
               0  " Local variables
               0  " ===============
               0  $REAL
               0      blccc,     "multiple scattering parameter
               0      xcccc,     "multiple scattering parameter
               0      z,r,z2,r2, "used to calculate PLC and lateral deflection a la PRESTA-I
               0      r2max,
               0      chia2,     "screening angle, note: our chia2 is Moliere's chia2/4
               0      chilog,    "log(1+1/chia2)
               0      cphi0,     "cosine of the azimuthal angle of the initial particle relative
               0                 "to its coordinates
               0      cphi,      "cosine of the azimuthal scattering angle
               0      sphi,      "sine of the  azimuthal scattering angle
               0      e,         "average kinetic energy over the step
               0      elke,      "Log(e)
               0      beta2,     "speed at e in units of c, squared
               0      etap,      "correction to the screening angle derived from PWA
               0      xi_corr,   "correction to the first MS moment due to spin
               0      ms_corr,
               0      epsilon,   "fractional energy loss
               0      temp,      "auxilarity variable for energy loss corrections
               0      factor,    "intermediate factor employed in the energy-loss calculations
               0      lambda,    "distance in number of elastic scattering mean free paths
               0      p2,        "average momentum over the step
               0      p2i,       "inverse of p2
               0      q1,        "first moment of the single scattering cross section
               0      rhophi2,   "xphi**2 + yphi**2 or its inverse
               0      sint,      "sine of the MS angle
               0      sint0,     "sine of the initial particle relative to its coordinates
               0      sint02,    "sint0**2
               0      sint0i,    "1/sint0
               0      sphi0,     "sine of the azimuthal angle of the initial particle relative
               0                 "to its coordinates
               0      u2p,       "intermediate scatter or transport direction cosine
               0      ut,        "x-direction cosine for transport
               0      vt,        "y-direction cosine for transport
               0      wt,        "z-direction cosine for transport
               0      xi,        "first GS - moment
               0      xphi,      "x - used to calculated azimuthal angles
               0      xphi2,     "xphi**2
               0      yphi,      "y - used to calculated azimuthal angles
               0      yphi2      "yphi**2
               0  ;
               0  $LOGICAL
               0     find_index, "needed to save locating the q2 index in the 2. call to mscat"
               0     spin_index
               0  ;
               0  $INTEGER
               0     lelke
               0  ;
               0  $declare_max_medium;
               0  ;COMIN/ELECIN,THRESH,UPHIOT,RANDOM/;
               0
               0  blccc   = blcc(medium);
               0  xcccc   = xcc(medium);
               0
               0  e       = e0 - 0.5*eloss;
               0  p2      = e*(e + rmt2);
               0  p2i     = 1/p2;
               0  chia2   = xcccc*p2i/(4*blccc);
               0  beta2   = p2/(p2 + rmsq);
               0  lambda  = tustep*rhof*blccc/beta2;
               0
               0  "Account for energy loss in the MS distribution
               0  factor = 1/(1 + 0.9784671*e); "0.9784671 = 1/(2*rm)
               0  epsilon= eloss/e0;
               0  epsilon= epsilon/(1-0.5*epsilon);
               0  temp   = 0.25*(1 - factor*(1 - 0.333333*factor))*epsilon**2;
               0  lambda = lambda*(1 + temp);
               0
               0  IF ( spin_effects ) [
               1     elke = Log(e);
               1     $SET INTERVAL elke,eke;
               1     IF ( lelke < 1 ) [ "This should normally not happen"
               2         lelke = 1; elke = (1 - eke0(medium))/eke1(medium);
               2     ]
               1     IF( qel = 0 ) [
               2         $EVALUATE etap USING etae_ms(elke);
               2         $EVALUATE xi_corr USING q1ce_ms(elke);
               2     ]
               1     ELSE [
               2         $EVALUATE etap USING etap_ms(elke);
               2         $EVALUATE xi_corr USING q1cp_ms(elke);
               2     ]
               1     $EVALUATE ms_corr USING blcce(elke);
               1  ]
               0  ELSE [ etap = 1; xi_corr = 1; ms_corr = 1; ]
               0
               0  chia2   = xcccc*p2i/(4*blccc)*etap;
               0  lambda = lambda/etap/(1+chia2)*ms_corr;
               0  chilog = Log(1 + 1/chia2);
               0  q1     = 2*chia2*(chilog*(1 + chia2) - 1);
               0  xi     = q1*lambda;
               0
               0  "Sample multiple scattering angle
               0  find_index = .true.; spin_index = .true.;
               0  call mscat(lambda,chia2,xi,elke,beta2,qel,medium,
               0             spin_effects,find_index,spin_index,
               0             ws,sint);
               0  $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               0  us  = sint*cphi;
               0  vs  = sint*sphi;
               0
               0  "Correct xi used for the PLC calc. for spin effects
               0  xi     = xi*xi_corr;
               0
               0  "Calculate PLC and lateral transport a la PRESTA-I
               0  "Note that we use here the exact expression for <z>
               0  "because it is much simpler and faster than the original PRESTA-I formulas
               0  "(which are also second order approximations)
               0  IF ( xi < 0.1 )
               0  [
               1     z = 1 - xi*(0.5 - xi*(0.166666667 - 0.041666667*xi));
               1  ]
               0  ELSE
               0  [
               1     z = (1 - Exp(-xi))/xi;
               1  ]
               0  r  = 0.5*sint;
               0  r2 = r*r; z2 = z*z;
               0  r2max = 1 - z2;
               0  IF ( r2max < r2 ) [ r2 = r2max; r = Sqrt(r2); ]
               0
               0  "Calculate final position vector
               0  ut   = r*cphi; vt = r*sphi; wt = z;
               0
               0  "Calculate transport distance
               0  ustep = Sqrt(z2 + r2)*tustep;
               0
               0  "Rotate into the final direction of motion and transport
               0  "relative to original direction of motion
               0  sint02 = u0**2 + v0**2;
               0  IF (sint02 > 1e-20)
               0  [
               1      sint0  = sqrt(sint02);
               1      sint0i = 1/sint0;
               1      cphi0  = sint0i*u0;
               1      sphi0  = sint0i*v0;
               1
               1      "Scattering angles
               1      u2p    = w0*us + sint0*ws;
               1      ws     = w0*ws - sint0*us;
               1      us     = u2p*cphi0 - vs*sphi0;
               1      vs     = u2p*sphi0 + vs*cphi0;
               1
               1      "Transport angles
               1      u2p    = w0*ut + sint0*wt;
               1      wt     = w0*wt - sint0*ut;
               1      ut     = u2p*cphi0 - vt*sphi0;
               1      vt     = u2p*sphi0 + vt*cphi0;
               1  ]
               0  ELSE [ wt = w0*wt; ws = w0*ws; ]
               0
               0  "Transport
               0  xf = x0 + tustep*ut;
               0  yf = y0 + tustep*vt;
               0  zf = z0 + tustep*wt;
               0
               0  return;
               0  end;
               0
               0  ;
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE PAIR;
               0  "                                                                  "
               0  "******************************************************************"
               0  "   For a photon energy below 2.1 MeV, the energies of the pair    "
               0  "   particles are uniformly distributed in the allowed range via   "
               0  "   the default replacement for $SELECT-LOW-ENERGY-PAIR-PRODICTION;"
               0  "   If the user has a better approach, modify this macro.          "
               0  "   For a photon energy between 2.1 and 50 MeV the Bethe-Heitler   "
               0  "   cross section is employed, above 50 MeV the Coulomb-corrected  "
               0  "   Bethe-Heitler is used.                                         "
               0  "   Modified from its original version to make compatible with the "
               0  "   changes made in BREMS.                                         "
               0  "                                                                  "
               0  "   I. Kawrakow                                                    "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-PAIR;     "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/DEBUG,BREMPR,EGS-VARIANCE-REDUCTION,STACK,"
               0                                   "THRESH,UPHIOT,USEFUL,RANDOM/;"
               0
               0  $DEFINE-LOCAL-VARIABLES-PAIR;
               0
               0  $DEFINE-VARIABLES-FOR-SET-PAIR-ANGLE;
               0
               0  $REAL    k,xx,abin,rbin,alias_sample1;
               0  $INTEGER ibin, iq1, iq2, iprdst_use;
               0  $LOGICAL do_nrc_pair;
               0  $INTEGER itrip;
               0  $REAL    ftrip;
               0
               0  NPold = NP;      "Set the old stack counter"
               0
               0  IF( i_play_RR = 1 ) [ " The user wants to play Russian Roulette. For pair "
               1                        " it is much more efficient to do it BEFORE the "
               1                        " actual sampling "
               1      i_survived_RR = 0;  "flag they all survive inititally"
               1      IF( prob_RR <= 0 ) [
               2          IF( n_RR_warning < $MAX-RR-WARNING ) [
               3            n_RR_warning = n_RR_warning + 1;
               3            $egs_warning('(a,g14.6)',
               3                        'Attempt to play Russian Roulette with prob_RR<0! ');
               3          ]
               2      ]
               1      ELSE [
               2          $RANDOMSET rnno_RR;
               2          IF( rnno_RR > prob_RR ) [  "The pair was killed "
               3              i_survived_RR =2; "flag both particles eliminated"
               3              IF( np > 1 ) [ np = np-1; ]
               3              ELSE [ " We have just one photon left on the stack. In order to  "
               4                     " get a proper exit from PHOTO, we have to leave at least "
               4                     " one particle on the stack                               "
               4                  wt(np) = 0; e(np) = 0;
               4              ]
               3              return;
               3          ]
               2          ELSE [ "The pair survived, increase the weight"
               3              wt(np) = wt(np)/prob_RR;
               3          ]
               2      ]
               1  ]
               0
               0  $CHECK-STACK(np+1,'PAIR');
               0  PEIG=E(NP); "PRECISE ENERGY OF INCIDENT GAMMA"
               0  EIG=PEIG;   "ENERGY OF INCIDENT GAMMA"
               0  do_nrc_pair = .false.;
               0
               0  IF( itriplet > 0 & eig > 4*rm ) [
               1      itrip = dli_triplet*gle + bli_triplet;
               1      ftrip = a_triplet(itrip,medium)*gle + b_triplet(itrip,medium);
               1      $RANDOMSET rnno34;
               1      IF( rnno34 < ftrip ) [  " Triplet production "
               2          call sample_triplet;
               2          return;
               2      ]
               1  ]
               0
               0  IF( pair_nrc = 1 ) [  "Sample from the NRC pair cross section data base"
               1                        "(privided the energy is within the available range)"
               1      k = eig/rm;
               1      IF( k < nrcp_emax ) [
               2          do_nrc_pair = .true.;
               2          IF( k <= nrcp_emin ) [ ibin = 1; ]
               2          ELSE [
               3              abin = 1 + log((k-2)/(nrcp_emin-2))*nrcp_dlei;
               3              ibin = abin; abin = abin - ibin;
               3              $RANDOMSET rbin;
               3              IF( rbin < abin ) ibin = ibin + 1;
               3          ]
               2          xx = alias_sample1($NRC-PAIR-NX-1,nrcp_xdata,
               2                  nrcp_fdata(1,ibin,medium),nrcp_wdata(1,ibin,medium),
               2                  nrcp_idata(1,ibin,medium));
               2             " The above returns the energy fraction of the positron "
               2          IF( xx > 0.5 ) [
               3              pese1 = prm*(1 + xx*(k-2)); iq1 = 1;
               3              pese2 = peig - pese1; iq2 = -1;
               3          ]
               2          ELSE [
               3              pese2 = prm*(1 + xx*(k-2)); iq2 = 1;
               3              pese1 = peig - pese2; iq1 = -1;
               3          ]
               2      ]
               1  ]
               0
               0
               0  IF( ~do_nrc_pair ) [
               1  IF (EIG.LE.2.1) [
               2      "   BELOW 2.1,USE APPROXIMATION"
               2      $SELECT-LOW-ENERGY-PAIR-PRODICTION;
               2  ]
               1  ELSE[   "ABOVE 2.1, MUST SAMPLE"
               2
               2      "   DECIDE WHETHER TO USE BETHE-HEITLER or BH
               2      "   COULOMB CORRECTED
               2
               2      IF (EIG.LT.50.) [ "Use BH without Coulomb correction"
               3
               3          L = 5;
               3          L1 = L + 1;
               3
               3          "Find the actual rejection maximum for this photon energy"
               3          delta = 4*delcm(medium)/eig;
               3          IF( delta < 1 ) [
               4             Amax = dl1(l,medium)+delta*(dl2(l,medium)+delta*dl3(l,medium));
               4             Bmax = dl1(l1,medium)+delta*(dl2(l1,medium)+delta*dl3(l1,medium));
               4          ]
               3          ELSE [
               4             aux2 = log(delta+dl6(l,medium));
               4             Amax = dl4(l,medium)+dl5(l,medium)*aux2;
               4             Bmax = dl4(l1,medium)+dl5(l1,medium)*aux2;
               4          ]
               3          "and then calculate the probability for sampling from (br-1/2)**2"
               3          aux1 = 1 - rmt2/eig; aux1 = aux1*aux1;
               3          aux1 = aux1*Amax/3; aux1 = aux1/(Bmax+aux1);
               3      ]
               2      ELSE [
               3          "Use BH Coulomb-corrected"
               3          L = 7;
               3          "The absolute maxima are close to the actual maxima at high energies"
               3          "=>use the absolute maxima to save time"
               3          Amax = dl1(l,medium); Bmax = dl1(l+1,medium);
               3          aux1 = bpar(2,medium)*(1-bpar(1,medium)*rm/eig);
               3      ]
               2
               2      del0 = eig*delcm(medium);
               2      Eavail = eig - rmt2;
               2
               2      LOOP [
               3
               3          $RANDOMSET RNNO30; $RANDOMSET RNNO31; $RANDOMSET RNNO34;
               3          IF( rnno30 > aux1 ) [ "use the uniform part"
               4              br = 0.5*rnno31;  rejmax = Bmax; l1 = l+1;
               4          ]
               3          ELSE [  "use the (br-1/2)**2 part of the distribution"
               4              $RANDOMSET rnno32; $RANDOMSET rnno33;
               4              br = 0.5*(1-max(rnno31,rnno32,rnno33));
               4              rejmax = Amax; l1 = l;
               4          ]
               3          Eminus = br*Eavail + rm;
               3          Eplus  = eig - Eminus;
               3          delta = del0/(Eminus*Eplus);
               3          IF( delta < 1 ) [
               4             rejf = dl1(l1,medium)+delta*(dl2(l1,medium)+delta*dl3(l1,medium));
               4          ]
               3          ELSE [
               4            rejf = dl4(l1,medium)+dl5(l1,medium)*log(delta+dl6(l1,medium));
               4          ]
               3
               3      ] UNTIL ( rnno34*rejmax <= rejf );
               2
               2      pese2 = Eminus; pese1 = peig - pese2;
               2      $RANDOMSET RNNO34;
               2      IF( rnno34 < 0.5 ) [ iq1 = -1; iq2 = 1; ] ELSE [ iq1 = 1; iq2 = -1; ]
               2
               2  ]
               1  ]
               0
               0  "   ENERGY GOING TO LOWER SECONDARY HAS NOW BEEN DETERMINED"
               0  ESE2=PESE2;
               0  E(NP)=PESE1; E(NP+1)=PESE2;
               0  "   THIS AVERAGE ANGLE OF EMISSION FOR BOTH PAIR PRODUCTION AND"
               0  "   BREMSSTRAHLUNG IS MUCH SMALLER THAN THE AVERAGE ANGLE OF"
               0  "   MULTIPLE SCATTERING FOR DELTA T TRANSPORT=0.01 R.L."
               0  "   THE INITIAL AND FINAL MOMENTA ARE COPLANAR "
               0  "   SET UP A NEW 'ELECTRON'  "
               0  $SET-PAIR-ANGLE;
               0  " DEFAULT FOR $SET-PAIR-ANGLE; is to select the angle from the leading term"
               0  " of the angular distribution "
               0  CALL UPHI(1,1);
               0  "   SET UP A NEW 'ELECTRON' "
               0  NP=NP+1;
               0  SINTHE=-SINTHE;
               0  CALL UPHI(3,2);
               0
               0  IQ(NP)=iq2; IQ(NP-1)=iq1;
               0  RETURN;
               0  "END OF SUBROUTINE PAIR"    END;
               0
               0  "***************************************************************************"
               0  "                                                                           "
               0  " Sampling of triplet production events.                                    "
               0  "                                                                           "
               0  " The treatment is based on Borsellino's first Born approximation           "
               0  " result (see Eq. 4B-3002 in the pair article of Motz, Olsen & Koch)        "
               0  " As the kinematic of the process is already complicated enough and the     "
               0  " cross section itself is not simple either, a Markov-chain method is used  "
               0  " to sample triplet events from the Borsellino equation without any         "
               0  " additional approximations (other then the use of the first Born           "
               0  " approximation and the assumption of free electrons implied by             "
               0  " Borsellino's derivation)                                                  "
               0  "                                                                           "
               0  " Iwan Kawrakow, April 2005.                                                "
               0  "***************************************************************************"
               0
               0  subroutine sample_triplet;
               0
               0  "***************************************************************************"
               0  implicit none;
               0  $declare_max_medium;
               0  ;COMIN/EPCONT,STACK,MEDIA,THRESH,USEFUL,RANDOM,USER,EGS-IO/;
               0  $declare_write_buffer;
               0
               0  " We use double precision throughout as in many cases the kinematically "
               0  " permitted angular interval is too small to be resolved accurately enough "
               0  " in single precision "
               0
               0  real*8 fmax_array($MAX_TRIPLET), eta_p_array($MAX_TRIPLET),
               0         eta_Ep_array($MAX_TRIPLET), eta_costp_array($MAX_TRIPLET),
               0         eta_costm_array($MAX_TRIPLET), ebin_array($MAX_TRIPLET),
               0         wp_array($MAX_TRIPLET), qmin_array($MAX_TRIPLET);
               0
               0  real*8 kmin, kmax, dlogki, alogkm, prmi, tiny_eta;
               0
               0  real*8 ai,rnno,k,qmin,qmax,aux,a1,a2,a3,D,px1,px2,pp_min,pp_max,
               0         Ep_min,Ep_max,k2p2,k2p2x,peig,b,aux1,aux12,D1,aux3,xmin,xmax,
               0         aux6,aux7,uu,cphi,sphi,cphi_factor,aux5,phi,tmp;
               0  real*8 Er,pr,pr2,eta_pr;
               0  real*8 Ep,pp,pp2,wEp,cost_p,sint_p,eta_Ep,mup_min,wmup,
               0         eta_costp,Epp,pp_sintp,pp_sntp2;
               0  real*8 Em,pm,pm2,cost_m,sint_m,Emm,wmum,pm_sintm,
               0         eta_costm;
               0  real*8 k2,k3,s2,s3,k2k3i,k22,k32,q2,aux4,S_1,S_2,sigma;
               0  real*8 ppx, ppy, ppz, pmx, pmy, pmz, prx, pry, prz,
               0         a,c,sindel,cosdel,sinpsi;
               0
               0  $INTEGER i;
               0  $LOGICAL use_it;
               0  $INTEGER iscore; " needed for BEAM "
               0
               0  $LOGICAL is_initialized;
               0  data is_initialized/.false./;
               0  save is_initialized,fmax_array,eta_p_array,eta_Ep_array,eta_costp_array,
               0       eta_costm_array,ebin_array,wp_array,qmin_array,
               0       kmin,kmax,dlogki,alogkm,prmi,tiny_eta;
               0
               0  IF( ~is_initialized ) [
               1      is_initialized = .true.;
               1      tiny_eta = 1e-6;
               1      " Set current cross section value to -1 in each energy bin "
               1      DO i=1,$MAX_TRIPLET [ fmax_array(i) = -1; ]
               1      " Find the maximum energy of the cross section data "
               1      kmax = 0; kmin = 4.1*prm;
               1      DO i=1,nmed [ IF( up(i) > kmax ) kmax = UP(i); ]
               1      IF( kmax <= kmin ) return;
               1      dlogki = $MAX_TRIPLET - 1; dlogki = dlogki/log(kmax/kmin);
               1      alogkm = 1 - dlogki*log(kmin);
               1      prmi = 1/prm;
               1      DO i=1,$MAX_TRIPLET [
               2          k = 4.1*exp((i-1.)/dlogki); ebin_array(i) = k;
               2          qmin = 4*k/(k*(k-1)+(k+1)*sqrt(k*(k-4)));
               2          qmax = (k*(k-1) + (k+1)*sqrt(k*(k-4)))/(2*k+1);
               2          qmin_array(i) = qmin; wp_array(i) = log(qmax/qmin);
               2      ]
               1  ]
               0
               0  peig = e(np);
               0  IF( peig <= 4*prm ) return;
               0  $CHECK-STACK(np+2,'sample_triplet');
               0
               0  " Determine energy bin "
               0  IF( peig <= kmin ) [ i = 1; ]
               0  ELSE IF( peig >= kmax ) [ i = $MAX_TRIPLET; ]
               0  ELSE [
               1      ai = alogkm + dlogki*gle; i = ai; ai = ai - i;
               1      $RANDOMSET rnno;
               1      IF( rnno < ai ) [ i = i+1; ]
               1  ]
               0
               0  " First use the bin energy to sample the random numbers "
               0  " that determine recoil momentum and electron/postron angles "
               0  k = ebin_array(i);
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  :retry_triplet:;
               0
               0  " Pick the recoil electron momentum from 1/p.
               0  $RANDOMSET eta_pr; IF( eta_pr < tiny_eta ) eta_pr = tiny_eta;
               0  pr = qmin_array(i)*exp(eta_pr*wp_array(i));
               0  pr2 = pr*pr; Er = sqrt(1+pr2);
               0
               0  " Determine min./max. kinematically permitted postron energy for "
               0  " this k and p "
               0  aux = Er-pr-1; a1=(k-pr)*(1-Er-k*aux); a2=1+k-Er; a3=1/(aux*(pr+Er-2*k-1));
               0  D = a2*sqrt(aux*(2*k*Er+k*k*aux-pr*(Er+pr+1)/2));
               0  px1 = (a1 + D)*a3; px2 = (a1 - D)*a3;
               0  IF( px1 < px2 ) [ pp_min = px1; pp_max = px2; ]
               0  ELSE            [ pp_min = px2; pp_max = px1; ]
               0  Ep_min = sqrt(1 + pp_min*pp_min); Ep_max = sqrt(1 + pp_max*pp_max);
               0
               0  " Pick the positron energy "
               0  $RANDOMSET eta_Ep; IF( eta_Ep < tiny_eta ) eta_Ep = tiny_eta;
               0  wEp = Ep_max - Ep_min; Ep = Ep_min + eta_Ep*wEp;
               0  pp2 = Ep*Ep - 1; pp = sqrt(pp2); k2p2 = k*k + pp2;
               0
               0  " Now we can determine the pair electron energy from energy conservation "
               0  Em = k + 1 - Er - Ep;
               0  pm2 = Em*Em-1; pm = sqrt(pm2);
               0
               0  " The minimum cosine of the positron angle follows from the kinematics. "
               0  mup_min = (k2p2 - (pr + pm)*(pr + pm))/(2*k*pp);
               0
               0  " Now pick the positron direction from 1/(Ep-pp*cost_p) "
               0  $RANDOMSET eta_costp; IF( eta_costp < tiny_eta ) eta_costp = tiny_eta;
               0  Epp = Ep/pp; wmup = log((Epp-1)/(Epp-mup_min));
               0  cost_p = Epp - (Epp - mup_min)*exp(wmup*eta_costp);
               0  wmup = wmup*(cost_p - Epp);
               0  sint_p = 1-cost_p*cost_p;
               0  IF( sint_p > 1e-20 ) [ sint_p = sqrt(sint_p); ] ELSE [ sint_p = 1e-10; ]
               0  k2p2x = k2p2 - 2*k*pp*cost_p;
               0
               0  " The minimum amd maximum cosine of the pair electron angle follows from "
               0  " the kinematics "
               0  b = pr2-k2p2x-pm2; aux1 = k - pp*cost_p; aux12 = aux1*aux1;
               0  pp_sintp = pp*sint_p; pp_sntp2 = pp_sintp*pp_sintp;
               0  D1 = pm2*(aux12+pp_sntp2)-b*b/4;
               0  if( D1 <= 0 ) [ goto :retry_triplet:; ]
               0  D = 2*pp_sintp*sqrt(D1);
               0  aux3 = 0.5/(aux12+pp_sntp2);
               0  xmin = (-b*aux1-D)*aux3; xmax = (-b*aux1+D)*aux3;
               0
               0  " Now pick the electron direction from "
               0  "  1/(Em-pm*cost_m)/sqrt((cost_m_max-cost_m)*(cost_m-cost_m_min)) "
               0  " We have to take into account the "
               0  " 1/sqrt((cost_m_max-cost_m)*(cost_m-cost_m_min)) factor in the sampling "
               0  " otherwise we end up with 1/sqrt() singularities near the ends of the "
               0  " allowed cost_m range                                                 "
               0  $RANDOMSET eta_costm; IF( eta_costm < tiny_eta ) eta_costm = tiny_eta;
               0  aux6 = sqrt((Em-xmin)/(Em-xmax));
               0  aux7 = aux6*tan(1.570796326794897*eta_costm);
               0  uu = (aux7-1)/(aux7+1);
               0  cost_m = 0.5*(xmax + xmin + 2*uu*(xmax-xmin)/(1+uu*uu));
               0  wmum = sqrt((xmax-cost_m)*(cost_m-xmin));
               0  wmum = wmum*aux6*(Em-cost_m)/(Em-xmin);
               0  cost_m = cost_m/pm;
               0  sint_m = sqrt(1-cost_m*cost_m); pm_sintm = pm*sint_m;
               0
               0  " Now we have selected all independent kinematic variables. "
               0  " Determine the azimuthal angle between the pair electrons "
               0  cphi = (b + 2*pm*cost_m*aux1)/(2*pp_sintp*pm_sintm);
               0  IF( abs(cphi) >= 1 ) [ goto :retry_triplet:; ]
               0  sphi = sqrt(1-cphi*cphi);
               0
               0  " And now evaluate the Borsellino cross section "
               0  k3 = k*(pp*cost_p - Ep); k2 = k*(pm*cost_m - Em);
               0  k22 = k2*k2; k32 = k3*k3; k2k3i = 1/(k2*k3);
               0  s2 = pp*pm*(cost_p*cost_m + sint_p*sint_m*cphi) - Ep*Em;
               0  s3 = k2 - Em + 1 - s2; q2 = 2*(Er-1);
               0  S_1 = k32+k22+(q2-2)*s2-(1-q2/2)*(k32+k22)*k2k3i;
               0  aux4 = k3*Ep-k2*Em;
               0  S_2 = -q2*(Ep*Ep+Em*Em) + 2*s2 - (2*aux4*aux4 - k22 - k32)*k2k3i;
               0  sigma = abs(pp*pm2*pm*k2k3i/(q2*q2*(Em*s3+Er))*(S_1*(1-q2/4)+S_2*(1+q2/4)));
               0
               0  " We get the following factor due to the transformation from phi to "
               0  " the recoil momentum pr "
               0  cphi_factor = abs(2*Er*pm2-Em*(k2p2x-pr2-pm2))/(2*pp_sintp*pm_sintm*pm2*sphi);
               0
               0  " We have to also multiply by the various factors from the sampling of "
               0  " pr, Ep, cost_p and cost_m "
               0  sigma = sigma*cphi_factor*wEp*wmup*wmum*wp_array(i)*pr2/Er;
               0  IF( sigma < 0 ) [
               1      $egs_warning(*,'In triplet sigma < 0 ? ',sigma);
               1  ]
               0
               0  " Now determine if we accept this new event "
               0  use_it = .true.;
               0  IF( sigma < fmax_array(i) ) [
               1      $RANDOMSET rnno;
               1      IF( sigma < fmax_array(i)*rnno ) [ use_it = .false. ]
               1  ]
               0  IF( use_it ) [       " Yes, event accepted "
               1      fmax_array(i) = sigma;
               1      eta_p_array(i) = eta_pr; eta_Ep_array(i) = eta_Ep;
               1      eta_costp_array(i) = eta_costp; eta_costm_array(i) = eta_costm;
               1  ] ELSE [             " Nop, event rejected => use last accepted "
               1      eta_pr = eta_p_array(i); eta_Ep = eta_Ep_array(i);
               1      eta_costp = eta_costp_array(i); eta_costm = eta_costm_array(i);
               1  ]
               0
               0  " We now have a set of random number accepted for sampling around "
               0  " the i'th bin energy. We need to recalculate all variables using "
               0  " the actual photon energy "
               0
               0  k = peig*prmi;
               0  aux5 = k*(k-1)+(k+1)*sqrt(k*(k-4));
               0  qmin = 4*k/aux5; qmax = aux5/(2*k+1);
               0  pr = qmin*exp(eta_pr*log(qmax/qmin));
               0  pr2 = pr*pr; Er = sqrt(1+pr2);
               0
               0  aux = Er-pr-1; a1=(k-pr)*(1-Er-k*aux); a2=1+k-Er; a3=1/(aux*(pr+Er-2*k-1));
               0  D = a2*sqrt(aux*(2*k*Er+k*k*aux-pr*(Er+pr+1)/2));
               0  px1 = (a1 + D)*a3; px2 = (a1 - D)*a3;
               0  IF( px1 < px2 ) [ pp_min = px1; pp_max = px2; ]
               0  ELSE            [ pp_min = px2; pp_max = px1; ]
               0  Ep_min = sqrt(1 + pp_min*pp_min); Ep_max = sqrt(1 + pp_max*pp_max);
               0
               0  wEp = Ep_max - Ep_min; Ep = Ep_min + eta_Ep*wEp;
               0  pp2 = Ep*Ep - 1; pp = sqrt(pp2); k2p2 = k*k + pp2;
               0  Em = k + 1 - Er - Ep;
               0  pm2 = Em*Em-1; pm = sqrt(pm2);
               0
               0  mup_min = (k2p2 - (pr + pm)*(pr + pm))/(2*k*pp);
               0  Epp = Ep/pp; wmup = log((Epp-1)/(Epp-mup_min));
               0  cost_p = Epp - (Epp - mup_min)*exp(wmup*eta_costp);
               0  sint_p = sqrt(1-cost_p*cost_p);
               0  k2p2x = k2p2 - 2*k*pp*cost_p;
               0
               0  b = pr2-k2p2x-pm2; aux1 = k - pp*cost_p; aux12 = aux1*aux1;
               0  pp_sintp = pp*sint_p; pp_sntp2 = pp_sintp*pp_sintp;
               0  D1 = pm2*(aux12+pp_sntp2)-b*b/4;
               0  if( D1 <= 0 ) [ goto :retry_triplet:; ]
               0  D = 2*pp_sintp*sqrt(D1);
               0  aux3 = 0.5/(aux12+pp_sntp2);
               0  xmin = (-b*aux1-D)*aux3; xmax = (-b*aux1+D)*aux3;
               0  aux6 = sqrt((Em-xmin)/(Em-xmax));
               0  aux7 = aux6*tan(1.570796326794897*eta_costm);
               0  uu = (aux7-1)/(aux7+1);
               0  cost_m = 0.5*(xmax + xmin + 2*uu*(xmax-xmin)/(1+uu*uu))/pm;
               0  sint_m = sqrt(1-cost_m*cost_m); pm_sintm = pm*sint_m;
               0
               0  cphi = (b + 2*pm*cost_m*aux1)/(2*pp_sintp*pm_sintm);
               0  IF( abs(cphi) >= 1 ) [ goto :retry_triplet:; ]
               0  sphi = sqrt(1-cphi*cphi);
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  $RANDOMSET phi; phi = phi*6.283185307179586;
               0  ppx = pp*sint_p; ppy = 0;
               0  pmx = pm*sint_m*cphi; pmy = pm*sint_m*sphi;
               0  cphi = cos(phi); sphi = sin(phi);
               0  tmp = ppx*sphi; ppx = ppx*cphi - ppy*sphi; ppy = tmp + ppy*cphi;
               0  tmp = pmx*sphi; pmx = pmx*cphi - pmy*sphi; pmy = tmp + pmy*cphi;
               0  ppz = pp*cost_p; pmz = pm*cost_m;
               0  prx = -ppx-pmx; pry = -ppy-pmy; prz = k - ppz - pmz;
               0  " Set up particles on the stack ";
               0  " We always put the recoil electron on top (even if its energy is higher "
               0  " then the energies of the pair particles) because                       "
               0  "   - that way, we know which particle is the recoil  electron in case   "
               0  "     we want to score some quantity related to it                       "
               0  "   - its energy is, on average, lower than the pair particle energies   "
               0  NPold = np;
               0  $TRANSFER PROPERTIES TO (np)   FROM (np);
               0  $TRANSFER PROPERTIES TO (np+1) FROM (np);
               0  $TRANSFER PROPERTIES TO (np+2) FROM (np+1);
               0  pp = 1/pp; pm = 1/pm; pr = 1/pr;
               0  a = u(np); b = v(np); c = w(np); sinpsi = a*a + b*b;
               0  IF( sinpsi > 1e-20 ) [
               1      sinpsi = sqrt(sinpsi); sindel = b/sinpsi; cosdel = a/sinpsi;
               1      IF( Ep > Em ) [
               2          u(np)   = pp*(c*cosdel*ppx - sindel*ppy + a*ppz);
               2          v(np)   = pp*(c*sindel*ppx + cosdel*ppy + b*ppz);
               2          w(np)   = pp*(c*ppz - sinpsi*ppx); iq(np) = 1; E(np) = Ep*prm;
               2          u(np+1) = pm*(c*cosdel*pmx - sindel*pmy + a*pmz);
               2          v(np+1) = pm*(c*sindel*pmx + cosdel*pmy + b*pmz);
               2          w(np+1) = pm*(c*pmz - sinpsi*pmx); iq(np+1) = -1; E(np+1) = Em*prm;
               2      ]
               1      ELSE [
               2          u(np+1) = pp*(c*cosdel*ppx - sindel*ppy + a*ppz);
               2          v(np+1) = pp*(c*sindel*ppx + cosdel*ppy + b*ppz);
               2          w(np+1) = pp*(c*ppz - sinpsi*ppx); iq(np+1) = 1; E(np+1) = Ep*prm;
               2          u(np)   = pm*(c*cosdel*pmx - sindel*pmy + a*pmz);
               2          v(np)   = pm*(c*sindel*pmx + cosdel*pmy + b*pmz);
               2          w(np)   = pm*(c*pmz - sinpsi*pmx); iq(np) = -1; E(np) = Em*prm;
               2      ]
               1      np = np + 2;
               1      u(np)   = pr*(c*cosdel*prx - sindel*pry + a*prz);
               1      v(np)   = pr*(c*sindel*prx + cosdel*pry + b*prz);
               1      w(np)   = pr*(c*prz - sinpsi*prx); iq(np) = -1; E(np) = Er*prm;
               1  ] ELSE [
               1      IF( Ep > Em ) [
               2          u(np) = pp*ppx; v(np) = pp*ppy; w(np) = c*pp*ppz;
               2          iq(np) = 1; E(np) = Ep*prm;
               2          u(np+1) = pm*pmx; v(np+1) = pm*pmy; w(np+1) = c*pm*pmz;
               2          iq(np+1) = -1; E(np+1) = Em*prm;
               2      ]
               1      ELSE [
               2          u(np+1) = pp*ppx; v(np+1) = pp*ppy; w(np+1) = c*pp*ppz;
               2          iq(np+1) = 1; E(np+1) = Ep*prm;
               2          u(np) = pm*pmx; v(np) = pm*pmy; w(np) = c*pm*pmz;
               2          iq(np) = -1; E(np) = Em*prm;
               2      ]
               1      np = np + 2;
               1      u(np) = pr*prx; v(np) = pr*pry; w(np) = c*pr*prz;
               1      iq(np) = -1; E(np) = Er*prm;
               1  ]
               0
               0  return; end;
               0
1              0  %E
               0  "******************************************************************"
               0  SUBROUTINE PHOTO;
               0  "******************************************************************"
               0  " Programmers:  I. Kawrakow, complete recoding,                    "
               0  "                            Fluorescent X-rays, Auger,            "
               0  "                            Coster-Kronig treated in RELAX        "
               0  "               A.F. Bielajew (NRC) photoelectric angular distn    "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-PHOTO; "default replacement is:
               0                "COMIN/BOUNDS,DEBUG,EDGE,EGS-VARIANCE-REDUCTION,EPCONT,"
               0                    "MEDIA,PHOTIN,RANDOM,STACK,UPHIOT,USEFUL/"
               0
               0  $DEFINE-VARIABLES-FOR-SELECT-PHOTOELECTRON-DIRECTION;
               0  $DEFINE-LOCAL-VARIABLES-PHOTO;
               0
               0  data n_warning/0/;
               0
               0  IF ( mcdf_pe_xsections )[call egs_shellwise_photo();return;]
               0
               0  NPold = NP;      "Set the old stack counter"
               0  PEIG=E(NP); irl = ir(np);
               0  IF( peig < edge_energies(2,1) ) [
               1      IF( n_warning < 100 ) [
               2          n_warning = n_warning + 1;
               2          $egs_info(*,' Subroutine PHOTO called with E = ',peig,
               2                     ' which is below the current min. energy of 1 keV! ');
               2          $egs_info(*,' Converting now this photon to an electron, ');
               2          $egs_info(*,' but you should check your code! ');
               2      ]
               1      iq(np) = -1;
               1      e(np) = peig + prm;
               1      return;
               1  ]
               0
               0  iZ = iedgfl(irl);
               0  do_relax = .false.;
               0  edep = pzero;
               0  IF( iedgfl(irl) ~= 0 ) [   " User requested atomic relaxations "
               1                             " first sample the element "
               1      IF( nne(medium) = 1 ) [
               2          iZ = int( zelem(medium,1) + 0.5 );
               2          DO j=1,edge_number(iZ) [
               3              IF( peig >= edge_energies(j,iZ) ) EXIT;
               3          ]
               2      ]
               1      ELSE [
               2          aux = peig*peig; aux1 = aux*peig; aux = aux*Sqrt(peig);
               2          sigtot = 0;
               2          DO k=1,nne(medium) [
               3              iZ = int( zelem(medium,k) + 0.5 );
               3              IF( iZ < 1 | iZ > $MXELEMENT ) [
               4                  $egs_info(*,' Error in PHOTO: ');
               4                  $egs_fatal(*,'   Atomic number of element ',k,
               4                     ' in medium ',medium,' is not between 1 and ',$MXELEMENT);
               4              ]
               3              IF( peig > edge_energies(1,iZ) ) [
               4                  j = 1;
               4                  sigma = (edge_a(1,iZ) + edge_b(1,iZ)/peig +
               4                       edge_c(1,iZ)/aux + edge_d(1,iZ)/aux1)/peig;
               4              ]
               3              ELSE [
               4                  DO j=2,edge_number(iZ) [
               5                      IF( peig >= edge_energies(j,iZ) ) EXIT;
               5                  ]
               4                  sigma = edge_a(j,iZ) + gle*(edge_b(j,iZ) + gle*(edge_c(j,iZ) +
               4                          gle*edge_d(j,iZ) ));
               4                  sigma = Exp(sigma);
               4              ]
               3              sigma = sigma * pz(medium,k);
               3              sigtot = sigtot + sigma;
               3              probs(k) = sigma;
               3              ints(k) = j;
               3          ]
               2          $RANDOMSET br; br = br*sigtot;
               2          DO k=1,nne(medium) [
               3              br = br - probs(k);
               3              IF( br <= 0 ) EXIT;
               3          ]
               2          iZ = int( zelem(medium,k) + 0.5 );
               2          j  = ints(k);
               2      ]
               1      " Now we know the atomic number (iZ) and the energy interval the "
               1      " photon energy is in (j). It is time to sample the shell the photon "
               1      " is interacting with. "
               1      " left for now as before, to be changed!!! "
               1      IF( peig <= binding_energies($MXSHELL,iZ) )
               1      [   "Outer shells, no atomic relaxation"
               2             "EADL relax: Below  M2-shell -> just emit e- "
               2             iq(np) = -1;
               2             e(np) = peig + prm;
               2      ]
               1      ELSE ["Above  N-shell -> sample the shell the photon is interacting with"
               2          $RANDOMSET br;
               2          DO k=1,$MXINTER [
               3              IF( peig > binding_energies(k,iZ) ) [
               4                  IF( br < interaction_prob(k,iZ) ) EXIT;
               4                  br = (br - interaction_prob(k,iZ))/(1-interaction_prob(k,iZ));
               4              ]
               3          ]
               2          "Interaction possible with any shell from k=1 to $MXSHELL"
               2          "Defaults to $MXSHELL interaction if DO loop completes"
               2          "****************"
               2          "EADL APPROACH 1: Do not allow interaction below L3. Deviates"
               2          "**************** from previous EGSnrc approach as it doesn't"
               2          "                 generate e- nor x-rays from <M> and <N> shells."
               2          IF (eadl_relax & k > 4)[
               3             "No initial vacancy below L3 for now, just emit e-"
               3             iq(np) = -1;
               3             e(np) = peig + prm;
               3          ]
               2          ELSE["EADL:    Interacts with K,L1..L3 shells"
               3               "default: Interacts with K,L1..L3,<M>, and <N> shells"
               3             e_vac = binding_energies(k,iZ);
               3             e(np) = peig - e_vac + prm; do_relax = .true.;
               3             iq(np) = -1;
               3          ]
               2      ]
               1  ]
               0  ELSE [
               1      e(np) = peig + prm; iq(np) = -1;
               1  ]
               0
               0  IF( iq(np) = -1 ) [
               1      $SELECT-PHOTOELECTRON-DIRECTION; "Samples photo-electron direction"
               1  ]
               0
               0  "****************"
               0  "EADL APPROACH 2: PE interactions with K, L1...L3,<M> and <N> shells,"
               0  "**************** but vacancies below L3 deposit energy locally. It wont"
               0  "                 produce x-rays from <M> and <N> shells."
               0  "IF ($EADL_RELAX & k > 4)[
               0  "   edep = e_vac; do_relax = .false.;
               0  "]
               0  IF( do_relax ) [
               1      call relax(e_vac,k,iZ);
               1  ]
               0
               0  IF( EDEP > 0 ) [ $AUSCALL($PHOTXAUS); ]    "generates IARG = 4 call"
               0
               0  ;
               0  $PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold; " TO NP;"
               0
               0  return;
               0  end;
               0
1              0  %E
               0  "******************************************************************"
               0  subroutine egs_shellwise_photo;
               0  "******************************************************************"
               0  " Derived from PHOTO by I. Kawrakow and A.F. Bielajew              "
               0  " Shellwise implementation and      "
               0  "                                sampling optimizations            "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-PHOTO; "default replacement is:
               0                "COMIN/BOUNDS,DEBUG,EDGE,EGS-VARIANCE-REDUCTION,EPCONT,"
               0                    "MEDIA,PHOTIN,RANDOM,STACK,UPHIOT,USEFUL/"
               0  ;COMIN/PE-SHELL-DATA/;
               0
               0  $DEFINE-VARIABLES-FOR-SELECT-PHOTOELECTRON-DIRECTION;
               0  $DEFINE-LOCAL-VARIABLES-PHOTO;
               0  $REAL slope, logE, int_prob;
               0  $INTEGER zpos, ibsearch;
               0  data n_warning/0/;
               0
               0  NPold = NP;      "Set the old stack counter"
               0  PEIG=E(NP); irl = ir(np);
               0  do_relax = .false.;
               0  IF( peig < $RELAX-CUTOFF ) [
               1      IF( n_warning < 100 ) [
               2          n_warning = n_warning + 1;
               2          $egs_info(*,' Subroutine egs_shellwise_photo called with E = ',
               2                      peig,' which is below the current min. energy of ',
               2                     $RELAX-CUTOFF,' keV! ');
               2          $egs_info(*,' Converting now this photon to an electron, ');
               2          $egs_info(*,' but you should check your code! ');
               2      ]
               1      iq(np) = -1;
               1      e(np) = peig + prm;
               1      return;
               1  ]
               0
               0  edep = pzero;
               0
               0  IF( iedgfl(irl) ~= 0 ) [" User requested atomic relaxations "
               1                          " sample element and atomic shell for"
               1     j = -1;              " the interaction."
               1     IF( nne(medium) = 1 ) [
               2      iZ = int( zelem(medium,1) + 0.5 ); zpos = pe_zpos(iZ);
               2      IF( pe_nshell(zpos) > 0) [
               3        logE = log(peig);
               3        j = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos));
               3      ]
               2     ]
               1     ELSE [
               2        $RANDOMSET br; logE = log(peig);
               2        "DO k=1,nne(medium) ["
               2        DO k=nne(medium),1,-1 [
               3            iZ = int( zelem(medium,k) + 0.5 );zpos = pe_zpos(iZ);
               3            IF( iZ < 1 | iZ > $MXELEMENT ) [
               4                $egs_info(*,' Error in egs_shellwise_photo: ');
               4                $egs_fatal(*,'   Atomic number of element ',k,
               4                   ' in medium ',medium,' is not between 1 and ',$MXELEMENT);
               4            ]
               3            j = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos));
               3            slope    = pe_elem_prob(j+1,k,medium) - pe_elem_prob(j,k,medium);
               3            slope    = slope/(pe_energy(j+1,zpos)-pe_energy(j,zpos));
               3            int_prob = pe_elem_prob(j,k,medium)+slope*(logE-pe_energy(j,zpos));
               3            br -= exp(int_prob);
               3            IF ( br <= 0 ) EXIT;
               3        ]
               2     ]
               1     " Now we know the atomic number (iZ) and the energy interval the "
               1     " photon energy is in (j). It is time to sample the shell the photon "
               1     " is interacting with. "
               1     IF( peig < pe_be(zpos,pe_nshell(zpos)) | pe_nshell(zpos) = 0 )
               1     [   "no atomic relaxation, create photo-electron"
               2           iq(np) = -1;
               2           e(np) = peig + prm;
               2     ]
               1     ELSE ["sample the shell the photon is interacting with"
               2        $RANDOMSET br; sigtot = 0;
               2        DO k=1,pe_nshell(zpos) [
               3            IF( peig > pe_be(zpos,k) ) [
               4              slope = pe_xsection(j+1,zpos,k) - pe_xsection(j,zpos,k);
               4              slope = slope/(pe_energy(j+1,zpos)-pe_energy(j,zpos));
               4              int_prob=pe_xsection(j,zpos,k)+slope*(logE-pe_energy(j,zpos));
               4              br -= exp(int_prob); sigtot += exp(int_prob);
               4              IF ( br <= 0 ) EXIT;
               4            ]
               3        ]
               2        IF (k > pe_nshell(zpos))["outer shell, create photo-electron"
               3           iq(np) = -1;
               3           e(np) = peig + prm;
               3        ]
               2        ELSE[
               3           e_vac = pe_be(zpos,k);
               3           e(np) = peig - e_vac + prm; do_relax = .true.;
               3           iq(np) = -1;
               3        ]
               2     ]
               1  ]
               0  ELSE ["No atomic relaxations, just create photo-electron"
               1      e(np) = peig + prm; iq(np) = -1;
               1  ]
               0
               0  IF( iq(np) = -1 ) [
               1      $SELECT-PHOTOELECTRON-DIRECTION; "Samples photo-electron direction"
               1  ]
               0
               0  IF( do_relax ) [
               1      call egs_eadl_relax(iZ,k);
               1  ]
               0
               0  IF( EDEP > 0 ) [ $AUSCALL($PHOTXAUS); ]    "generates IARG = 4 call"
               0
               0  ;
               0  $PLAY RUSSIAN ROULETTE WITH ELECTRONS FROM NPold; " TO NP;"
               0
               0  return;
               0  end;
               0
               0  "*************************************************************************"
               0  subroutine egs_read_shellwise_pe;
               0  "*************************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $declare_max_medium;
               0  $COMIN-SHELLWISE-PE-INIT;
               0
               0  $INTEGER   lnblnk1,egs_get_unit,pe_sw_unit,ounit,egs_open_file;
               0  $INTEGER   sorted($MXELEMENT),i,j,k,l,m;
               0  $REAL      z_sorted($MXELEMENT),pz_sorted($MXELEMENT);
               0  $REAL      rest_xs($MXNE,$MXELEMENT);
               0  $REAL      tmp_e($MXNE,$MXPESHELL), tmp_xs($MXNE,$MXPESHELL);
               0  $REAL      new_e($MXNE),deltaEb,slope;
               0  $INTEGER   zread($MXELEMENT),ib($MXPESHELL),ibsearch;
               0  character  data_dir*128,pe_sw_file*144;
               0
               0  $INTEGER  medio,iZ,iZpos,egs_read_int,pos,curr_rec;
               0  real*4    egs_read_real,e_r, e_old,sigma_r;
               0  integer*2 nz, egs_read_short,ish, i_nshell,i_nge;
               0  $LOGICAL  is_open, is_there, shift_required;
               0
               0  character*3 labels(16);
               0  data labels/'  K',' L1',' L2',' L3',
               0              ' M1',' M2',' M3',' M4',' M5',
               0              ' N1',' N2',' N3',' N4',' N5',' N6',' N7'/;
               0
               0
               0
               0
               0  $egs_info('(/a$)',
               0  ' Reading renormalized photoelectric cross sections ......');
               0  data_dir = $cstring(hen_house) // 'data' // $file_sep;
               0  pe_sw_file = $cstring(data_dir) // 'photo_shellwise.data';
               0
               0
               0  pe_sw_unit = egs_get_unit(0);
               0  IF( pe_sw_unit < 1 ) [
               1    $egs_fatal(*,'egs_init_shellwise_pe: failed to get a free Fortran I/O unit');
               1  ]
               0  open(pe_sw_unit,file=pe_sw_file,status='old',
               0       form='UNFORMATTED',ACCESS='direct',recl=1,
               0       err=:no-pe-sw-file:);
               0  GOTO :read-pe-sw:;
               0  :no-pe-sw-file:
               0  $egs_fatal('(2a)','egs_init_shellwise_pe: failed to open ',
               0             pe_sw_file);
               0  :read-pe-sw:
               0  is_open = .true.;
               0
               0
               0
               0  DO medio = 1,nmed [
               1     DO i=1,nne(medio) [
               2        pe_nshell(i*medio) = 0;
               2        pe_nge(i*medio) = 0;
               2        pe_zsorted(i,medio) = 0;
               2     ]
               1  ]
               0  DO l = 1,$MXELEMENT [
               1     pe_zpos(l) = -1;
               1     DO k = 1,$MXNE [
               2        pe_energy(k,l) = 0.0;
               2        DO m = 1,$MXPESHELL [
               3           pe_xsection(k,l,m) = 0.0;
               3        ]
               2     ]
               1     DO k = 1,$MXPESHELL [
               2        pe_be(l,k) = -99;
               2     ]
               1  ]
               0
               0
               0
               0
               0  curr_rec = 1; iZpos = 0;
               0  nz = egs_read_short(pe_sw_unit,curr_rec);
               0  "$egs_info('(a,i2,a)','PE shellwise data available for ',nz,' elements....');"
               0  DO medio = 1,nmed [
               1     DO i=1,nne(medio) [z_sorted(i) = zelem(medio,i);]
               1     call egs_heap_sort(nne(medio),z_sorted,sorted);
               1     DO i=1,nne(medio) [pe_zsorted(i,medio) = z_sorted(i);]
               1     DO i=1,nne(medio) [
               2        iZ = z_sorted(i);
               2        "Now check whether we have already loaded the data for"
               2        "this atomic number"
               2        is_there = .false.;
               2        DO j = 1,medio-1 [
               3           DO k = 1, nne(j)[
               4             IF( iZ = pe_zsorted(k,j) ) [
               5                 is_there = .true.; EXIT;
               5             ]
               4           ]
               3        ]
               2        IF (is_there) NEXT;
               2        "Read data for this element"
               2        iZpos += 1; zread(iZpos) = iZ;
               2        pe_zpos(iZ) = iZpos;
               2        pos         = 3 + (iZ-1)*4;
               2        curr_rec    = egs_read_int(pe_sw_unit,pos) + 1;
               2        i_nge       = egs_read_short(pe_sw_unit,curr_rec);
               2        i_nshell    = egs_read_short(pe_sw_unit,curr_rec);
               2        "$egs_info('(a,i2,a,i3,a,i2,a)','Element ',iZ,' has ',i_nge,
               2        "  ' energy points and ',i_nshell,' shells');
               2        pe_nge(iZpos) = i_nge; pe_nshell(iZpos) = i_nshell;
               2        e_old = -1.0; ish = 0;
               2        DO j = 1,i_nge[
               3           e_r = egs_read_real(pe_sw_unit,curr_rec);
               3           sigma_r = egs_read_real(pe_sw_unit,curr_rec);
               3           pe_energy(j,iZpos) = e_r;
               3           pe_xsection(j,iZpos,0) = sigma_r;
               3           rest_xs(j,iZpos) = sigma_r;
               3           DO k = 1, i_nshell[
               4              sigma_r =  egs_read_real(pe_sw_unit,curr_rec);
               4              pe_xsection(j,iZpos,k) = sigma_r;
               4              rest_xs(j,iZpos) = rest_xs(j,iZpos) - sigma_r;
               4
               4           ]
               3           "Extract binding energies from the data base"
               3           IF (e_r - e_old < 1e-15)[
               4              pe_be(iZpos,i_nshell-ish) = e_r;
               4              ish += 1;
               4           ]
               3           e_old = e_r;
               3
               3        ]
               2        "DO k = 1, i_nshell[
               2        "   $egs_info('(a2,a3,a2,1pe12.4,a4)',
               2        "             'E(',labels(k),')=',pe_be(iZpos,k),' MeV');
               2        "]
               2
               2     ]
               1  ]
               0  pe_ne = iZpos;
               0  "$egs_info('(a,i2,a/)','Finished processing ',iZpos,' elements!');
               0
               0
               0
               0
               0
               0
               0  "$egs_info(*,' Adjusting cross sections to new binding energies ...');
               0  DO i=1,pe_ne[
               1     iZ = zread(i);
               1     IF (pe_nshell(i) = 0)[
               2        DO j=1,pe_nge(i)[
               3           pe_energy(j,i) =  log(pe_energy(j,i));
               3        ]
               2        NEXT;
               2     ]
               1     "Shift energy scale for different binding energy sets"
               1     DO l=1,pe_nshell(i)[
               2        IF ( pe_be(i,l) ~= binding_energies(l,iZ))[
               3             shift_required = .true.;
               3             deltaEb = binding_energies(l,iZ)-pe_be(i,l);
               3             "$egs_info('(2(a,a,a,1pe12.4),a,1pe12.4,a,e12.4)',
               3             "           'Eb_p_',labels(l),' = ',pe_be(i,l),
               3             "          ' Eb_e_',labels(l),' = ',binding_energies(l,iZ),
               3             "          ' diff = ',pe_be(i,l)-binding_energies(l,iZ),
               3             "          ' -> ', 100*(1.0 - binding_energies(l,iZ) / pe_be(i,l))
               3             "          );
               3        ]
               2        ELSE[shift_required =.false.;]
               2        is_there = .false.;
               2        DO j=1,pe_nge(i)[
               3           tmp_e(j,l)  = pe_energy(j,i);
               3           tmp_xs(j,l) = pe_xsection(j,i,l);
               3           IF ( shift_required &
               3                pe_energy(j,i) => pe_be(i,l) )[
               4              tmp_e(j,l) += deltaEb;
               4              "$egs_info(*,'Shifting ',pe_energy(j,i),' to ',tmp_e(j,l));
               4              "Determine edge position in energy array"
               4              IF (pe_energy(j,i) = pe_be(i,l) & ~is_there)[
               5                 ib(l) = j; is_there = .true.;
               5              ]
               4              "Update new energy grid"
               4              IF (l = 1)[
               5                 new_e(j) = tmp_e(j,l);
               5              ]
               4              "ELSE IF(tmp_e(j,l) < binding_energies(l-1,iZ))[
               4              ELSE IF(j < ib(l-1))[
               5                 new_e(j) = tmp_e(j,l);
               5              ]
               4           ]
               3        ]
               2        pe_be(i,l) = binding_energies(l,iZ);
               2     ]
               1     "Re-compute sub-shell xsections for new energy grid new_e"
               1     "Not needed for K shell"
               1     DO l=2,pe_nshell(i)[
               2        DO j=1,pe_nge(i)[
               3           IF ( new_e(j) >= pe_be(i,l-1) )[
               4              m = ibsearch(new_e(j),pe_nge(i),tmp_e(1,l));
               4              slope = log(tmp_xs(m+1,l)/tmp_xs(m,l));
               4              slope = slope/log(tmp_e(m+1,l)/tmp_e(m,l));
               4              pe_xsection(j,i,l) = log(tmp_xs(m,l));
               4              pe_xsection(j,i,l) += slope*log(new_e(j)/tmp_e(m,l));
               4              pe_xsection(j,i,l) = exp(pe_xsection(j,i,l));
               4           ]
               3        ]
               2     ]
               1     "Re-compute total xsections for new energy grid new_e"
               1     "$egs_info(*,'-> Z = ',iZ);"
               1     DO j=1,pe_nge(i)[
               2        IF ( j < ib(pe_nshell(i)))[
               3           new_e(j) = pe_energy(j,i);
               3        ]
               2        m = ibsearch(new_e(j),pe_nge(i),pe_energy(1,i));
               2        slope = log(rest_xs(m+1,i)/rest_xs(m,i));
               2        slope = slope/log(pe_energy(m+1,i)/pe_energy(m,i));
               2        pe_xsection(j,i,0)  = log(rest_xs(m,i));
               2        pe_xsection(j,i,0) += slope*log(new_e(j)/pe_energy(m,i));
               2        pe_xsection(j,i,0) = exp(pe_xsection(j,i,0));
               2        "$egs_info('(1pe12.4,1x,1pe12.4,1x,1pe12.4,1x,1pe12.4)',
               2        "         new_e(j),pe_xsection(j,i,0),pe_energy(j,i),rest_xs(j,i));
               2        DO l=1,pe_nshell(i)[
               3           pe_xsection(j,i,0) += pe_xsection(j,i,l);
               3        ]
               2        "$egs_info('(1pe12.4,1x,1pe12.4,1x,1pe12.4)',
               2        "         new_e(j),pe_xsection(j,i,0));
               2     ]
               1     "Normalize shell cross sections to total for sampling"
               1     "and update energy grid of ith element."
               1     " Prepare for log/log interpolation."
               1     DO j=1,pe_nge(i)[
               2        pe_energy(j,i) =  log(new_e(j));
               2        DO l=1,pe_nshell(i)[
               3           pe_xsection(j,i,l) = log(pe_xsection(j,i,l)/pe_xsection(j,i,0));
               3        ]
               2     ]
               1  ]
               0
               0  $egs_info('(a/)',' done');
               0
               0  IF( is_open ) close(pe_sw_unit);
               0  return;
               0  end;
               0
               0
               0  "******************************************************************"
               0  SUBROUTINE RELAX(energy,n,iZ);
               0  "******************************************************************"
               0  " Subroutine to fill a vacancy in shell n, element iZ              "
               0  " by emitting fluorescent X-rays, Auger and Coster-Kronig electrons"
               0  " Transitions between K,L1,L2,L3,average M,average N are taken into"
               0  " account. Particles with energies above the transport cut-offs    "
               0  " (ECUT and PCUT) are placed on the stack, energy of sub-threshold "
               0  " particles is stored in EDEP.                                     "
               0  " In this version a global cut-off of 1 keV applies                "
               0  "  i.e. if ECUT-RM or PCUT is below 1 keV, binding energies below  "
               0  "  1 keV will still be absorbed locally (due to lack of data)      "
               0  "                                                                  "
               0  " Version 1:  I. Kawrakow, December 1998                           "
               0  "******************************************************************"
               0  implicit none;
               0
               0  " Input variables "
               0  "================="
               0  $INTEGER n,iZ;
               0  $REAL    energy;  "
               0
               0  $declare_write_buffer;
               0
               0  " Local variables "
               0  "================="
               0  REPLACE {$MXVAC} WITH {50}  "Maximum number of vacancies during the"
               0                              "relaxation cascade                    "
               0
               0  $INTEGER vac_array($MXVAC), "array with shell vacancies            "
               0           n_vac,             "current number of vacancies           "
               0           shell;             "current shell                         "
               0  $INTEGER final,finala,      "code of final state                   "
               0           final1,final2,     "two vacancies in the final state in   "
               0                              "the case of Auger transitions         "
               0           iql,               "particle charge                       "
               0           irl;               "present region"
               0  $INTEGER first_transition($MXINTER),
               0           last_transition($MXINTER);
               0                              "first and last transition for a given "
               0                              "shell in the list of all possible     "
               0                              "transitions                           "
               0  $INTEGER final_state($MXTRANS);
               0             " final_state(i) is the final atomic state                "
               0             " after transition i coded as follows:                    "
               0             "   * fluorescence - final_state is the shell number      "
               0             "                    of the new vacancy                   "
               0             "   * Coster-Kronig - final_state is the shell number     "
               0             "                     of the new vacancy + 10             "
               0             "   * Auger - final_state is n1 + 100*n2 where n1 and n2  "
               0             "             are the shell numbers of the 2 new vacancies"
               0
               0  $INTEGER k, np_old, ip, iarg;
               0  $REAL    e_array($MXVAC),   "array with vacancy energies           "
               0           Ei,Ef,             "initial,final binding energies        "
               0           Ex,                "kinetic energy of emitted particle    "
               0           eta,               "a random number                       "
               0           e_check,           "energy conservation check             "
               0           min_E,ekcut,pkcut,elcut; "cut-off energies  "
               0
               0  $REAL    xphi,yphi,xphi2,yphi2,rhophi2,
               0           cphi,sphi;         "for azimuthal angle selection"
               0
               0  " Global EGS4 variables "
               0  "======================="
               0  $COMIN-RELAX;
               0  ;COMIN/RELAX-USER/;
               0
               0  data first_transition/1,20,27,33,38/;
               0  data last_transition/19,26,32,37,39/;
               0  data final_state/ "See the final_state definition above"
               0           4,3,5,6,                           " K-shell fluorescence    "
               0           202,302,402,404,403,303,           " K-shell Auger           "
               0           502,503,504,602,603,604,           " K-shell Auger           "
               0           505,605,606,                       " K-shell Auger           "
               0           13,14,                             " L1 Coster-Kronig        "
               0           5,6,                               " L1 fluorescence         "
               0           505,605,606,                       " L1 Auger                "
               0           14,                                " L2 Coster-Kronig        "
               0           5,6,                               " L2 fluorescence         "
               0           505,605,606,                       " L2 Auger                "
               0           5,6,                               " L3 fluorescence         "
               0           505,605,606,                       " L3 Auger                "
               0           6,                                 " M  fluorescence         "
               0           606/;                              " M  Auger                "
               0
               0  save first_transition,last_transition,final_state; "to avoid problems with "
               0                                                     "non-static compiler options"
               0
               0  IF (eadl_relax)[
               1     call egs_eadl_relax(iZ,n);
               1     return;
               1  ]
               0
               0  IF( n < 1 | n > $MXSHELL ) [ return; ] "unknown vacancy"
               0
               0  iz_relax = iZ;
               0  irl = ir(np);
               0  ekcut = ecut(irl)-rm; pkcut = pcut(irl);
               0  min_E = $RELAX-CUTOFF;
               0
               0  IF( energy <= min_E ) [
               1      edep = edep + energy;  "We assume that edep is zeroed "
               1                          "(or set to the appropriate value) in the routine "
               1                          "calling RELAX "
               1      edep_local = energy;
               1
               1      "Assign this energy deposition to an electron."
               1      "Note that this should NOT be treated as though it came from a photon,"
               1      "even if a photon initiated the relaxations. Rather, energy remaining"
               1      "in vacancies should be given to an electron or absorbed locally."
               1      $AUSCALL($SELECTRONA); "call ausgab with iarg=34"
               1
               1      return;
               1  ]
               0
               0  " Set-up the array of vacancies for the relaxation cascade "
               0  n_vac = 1; vac_array(n_vac) = n; np_old = np;
               0  e_check = 0; e_array(n_vac) = energy;
               0
               0  :START: LOOP[     "Until no  >N-shell vacancies"
               1
               1      shell = vac_array(n_vac); Ei = e_array(n_vac); n_vac = n_vac - 1;
               1
               1      IF( Ei <= min_E ) [  " Below cut-off -> local absorption "
               2          edep = edep + Ei;
               2
               2          edep_local = Ei;
               2
               2          "Assign this energy deposition to an electron."
               2          "Note that this should NOT be treated as though it came from a photon,"
               2          "even if a photon initiated the relaxations. Rather, energy remaining"
               2          "in vacancies should be given to an electron or absorbed locally."
               2          $AUSCALL($SELECTRONA); "call ausgab with iarg=34"
               2
               2          IF( n_vac > 0 ) goto :START: ;
               2          EXIT;
               2      ]
               1
               1      "Set the relax_user common block variables, IK March 22 2004"
               1      ish_relax = shell; u_relax = Ei;
               1      IF( shell = $MXSHELL ) [ "This is N-shell vacancy -> just produce Auger"
               2          IF( Ei > ekcut ) [
               3              np = np + 1;
               3              $CHECK-STACK(np,'RELAX');
               3              e(np) = Ei + prm; iq(np) = -1;
               3              $TRANSFER PROPERTIES TO (np) FROM (np-1);
               3              $RANDOMSET eta; eta = 2*eta - 1; w(np) = eta;
               3              eta = (1-eta)*(1+eta);
               3              IF( eta > 1e-20 ) [
               4                  eta = Sqrt(eta);
               4                  $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               4                  u(np) = eta*cphi; v(np) = eta*sphi;
               4              ]
               3              ELSE [ u(np) = 0; v(np) = 0; w(np) = 1; ]
               3              $AUSCALL($AUGERTRA);
               3          ]
               2          ELSE             [
               3              edep = edep + Ei;
               3
               3              edep_local = Ei;
               3              $AUSCALL($SELECTRONA);
               3          ]
               2          IF( n_vac > 0 ) goto :START: ;
               2          EXIT;
               2      ]
               1      " Sample transition number for this vacancy "
               1      $RANDOMSET eta;
               1      DO k=first_transition(shell),last_transition(shell)-1 [
               2          eta = eta - relaxation_prob(k,iZ);
               2          IF( eta <= 0 ) EXIT;
               2      ]
               1      final = final_state(k); finala = final;
               1      IF( final < 100 ) [
               2          IF( final < 10 ) [ "fuorescence"
               3              iql = 0; elcut = pkcut;
               3          ]
               2          ELSE             [ "Coster-Kronig"
               3              final = final - 10;
               3              iql = -1; elcut = ekcut;
               3          ]
               2          Ef = binding_energies(final,iZ);
               2          Ex = Ei - Ef;
               2          n_vac = n_vac + 1;
               2          vac_array(n_vac) = final;
               2          e_array(n_vac) = Ef
               2      ]
               1      ELSE [  "Auger"
               2          final1 = final/100; final2 = final - final1*100;
               2          n_vac  = n_vac + 1;
               2          vac_array(n_vac) = final1;
               2          e_array(n_vac) = binding_energies(final1,iZ);
               2          n_vac  = n_vac + 1;
               2          vac_array(n_vac) = final2;
               2          e_array(n_vac) = binding_energies(final2,iZ);
               2          iql = -1;
               2          Ex = Ei - e_array(n_vac) - e_array(n_vac-1);
               2          elcut = ekcut;
               2      ]
               1      IF( Ex <= elcut ) [ "Below cut-off"
               2          edep = edep + Ex;
               2
               2          IF( finala <  10 ) [
               3              edep_local = Ex;
               3              $AUSCALL($SPHOTONA);
               3          ]
               2          ELSE [
               3              edep_local = Ex;
               3              $AUSCALL($SELECTRONA);
               3          ]
               2      ]
               1      ELSE [
               2          np = np + 1;
               2          $CHECK-STACK(np,'RELAX');
               2          iq(np) = iql;
               2          IF( iql = 0 ) [ e(np) = Ex; ] ELSE [ e(np) = Ex + rm;]
               2          $TRANSFER PROPERTIES TO (np) FROM (np-1);
               2          $RANDOMSET eta;
               2          eta = 2*eta - 1;
               2          w(np) = eta;
               2          eta = (1-eta)*(1+eta);
               2          IF( eta > 1e-20 ) [
               3              eta = Sqrt(eta);
               3              $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               3              u(np) = eta*cphi;
               3              v(np) = eta*sphi;
               3          ]
               2          ELSE [ u(np) = 0; v(np) = 0; w(np) = 1; ]
               2          IF     ( finala <  10 ) [ $AUSCALL($FLUORTRA);  ]
               2          ELSE IF( finala < 100 ) [ $AUSCALL($COSKROTRA); ]
               2          ELSE                    [ $AUSCALL($AUGERTRA);  ]
               2      ]
               1  ]
               0
               0  return;
               0  end;
               0
               0  "*************************************************************************"
               0  subroutine egs_init_relax;
               0  "*************************************************************************"
               0  " Reads EADL atomic relaxation data from $HEN_HOUSE/data/relax.data. This "
               0  " data base was originally created by I. Kawrakow to be used with C++ user"
               0  " codes. It has been re-created using 4 bytes integers instead of using   "
               0  " optimized integer sizes to save space. It is now about 34% larger (760K)"
               0  " than before (557K). Reason for this was that some compilers need a switch"
               0  " to get it to read binary files on byte at a time. This would have been a"
               0  " nuisance for users when configuring the already complex system.         "
               0  "                                                                        "
               0  " The final relaxation state from radiative transitions assumes C-style  "
               0  " array indexing and hence needs to be increased by 1.                   "
               0  " Similarly, for non-radiative transitions, there is need to increase the"
               0  " codified value of the two electron states by 65. The reason is that the"
               0  " two transition states are encoded as 64*state1+state2. Because of the C"
               0  " style indexing, state1 and state2 must be increased by 1, increasing the"
               0  " above codified value by 65.                                            "
               0  "                                                                        "
               0  "Shell information for all media elements stored in one-dimensional arrays:"
               0  "                                                                        "
               0  " ish              => absolute shell index (1...shell_ntot)              "
               0  " shell_be(ish)    => shell binding energy                               "
               0  " shell_type(ish)  => shell type according to EADL notation              "
               0  " shell_Z(ish)     => Z of shell element                                 "
               0  " shell_num(ish)   =>  relative shell position within one element        "
               0  " shell_ntot       => total number of shells for all media elements      "
               0  " relax_first(ish) => initial absolute relaxation position               "
               0  " relax_ntran(ish) => number of transitions                              "
               0  " shell_eadl(Z,shell_num(ish)) => absolute shell position for element Z  "
               0  "                                                                        "
               0  "Transition information for all shells also stored in one-dimensional arrays:"
               0  "                                                                         "
               0  " transition index itran runs from 1...relax_ntot                         "
               0  " relax_prob(itran)  => transition probabilities                          "
               0  " relax_atbin(itran) => holds the alias indices                           "
               0  " relax_state(itran) => final relaxation state:                           "
               0  "                       radiative: relative shell position                "
               0  "                   non-radiative: relative position of shells(64*sh1+sh2)"
               0  "                                                                         "
               0  "                              Originally coded by IK in a standalone code"
               0  "                          Modified for use with EGSnrc by EMH, June 2011 "
               0  "                          Corrected bugs and commented by EMH, April 2012"
               0  "*************************************************************************"
               0  $IMPLICIT-NONE;
               0
               0  $declare_max_medium;
               0  $COMIN-RELAX-INIT;
               0
               0  $INTEGER   lnblnk1,egs_get_unit,relax_unit,ounit,egs_open_file;
               0  $INTEGER   sorted($MXELEMENT),i,j,k,k1,k2,m;
               0  $REAL      z_sorted($MXELEMENT),pz_sorted($MXELEMENT);
               0  character  data_dir*128,relax_file*144;
               0
               0  $INTEGER  ish,medio,iZ,ntran;
               0  $REAL     Ec, Pc, tmp, min_be, sumw,Ex;
               0  $LOGICAL  is_open, is_there;
               0  REPLACE {$MAXTMP} WITH {250}
               0  $REAL     wtmp($MAXTMP);
               0  $INTEGER  itmp($MAXTMP);
               0
               0  integer*4 pos, curr_rec, sh_eadl;
               0  integer*4 nz, nshell, tr_type;
               0  integer*4 ttype;
               0  real*4    be_r, prob_r;
               0
               0
               0  DO iZ=1,$MXELEMENT[
               1   DO k=1,$MXESHLL[
               2     shell_eadl(iZ,k) = -1;
               2   ]
               1  ]
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  min_be = $RELAX-CUTOFF;
               0  $egs_debug('(a)',' ************ relax_init **************** ');
               0  $egs_debug('(a,f10.7)',
               0          ' Minimum binding energy requiring relaxation data: ',min_be);
               0
               0
               0
               0
               0  $egs_info('(/a)',' Reading EADL relaxation data ......');
               0  data_dir = $cstring(hen_house) // 'data' // $file_sep;
               0  relax_file = $cstring(data_dir) // 'relax.data';
               0
               0
               0  relax_unit = egs_get_unit(0);
               0  IF( relax_unit < 1 ) [
               1     $egs_fatal(*,'egs_init_relax: failed to get a free Fortran I/O unit');
               1  ]
               0  open(relax_unit,file=relax_file,status='old',
               0       form='UNFORMATTED',ACCESS='direct',recl=$RECL-FACTOR,
               0       err=:no-relax-file:);
               0  GOTO :read-relax:;
               0  :no-relax-file:
               0  $egs_fatal('(2a)','egs_init_relax: failed to open ',
               0             relax_file);
               0  :read-relax:
               0  is_open = .true.;
               0
               0
               0
               0  curr_rec = 1;
               0  read(relax_unit,rec=curr_rec) nz;
               0  "$egs_info('(a,i2,a)','Relaxation data for ',nz,' elements....');"
               0  shell_ntot = 0;relax_ntot = 0;
               0  DO medio = 1,nmed [
               1     DO i=1,nne(medio) [z_sorted(i) = zelem(medio,i);]
               1     call egs_heap_sort(nne(medio),z_sorted,sorted);
               1     DO i=1,nne(medio) [
               2        iZ = z_sorted(i);
               2        "Now check whether we have already loaded the data for"
               2        "this atomic number"
               2        is_there = .false.;
               2        DO j = 1,shell_ntot [
               3           IF( iZ = shell_Z(j) ) [ is_there = .true.; EXIT; ]
               3        ]
               2        IF (is_there) NEXT;
               2        pos = iZ + 1;
               2        read(relax_unit,rec=pos) curr_rec;
               2        read(relax_unit,rec=curr_rec) nshell;
               2        IF( shell_ntot + nshell > $MAXSHELL ) [
               3           $egs_fatal('(a,i5,a/,a//)',' Too many shells to fit in the list: ',
               3                  shell_ntot + nshell,' (at least).',
               3                  ' Increase the parameter $MAXSHELL and retry ');
               3        ]
               2        $egs_info('(a,i3,a,i2,a)',
               2        '  Z = ',iZ,' has ',nshell,' shells');
               2        DO ish=shell_ntot+1,shell_ntot+nshell[
               3          curr_rec  = curr_rec+1;
               3          read(relax_unit, rec=curr_rec) shell_type(ish);
               3          curr_rec  = curr_rec+1;
               3          read(relax_unit, rec=curr_rec) ntran;
               3          curr_rec  = curr_rec+1;
               3          read(relax_unit, rec=curr_rec) be_r; shell_be(ish) = be_r;
               3
               3          shell_Z(ish) = iZ;
               3          shell_num(ish) = ish - shell_ntot;
               3          shell_eadl(iZ,shell_num(ish)) = ish;
               3          IF (binding_energies(shell_num(ish),iZ) > 0)[
               4             shell_be(ish) = binding_energies(shell_num(ish),iZ);
               4          ]
               3          ELSE IF( photon_xsections = 'epdl' )[
               4            "Use binding energies from relax.data below 1 keV"
               4             binding_energies(shell_num(ish),iZ) = shell_be(ish);
               4          ]
               3          DO k=1,ntran[
               4              curr_rec  = curr_rec+1;
               4              read(relax_unit,rec=curr_rec) itmp(k);
               4              curr_rec  = curr_rec+1;
               4              read(relax_unit,rec=curr_rec) prob_r;wtmp(k)=prob_r;
               4
               4
               4
               4              IF (itmp(k)<64) [itmp(k) +=1;]
               4              ELSE            [itmp(k) += 65;]
               4          ]
               3          IF( shell_be(ish) < min_be ) [
               4              relax_first(ish) = -1;
               4              relax_ntran(ish) = -1;
               4          ]
               3          ELSE [
               4              sumw = 0;
               4              DO k=1,ntran [  sumw = sumw + wtmp(k); ]
               4              IF( sumw > 1 ) [
               5                  DO k=1,ntran [  wtmp(k) = wtmp(k)/sumw; ]
               5              ]
               4              ELSE IF( sumw < 1 ) [
               5                  ntran = ntran + 1; itmp(ntran) = -1; wtmp(ntran) = 1-sumw;
               5              ]
               4              IF( relax_ntot + ntran > $MAXRELAX ) [
               5                 $egs_fatal('(a,i5,a/,a/)',' Too many relaxation transitions: ',
               5                   relax_ntot + ntran,' (at least).',
               5                   ' Increase $MAXRELAX and retry ');
               5              ]
               4              relax_first(ish) = relax_ntot+1; relax_ntran(ish) = ntran;
               4              call prepare_alias_histogram(ntran,wtmp,
               4                                   relax_atbin(relax_ntot+1));
               4              DO k=1,ntran [
               5                 j = relax_ntot + k;
               5                 relax_state(j) = itmp(k); relax_prob(j) = wtmp(k);
               5              ]
               4              relax_ntot = relax_ntot + ntran;
               4          ]
               3        ]
               2
               2        shell_ntot = shell_ntot + nshell;
               2
               2     ]
               1
               1  ]
               0  $egs_debug('(a,i4,a)',' There are ',
               0          shell_ntot,' shells in the list of shells ');
               0  $egs_info('(a/)',' ...... Done.');
               0
               0
               0  IF( is_open ) close(relax_unit);
               0  return;
               0
               0  stop;
               0  end;
               0
               0  "Macro to check that the stack size is not exceeded"
               0  REPLACE {$CHECK-RELAX-STACK(#,#);} WITH {;
            {  0    IF( {P1} > $MXSTACK ) [
            {  0        $egs_warning('(3(a,f10.6),a,i2)',
            {  0         'Evac = ',Evac, ' Ef = ',Ef,
            {  0         "' Z = ',iZ,' Nvac = ',Nvac,"
            {  0         ' min_E = ', min_E,' iq = ',iqf);
            {  0  ;  "---------- BUFFER FLUSH SEMICOLON ----------"
            {  0        $egs_fatal('(//,3a,/,2(a,i9),/,a)',' In subroutine ',{P2},
            {  0            ' stack size exceeded! ',' $MXSTACK = ',$MXSTACK,' np = ',{P1},
            {  0            ' Increase $MXSTACK and try again ');
            {  0    ]
            {  0  };
               0
               0  "***********************************************************************"
               0    subroutine egs_eadl_relax(iZ, shell_egs);
               0  "************************************************************************"
               0  " Subroutine, called from subroutine relax, to fill a vacancy in         "
               0  " shell shell_egs in element iZ by emitting fluorescent X-rays, Auger    "
               0  " and Coster-Kronig electrons.  Uses EADL data.                          "
               0  " Results passed via variables in comins.                                "
               0  "   edep                                                                 "
               0  "   edep_local                                                           "
               0  "   e(np)                                                                "
               0  "                                                                        "
               0  " There are calls to ausgab with IARG values                             "
               0  "   24  A fluorescent transition just occurred                           "
               0  "   26  An Auger transition just occurred                                "
               0  "   32  Sub-threshold fluorescent transition just occurred               "
               0  "   33  Sub-threshold Auger transition just occurred                     "
               0  "                                                                        "
               0  " There is an inconsistency in the binding energies (BE) as COMPT uses   "
               0  " different BE (incoh.data)                                              "
               0  "                                                                        "
               0  " Explain need to reduce new_state by 1 below as alias sampling provides "
               0  " bin number from 1...nbin and not 0...nbin-1                            "
               0  "                                                                        "
               0  "                             Originally coded by IK in a standalone code"
               0  "                         Modified for use with EGSnrc by EMH, June 2011 "
               0  "                         Corrected bugs and commented by EMH, April 2012"
               0  "************************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $declare_max_medium;
               0  $COMIN-RELAX-EADL;
               0  ;COMIN/RELAX-USER/;
               0
               0  $REAL    Ec,Pc,min_E,rnno,Evac,Ef,Ef1,Ef2,Ex,Ecc,
               0           cost,sint,cphi,sphi;
               0  "Ec      ecut as k.e. for current region"
               0  "Pc      pcut for current region"
               0  "min_E   the minimum energy for transitions to continue"
               0  "rnno    a random number"
               0  "Evac    binding energy of current vacancy"
               0  "Ef      the sum of the binding energies of the new vacancies"
               0  "Ef1     the first new binding energy of for non-radiative transitions"
               0  "Ef2     the second new binding energy of for non-radiative transitions"
               0  "Ex      the change in total binding energy"
               0  "Ecc     the cutoff energy (Ec or Pc)"
               0  "cost,sint,cphi,sphi variables for calculating particle direction"
               0
               0  $INTEGER  shell, shell_egs, iZ, iarg;
               0  "shell       number in master eadl list"
               0  "shell_egs   shell number in current element"
               0  "iZ          atomic number of element"
               0
               0  $INTEGER  irl,vacs($MAXVAC),nvac,vac,new_state,iqf,np_save,new1,new2;
               0  "irl           current region"
               0  "vacs($MAXVAC) array of vacancy shell numbers"
               0  "nvac          current number of vacancies in vacs"
               0  "vac           shell number of current vacancy"
               0  "new_state     the state number that represents the new vacancy"
               0  "iqf           the charge of the emitted relaxation particle"
               0  "np_save       the stack index of the particle inducing in relaxations"
               0  "new1          the first new vacancy for non-radiative transitions"
               0  "new2          the second new vacancy for non-radiative transitions"
               0
               0  $INTEGER sample_alias_histogram;
               0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
               0
               0  shell = shell_eadl(iZ,shell_egs);
               0  IF( shell < 1 | shell > $MAXSHELL ) [ return; ] "unknown vacancy"
               0
               0  irl = ir(np);
               0  Ec = ecut(irl) - rm;
               0  Pc = pcut(irl);
               0  min_E = $RELAX-CUTOFF;
               0
               0  Evac = shell_be(shell); "provides relevant binding energy for this vacancy"
               0  "store some information in comin RELAX-FOR-USER.  This just duplicates"
               0  "various pieces of info so the user can access them."
               0  rfu_Z  = shell_Z(shell); "Z of element the relaxing shell belongs to"
               0  rfu_j0 = shell;         "shell # of vacancy that initiated cascade in long list"
               0  rfu_n0 = shell_num(shell); "same but number is shell number in element iZ"
               0  rfu_t0 = shell_type(shell); "the shell type (encodes the type of relaxation)"
               0  rfu_E0 = Evac;          "B.E. of vacancy that initiated cascade"
               0  "
               0  "Local energy deposition for vacancies below L3 shell."
               0  "Added here for consistency in algorithm for as long as"
               0  "<M> and <N> shells considered instead of proper shells."
               0  "AUSGAB call should be updated when charge of particle"
               0  "creating vacancy becomes available."
               0  IF (shell_egs > 4 & ~mcdf_pe_xsections) [
               1      edep = Evac;        "add energy of vacancy to edep"
               1      edep_local = Evac;  "set value of edep_local to energy of vacancy"
               1
               1      "Assign this energy deposition to an electron."
               1      "Note that this should NOT be treated as though it came from a photon,"
               1      "even if a photon initiated the relaxations. Rather, energy remaining"
               1      "in vacancies should be given to an electron or absorbed locally."
               1      $AUSCALL($SELECTRONA); "call ausgab with iarg=34"
               1
               1      return; "invokes $AUSCALL($PHOTXAUS) in COMPT;"
               1  ]
               0
               0  vac = shell; Nvac = 0; np_save = np;
               0  LOOP [ "from here to end of routine over all vacancies created"
               1
               1      "check if energy of vacancy < cutoff OR no transitions from this shell"
               1      IF( Evac < min_E | relax_ntran(vac) < 1 ) [
               2          edep += Evac;         "add energy of vacancy to edep"
               2          edep_local = Evac;    "set value of edep_local to energy of vacancy"
               2
               2          "Assign this energy deposition to an electron."
               2          "Note that this should NOT be treated as though it came from a photon,"
               2          "even if a photon initiated the relaxations. Rather, energy remaining"
               2          "in vacancies should be given to an electron or absorbed locally."
               2          $AUSCALL($SELECTRONA); "call ausgab with iarg=34"
               2
               2          go to :VACANCY:;      "exit loop and if Nvac still 0, exit routine"
               2      ]
               1
               1      "prepare_alias_histogram is called from subroutine egs_init_relax and"
               1      "sample_alias_histogram uses the array of bin probabilities and bin"
               1      "numbers relax_prob(relax_first(vac) and relax_atbin(relax_first(vac))"
               1      "to return the bin which has been sampled, i.e. new_state"
               1      "relax_ntran(vac) tells how many transitions are available"
               1      new_state = sample_alias_histogram(relax_ntran(vac),
               1                    relax_prob(relax_first(vac)),
               1                    relax_atbin(relax_first(vac)));
               1      IF( new_state < 0 ) [ "this may happen if the sum of probabilities from"
               2                            "EADL was < 1. In this case the entire energy is"
               2                            "given to an electron and no new vacancy is created"
               2          Ef = 0;
               2          iqf = -1;
               2          Ecc = Ec;
               2      ]
               1      ELSE[
               2          new_state = relax_state(relax_first(vac)+new_state-1);
               2       IF( new_state <= 64 ) [ "It was a radiative transition, i.e. fluorescence"
               3          iqf = 0;
               3          new_state += vac - shell_num(vac);
               3          Ef = shell_be(new_state);
               3          Nvac += 1;
               3          vacs(Nvac) = new_state;
               3          Ecc = Pc;
               3       ] "end of fluorescence block"
               2
               2       ELSE [ "It was a non-radiative transition (Auger or Coster-Kronig)"
               3          iqf = -1; new1 = new_state/64; new2 = new_state - 64*new1;
               3          new1 += vac - shell_num(vac); new2 += vac - shell_num(vac);
               3          Ef1 = shell_be(new1); Ef2 = shell_be(new2);
               3          Nvac += 1; vacs(Nvac) = new1;
               3          Nvac += 1; vacs(Nvac) = new2;
               3          Ef = Ef1 + Ef2; Ecc = Ec;
               3       ] "end Auger or Coster-Kronig block"
               2      ]
               1      Ex = Evac - Ef;
               1      edep_local = 0;
               1      IF( Ex > Ecc ) [
               2          np += 1; $CHECK-RELAX-STACK(np,'new_relax');
               2          iq(np) = iqf;
               2          $TRANSFER PROPERTIES TO (np) FROM (np_save);
               2          $RANDOMSET rnno; cost = 2*rnno-1; sint = 1-cost*cost;
               2          IF( sint > 0 ) [
               3              sint = sqrt(sint);
               3              $SELECT-AZIMUTHAL-ANGLE(cphi,sphi);
               3              u(np) = sint*cphi; v(np) = sint*sphi; w(np) = cost;
               3          ] ELSE [ u(np) = 0; v(np) = 0; w(np) = cost; ]
               2          rfu_j = vac; rfu_n = shell_num(vac); rfu_t = shell_type(vac);
               2          rfu_E = shell_be(vac);
               2          IF( iqf = 0 ) [
               3              e(np) = Ex; $AUSCALL($FLUORTRA);
               3          ]
               2          ELSE [
               3              e(np) = Ex + rm; $AUSCALL($AUGERTRA);
               3          ]
               2      ] ELSE [ "Ex <= Ecc"
               2          edep += Ex;
               2
               2          IF( iqf = 0 ) [
               3              edep_local = Ex;
               3              $AUSCALL($SPHOTONA);
               3          ] ELSE [
               3              edep_local = Ex;
               3              $AUSCALL($SELECTRONA);
               3          ]
               2      ] "end Ex <= Ecc block"
               1      :VACANCY:;
               1      IF( Nvac = 0 ) EXIT;
               1      "get next vacancy to process"
               1      vac = vacs(Nvac); Evac = shell_be(vac); Nvac -= 1;
               1  ] "end of main loop"
               0  return;
               0  end;
               0  ;
               0
               0  "***************************************************************************"
               0  "     Triplet production stuff                                              "
               0  "***************************************************************************"
               0
               0  REPLACE {$N_TRIPLET_DATA} WITH {55}
               0  REPLACE {$N_ELEMENT} WITH {100}
               0  ;
               0  subroutine init_triplet;
               0  implicit none;
               0  $declare_max_medium;
               0  $COMIN-INIT-TRIPLET;
               0  $REAL  energies($N_TRIPLET_DATA), sig_pair($N_ELEMENT,$N_TRIPLET_DATA),
               0         sig_triplet($N_ELEMENT,$N_TRIPLET_DATA), f_triplet($N_TRIPLET_DATA),
               0         sigp($N_TRIPLET_DATA), sigt($N_TRIPLET_DATA),
               0         as($N_TRIPLET_DATA), bs($N_TRIPLET_DATA), cs($N_TRIPLET_DATA),
               0         ds($N_TRIPLET_DATA);
               0  character*128  triplet_data_file;
               0  $INTEGER want_triplet_unit, triplet_unit, triplet_out;
               0  $INTEGER i, iel, imed, lnblnk1, egs_get_unit, ntrip, iz1, izi, ifirst;
               0  $REAL    logE, f_new, f_old, spline;
               0
               0  IF( itriplet = 0 ) return;
               0  $set_string(triplet_data_file,' ');
               0  triplet_data_file = $cstring(hen_house) // 'data' // $file_sep //
               0                      'triplet.data';
               0  want_triplet_unit = 63;
               0  triplet_unit = egs_get_unit(want_triplet_unit);
               0  IF( triplet_unit < 1 ) [
               1      $egs_fatal(*,'init_triplet: failed to get a free Fortran I/O unit');
               1  ]
               0  open(triplet_unit,file=triplet_data_file,err=:no-triplet-file:);
               0  $egs_info('(a,$)',' init_triplet: reading triplet data ... ');
               0  read(triplet_unit,*) ntrip;
               0  IF( ntrip > $N_TRIPLET_DATA ) [
               1      $egs_fatal(*,'Max. number of data points per element is ',$N_TRIPLET_DATA);
               1  ]
               0  read(triplet_unit,*,err=:error_triplet_data:) (energies(i),i=1,ntrip);
               0  DO iel=1,$N_ELEMENT [
               1      read(triplet_unit,*);
               1      read(triplet_unit,*,err=:error_triplet_data:)
               1          (sig_pair(iel,i),i=1,ntrip);
               1      read(triplet_unit,*,err=:error_triplet_data:)
               1          (sig_triplet(iel,i),i=1,ntrip);
               1  ]
               0  $egs_info(*,'OK');
               0  ifirst = 0;
               0  DO i=1,ntrip [
               1      IF( ifirst = 0 & energies(i) > 4.01*rm ) ifirst = i;
               1      energies(i) = log(energies(i));
               1  ]
               0  log_4rm = log(4*rm);
               0  energies(ifirst-1) = log_4rm;
               0  dl_triplet = (energies(ntrip) - log_4rm)/$MAX_TRIPLET;
               0  dli_triplet = 1/dl_triplet;
               0  bli_triplet = 1 - log_4rm/dl_triplet;
               0
               0  DO imed = 1, nmed [
               1
               1      $egs_info('(a,i3,a,$)',
               1        '   Preparing triplet fraction data for medium ',imed,' ... ');
               1      iz1 = zelem(imed,1) + 0.1;
               1      DO i=1,ntrip [
               2          sigp(i) = pz(imed,1)*sig_pair(iz1,i);
               2          sigt(i) = pz(imed,1)*sig_triplet(iz1,i);
               2          DO iel=2,nne(imed) [
               3              izi = zelem(imed,iel) + 0.1;
               3              sigp(i) = sigp(i) + pz(imed,iel)*sig_pair(izi,i);
               3              sigt(i) = sigt(i) + pz(imed,iel)*sig_triplet(izi,i);
               3          ]
               2      ]
               1
               1      DO i=ifirst,ntrip [ f_triplet(i-ifirst+2) = sigt(i)/(sigp(i) + sigt(i)); ]
               1      f_triplet(1) = 0;
               1      call set_spline(energies(ifirst-1),f_triplet,as,bs,cs,ds,ntrip-ifirst+2);
               1
               1      logE = log_4rm; f_old = 0;
               1      DO i=1, $MAX_TRIPLET-1 [
               2          logE = logE + dl_triplet;
               2          f_new = spline(logE,energies(ifirst-1),as,bs,cs,ds,ntrip-ifirst+2);
               2          a_triplet(i,imed) = (f_new - f_old)*dli_triplet;
               2          b_triplet(i,imed) = f_new - a_triplet(i,imed)*logE;
               2          f_old = f_new;
               2      ]
               1      $egs_info(*,'OK');
               1
               1  ]
               0  close(triplet_unit);
               0  return;
               0
               0  :no-triplet-file:;
               0  $egs_fatal('(a,a)',' init_triplet: failed to open the data file ',
               0               triplet_data_file(:lnblnk1(triplet_data_file)));
               0
               0  :error_triplet_data:;
               0  $egs_fatal(*,' init_triplet: error while reading triplet data ');
               0
               0  return; end;
               0
1              0  %E
               0  "******************************************************************"
               0  SUBROUTINE EDGSET(NREGLO,NREGHI);
               0  "******************************************************************"
               0  " SUBPROGRAM TO SET UP PARAMETERS FOR ATOMIC RELAXATIONS           "
               0  " and proper handling of photo-electric absorption
               0  "******************************************************************"
               0  " Programmer:   I. Kawrakow, (NRC)                                 "
               0  "******************************************************************"
               0  "                                                                  "
               0  "  Input:  NREGLO and NREGHI, not needed but left there for        "
               0  "                             compatibility with older user codes  "
               0  "
               0  "  This routine is called from HATCH, it checks whether one of the "
               0  "  elements of IEDGFL has been set to an integer number between    "
               0  "  1 and 100 and if so reads in photo-absorption and relaxation    "
               0  "  data. Note that the array IEDGFL, which used to be the          "
               0  "  `effecvtive' atomic number of a medium is not used for any      "
               0  "  purpose other than to indicate that relaxations are requested   "
               0  "  (if non-zero).
               0  "******************************************************************"
               0  "                                                                  "
               0
               0  $IMPLICIT-NONE;
               0
               0  ;COMIN/EDGE,X-OPTIONS,EGS-IO/;
               0
               0  "Input variables"
               0  integer  NREGLO,NREGHI;
               0
               0  $INTEGER i,j,k,jj,iz;
               0  logical  do_relax;
               0  logical  got_data;
               0  save     got_data;
               0  data     got_data/.false./;
               0
               0  IF( got_data ) return;
               0     "EDGSET is now called from HATCH. In older user codes it was called
               0     "from within the user code. If this happens, and the data is already
               0     "available, we don't need to read it again. That's why the above
               0     "statement.
               0
               0  $egs_info('(a/,a)',
               0            'Output from subroutine EDGSET:',
               0            '==============================');
               0
               0  $need_relaxation_data(do_relax);
               0  IF( ~do_relax ) [
               1
               1      IF(eadl_relax)[
               2          $egs_fatal('(a,/a)',
               2                     'You must turn ON atomic relaxations when requesting',
               2                     'detailed atomic relaxation (eadl_relax=true)!');
               2      ]
               1      $egs_info('(a/)',' Atomic relaxations not requested! ');
               1      return;
               1  ]
               0
               0  $egs_info('(a/)',' Atomic relaxations requested! ');
               0
               0  $egs_info('(a$)',' Reading simplified photo-absorption data .....');
               0
               0  got_data = .true.;
               0  rewind($PHOTOUNIT);
               0
               0  DO i=1,$MXELEMENT
               0  [
               1      IF (eadl_relax)[
               2         "Skip, using binding_energies from *_photo.data file
               2         read($PHOTOUNIT,*);
               2      ]
               1      ELSE[
               2         read($PHOTOUNIT,*) j,(binding_energies(k,i),k=1,$MXSHELL);
               2         DO k=1,$MXSHELL [
               3            binding_energies(k,i) = binding_energies(k,i)*1e-6; "Convert to MeV"
               3         ]
               2      ]
               1  ]
               0  read($PHOTOUNIT,*);
               0  DO i=1,$MXELEMENT
               0  [
               1      read($PHOTOUNIT,*) j,(interaction_prob(k,i),k=1,$MXINTER);
               1      interaction_prob($MXSHELL,i)=1.01;
               1  ]
               0  $egs_info('(a)',' Done');
               0
               0  $egs_info('(/a$)',' Reading simplified relaxation data .....');
               0  read($PHOTOUNIT,*);
               0  DO i=1,$MXELEMENT [
               1          read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=1,19);   "K-shell"
               1  ]
               0  read($PHOTOUNIT,*);
               0  DO i=1,$MXELEMENT [
               1          read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=20,26);   "L1-shell"
               1  ]
               0  read($PHOTOUNIT,*);
               0  DO i=1,$MXELEMENT [
               1          read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=27,32);   "L2-shell"
               1  ]
               0  read($PHOTOUNIT,*);
               0  DO i=1,$MXELEMENT [
               1          read($PHOTOUNIT,*) j,(relaxation_prob(k,i),k=33,37);   "L3-shell"
               1  ]
               0  read($PHOTOUNIT,*);
               0  DO i=1,$MXELEMENT [
               1          read($PHOTOUNIT,*) j,relaxation_prob(38,i);   "M-shell"
               1  ]
               0  $egs_info('(a)',' Done');
               0  $egs_info('(/a$)',' Reading parametrized XCOM photo cross section data .....');
               0  rewind($PHOCSUNIT);
               0  DO i=1,$MXELEMENT [
               1      read($PHOCSUNIT,*) j,edge_number(i);
               1      DO j=1,edge_number(i) [
               2          read($PHOCSUNIT,*) edge_a(j,i),edge_b(j,i),edge_c(j,i),
               2                             edge_d(j,i),edge_energies(j,i);
               2      ]
               1  ]
               0  $egs_info('(a)',' Done');
               0
               0  IF (eadl_relax)[
               1   call egs_init_relax;
               1  ]
               0
               0  RETURN;
               0  END;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE PHOTON(IRCODE);
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $INTEGER IRCODE; "1 => normal return"
               0
               0  $COMIN-PHOTON;   "default replacement produces the following:
               0                   "COMIN/DEBUG,BOUNDS,MEDIA,MISC,EPCONT,PHOTIN,STACK,THRESH,"
               0                   "  UPHIOT,USEFUL,USER,RANDOM,EGS-VARIANCE-REDUCTION/;"
               0
               0  $DEFINE-LOCAL-VARIABLES-PHOTON;
               0
               0
               0  IRCODE=1;"set up normal return"
               0  PEIG=E(NP);
               0  EIG=PEIG; "energy of incident gamma"
               0  IRL=IR(NP);
               0  $start_new_particle;
               0
               0  IF(EIG <= PCUT(IRL)) [GO TO :PCUT-DISCARD:;]
               0
               0  :PNEWENERGY:
               0  LOOP["enter this loop for each photon with new energy"
               1
               1  IF(WT(NP) = 0.0) [go to :USER-PHOTON-DISCARD:;] "added May 01"
               1
               1  GLE=LOG(EIG);"GLE IS GAMMA LOG ENERGY"
               1
               1  "   here to sample no. mfp to transport before interacting"
               1
               1  $SELECT-PHOTON-MFP;
               1  " DEFAULT FOR $SELECT-PHOTON-MFP; IS:  $RANDOMSET RNNO35;"
               1  "                                      DPMFP=-LOG(RNNO35);"
               1  "NOTE:  THIS TEMPLATE CAN ALSO BE OVER-RIDDEN BY OTHER SCHEMES,"
               1  "       SUCH AS THE 'EXPONENTIAL TRANSFORM' TECHNIQUE."
               1
               1  IROLD=IR(NP);"INITIALIZE PREVIOUS REGION"
               1
               1  :PNEWMEDIUM:
               1  LOOP["HERE EACH TIME WE CHANGE MEDIUM DURING PHOTON TRANSPORT"
               2  IF (MEDIUM.NE.0)[$SET INTERVAL GLE,GE;"SET PWLF INTERVAL"
               3  $EVALUATE GMFPR0 USING GMFP(GLE);]
               2
               2  :PTRANS:
               2  LOOP["PHOTON TRANSPORT LOOP"
               3  IF (MEDIUM.EQ.0)[TSTEP=VACDST;]
               3  ELSE [$SET-RHOF;    "DENSITY RATIO SCALING TEMPLATE"
               4  GMFP=GMFPR0/RHOF;
               4  $RAYLEIGH-CORRECTION;  "A RAYLEIGH SCATTERING TEMPLATE"
               4  "Ali:photonuc, 1 line"
               4  $PHOTONUC-CORRECTION;  "A PHOTONUCLEAR TEMPLATE"
               4  TSTEP=GMFP*DPMFP;]
               3  "   SET DEFAULT VALUES FOR FLAGS SENT BACK FROM USER"
               3  IRNEW=IR(NP);"SET DEFAULT NEW REGION NUMBER"
               3  IDISC=0;"ASSUME PHOTON NOT DISCARDED"
               3  USTEP=TSTEP;"TRANSFER TRANSPORT DISTANCE TO USER VARIABLE"
               3  TUSTEP=USTEP;
               3
               3  "IF (USTEP.GT.DNEAR(NP)) [;CALL HOWFAR;]"
               3  $CALL-HOWFAR-IN-PHOTON; "The above is the default replacement"
               3
               3
               3  "   NOW CHECK FOR USER DISCARD REQUEST"
               3  IF (IDISC.GT.0)["USER REQUESTED IMMEDIATE DISCARD"
               4  GO TO :USER-PHOTON-DISCARD:;]
               3
               3  VSTEP=USTEP; "SET VARIABLE FOR OUTPUT CODE"
               3  TVSTEP=VSTEP;
               3  EDEP=PZERO; "NO ENERGY DEPOSITION ON PHOTON TRANSPORT"
               3
               3  x_final = x(np) + u(np)*vstep;
               3  y_final = y(np) + v(np)*vstep;
               3  z_final = z(np) + w(np)*vstep;
               3
               3  $AUSCALL($TRANAUSB);
               3
               3  "   TRANSPORT THE PHOTON"
               3  x(np) = x_final; y(np) = y_final; z(np) = z_final;
               3  DNEAR(NP)=DNEAR(NP)-USTEP;"DEDUCT FROM DISTANCE TO NEAREST BOUNDARY"
               3  IF (MEDIUM.NE.0)[DPMFP=MAX(0.,DPMFP-USTEP/GMFP);] "DEDUCT MFP'S"
               3  IROLD=IR(NP); "SAVE PREVIOUS REGION"
               3
               3  MEDOLD=MEDIUM;
               3  IF (IRNEW.NE.IROLD) ["REGION CHANGE"
               4    $photon_region_change;
               4  ]
               3
               3  "   AFTER TRANSPORT CALL TO USER"
               3  $AUSCALL($TRANAUSA);
               3  "oct 31 bug found by C Ma. PCUT discard now after AUSGAB call"
               3  IF(EIG.LE.PCUT(IRL)) [GO TO :PCUT-DISCARD:;]
               3
               3  "   NOW CHECK FOR DEFERRED DISCARD REQUEST.  MAY HAVE BEEN SET"
               3  "   BY EITHER HOWFAR, OR ONE OF THE TRANSPORT AUSGAB CALLS"
               3  IF (IDISC.LT.0) GO TO :USER-PHOTON-DISCARD:;
               3
               3  IF (MEDIUM.NE.MEDOLD) EXIT :PTRANS:;
               3
               3  IF (MEDIUM.NE.0.AND.DPMFP.LE.$EPSGMFP)["TIME FOR AN INTERACTION"
               4  EXIT :PNEWMEDIUM:;]
               3  ]REPEAT ":PTRANS: LOOP"
               2
               2  ]REPEAT ":PNEWMEDIUM: LOOP"
               1
               1
               1  "   IT IS FINALLY TIME TO INTERACT."
               1  "   THE FOLLOWING MACRO ALLOWS ONE TO INTRODUCE RAYLEIGH SCATTERING"
               1  $RAYLEIGH-SCATTERING;
               1  "Ali:photonuclear, 1 line"
               1  $PHOTONUCLEAR;
               1  $RANDOMSET RNNO36; "THIS RANDOM NUMBER DETERMINES WHICH INTERACTION"
               1  "   GBR1=PAIR/(PAIR+COMPTON+PHOTO)=PAIR/GTOTAL"
               1  $EVALUATE GBR1 USING GBR1(GLE);
               1  IF((RNNO36.LE.GBR1).AND.(E(NP).GT.RMT2) )["IT WAS A PAIR PRODUCTION"
               2      $AUSCALL($PAIRAUSB);
               2      CALL PAIR;
               2      "   THE FOLLOWING MACRO ALLOWS THE USER TO CHANGE THE PARTICLE"
               2      "   SELECTION SCHEME (E.G., ADDING IMPORTANCE SAMPLING (SPLITTING, "
               2      "   LEADING PARTICLE SELECTION, ETC.))."
               2      "   (DEFAULT MACRO IS TEMPLATE '$PARTICLE-SELECTION-PHOTON' "
               2      "   WHICH IN TURN HAS THE 'NULL' REPLACEMENT ';') "
               2      $PARTICLE-SELECTION-PAIR;
               2      $AUSCALL($PAIRAUSA);
               2      IF( iq(np) ~= 0 ) [ EXIT :PNEWENERGY:; ]
               2      ELSE [ "this may happen if pair electrons killed via Russian Roulette"
               3          goto :PAIR-ELECTRONS-KILLED:;
               3      ]
               2  ]
               1  "GBR2=(PAIR+COMPTON)/GTOTAL"
               1  $EVALUATE GBR2 USING GBR2(GLE);
               1  IF (RNNO36.LT.GBR2)["IT WAS A COMPTON"
               2      $AUSCALL($COMPAUSB);
               2      CALL COMPT;
               2      "   THE FOLLOWING MACRO ALLOWS THE USER TO CHANGE THE PARTICLE"
               2      "   SELECTION SCHEME (E.G., ADDING IMPORTANCE SAMPLING (SPLITTING, "
               2      "   LEADING PARTICLE SELECTION, ETC.))."
               2      "   (DEFAULT MACRO IS TEMPLATE '$PARTICLE-SELECTION-PHOTON' "
               2      "   WHICH IN TURN HAS THE 'NULL' REPLACEMENT ';') "
               2      $PARTICLE-SELECTION-COMPT;
               2      $AUSCALL($COMPAUSA);
               2      IF (IQ(NP).NE.0"NOT PHOTON")EXIT:PNEWENERGY:;
               2  ]
               1  ELSE["IT WAS PHOTOELECTRIC EFFECT"
               2      $AUSCALL($PHOTOAUSB);
               2      CALL PHOTO;
               2      "   THE FOLLOWING MACRO ALLOWS THE USER TO CHANGE THE PARTICLE"
               2      "   SELECTION SCHEME (E.G., ADDING IMPORTANCE SAMPLING (SPLITTING, "
               2      "   LEADING PARTICLE SELECTION, ETC.))."
               2      "   (DEFAULT MACRO IS TEMPLATE '$PARTICLE-SELECTION-PHOTON' "
               2      "   WHICH IN TURN HAS THE 'NULL' REPLACEMENT ';') "
               2      $PARTICLE-SELECTION-PHOTO;
               2      IF (NP = 0 | NP < NPOLD ) [RETURN;]
               2        "The above may happen if Russian Roulette is on"
               2        "NP<NPOLD means that only electrons were created in the interaction"
               2        "and that all of them were killed. Hence, the top particle on the "
               2        "stack is from a previous interaction and may be in another region"
               2        "To avoid problems with the :PNEWENERGY: loop logic, we simply force"
               2        "a return to shower so that ELECTR or PHOTON are properly re-entered."
               2        "Changed by IK Dec. 21 2006 after D. Rogers and R. Taylor found a"
               2        "wrong dose with brems splitting and Russian Roulette on in a low "
               2        "energy calculation."
               2
               2      $AUSCALL($PHOTOAUSA);
               2      IF (IQ(NP) ~= 0 ) EXIT :PNEWENERGY:;
               2  ] "END OF PHOTO ELECTRIC BLOCK"
               1
               1  :PAIR-ELECTRONS-KILLED:
               1
               1  "   IF HERE, THEN GAMMA IS LOWEST ENERGY PARTICLE."
               1  PEIG=E(NP);
               1  EIG=PEIG;
               1  IF(EIG.LT.PCUT(IRL)) GO TO :PCUT-DISCARD:;
               1  ]REPEAT ":PNEWENERGY: LOOP"
               0
               0  "   IF HERE, MEANS ELECTRON TO BE TRANSPORTED NEXT"
               0  RETURN;
               0
               0  "---------------------------------------------"
               0  "PHOTON CUTOFF ENERGY DISCARD SECTION         "
               0  "---------------------------------------------"
               0  :PCUT-DISCARD:
               0  IF( medium > 0 ) [
               1      IF(EIG.GT.AP(MEDIUM)) [IDR=$EGSCUTAUS;]ELSE[IDR=$PEGSCUTAUS;]
               1  ] ELSE [ IDR=$EGSCUTAUS; ]
               0  EDEP=PEIG;"GET ENERGY DEPOSITION FOR USER"
               0  $PHOTON-TRACK-END;
               0  IRCODE=2;
               0  NP=NP-1;
               0  RETURN;
               0
               0  "---------------------------------------------"
               0  "User requested photon discard section        "
               0  "---------------------------------------------"
               0  :USER-PHOTON-DISCARD:
               0  EDEP=PEIG;
               0  $AUSCALL($USERDAUS);
               0  IRCODE=2;
               0  NP=NP-1;
               0  RETURN;
               0
               0  "END OF SUBROUTINE PHOTON"  END;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE SHOWER(IQI,EI,XI,YI,ZI,UI,VI,WI,IRI,WTI);
               0  "                                                                  "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-SHOWER;   "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/DEBUG,STACK,UPHIOT,RANDOM/;
               0
               0  "Input variables"
               0  $REAL EI,      "initial shower energy"
               0        XI,YI,ZI,"initial co-ordinates"
               0        UI,VI,WI,"initial direction cosines"
               0        WTI;     "initial weight"
               0
               0  $INTEGER
               0        IQI,     "initial particle charge"
               0        IRI;     "initial region number"
               0
               0  "Local variables"
               0  DOUBLE PRECISION
               0        DEG,    "energy for pi-zero option"
               0        DPGL,   "angle factor for pi-zero option"
               0        DEI,    "incident energy for pi-zero option"
               0        DPI,    "intermediate factor for pi-zero option"
               0        DCSTH,  "random number for pi-zero option"
               0        DCOSTH, "cos(theta) for pi-zero option"
               0        PI0MSQ; "pi-zero mass squared (in MeV**2)"
               0
               0  $REAL DNEARI, "initial distance to closest boundary"
               0        CSTH;   "random number for pi-zero option"
               0
               0  $INTEGER
               0        IRCODE; "status returned by ELECTR or PHOTON"
               0
               0  DATA PI0MSQ/1.8215416D4/;  "PI-ZERO MASS (MEV) SQUARED"
               0
               0  NP=1; NPold = NP;      "Set the old stack counter"
               0  DNEARI=0.0;
               0  IQ(1)=IQI; E(1)=EI; U(1)=UI; V(1)=VI; W(1)=WI;
               0  $TRANSFER PROPERTIES TO (1) FROM I;
               0
               0  IF (IQI = 2) ["PI-ZERO OPTION"
               1    "IF(EI <= PI0MSQ) [OUTPUT EI;    corrected Oct 24 1995 e-mail Hideo H "
               1    "                  noted by      Dr.  Muroyama at Nagoya University
               1    IF(EI**2 <= PI0MSQ) [
               2       $egs_fatal('(//a/,a,g15.5,a)',
               2       ' Stopped in subroutine SHOWER---PI-ZERO option invoked',
               2       ' but the total energy was too small (EI=',EI,' MeV)');
               2    ]
               1    $RANDOMSET CSTH;
               1    DCSTH=CSTH; DEI=EI; DPI=DSQRT(DEI*DEI-PI0MSQ);
               1    DEG=DEI+DPI*DCSTH; DPGL=DPI+DEI*DCSTH; DCOSTH=DPGL/DEG;
               1    COSTHE=DCOSTH; SINTHE=DSQRT(1.D0-DCOSTH*DCOSTH);
               1    IQ(1)=0; E(1)=DEG/2.;
               1    CALL UPHI(2,1);
               1    NP=2;
               1    DEG=DEI-DPI*DCSTH; DPGL=DPI-DEI*DCSTH; DCOSTH=DPGL/DEG;
               1    COSTHE=DCOSTH; SINTHE=-DSQRT(1.D0-DCOSTH*DCOSTH);
               1    IQ(2)=0; E(2)=DEG/2.;
               1    CALL UPHI(3,2);
               1  ]"end of pi-zero option"
               0
               0  "The following convoluted logic is difficult to follow"
               0  "when one modifies the outcome of certain interactions"
               0  "using nbr_split, Russian Roulette, or one of the     "
               0  "particle selection macros. I'm simplifying it        "
               0  "so that ircode becomes irrelevant. IK, August 2002   "
               0  ":TOPSTACK:"
               0  "LOOP["
               0  "   $KERMA-INSERT;"
               0  "   IF(IQ(NP) = 0) GO TO :PHOTON:;"
               0  "   LOOP ["
               0  "      :ELECTRON:"
               0  "      CALL ELECTR(IRCODE);"
               0  "      IF(IRCODE.EQ.2) EXIT; "
               0  "      :PHOTON:"
               0  "      CALL PHOTON(IRCODE);"
               0  "      IF(IRCODE.EQ.2) EXIT;"
               0  "   ]REPEAT"
               0  "   IF(NP <= 0) EXIT;"
               0  "]REPEAT "
               0
               0  LOOP [
               1      ;
               1      IF( np <= 0 ) EXIT;
               1      $KERMA-INSERT;  " DEFAULT FOR $KERMA-INSERT; IS ; (NULL)"
               1      IF( iq(np) = 0 ) [ call photon(ircode); ]
               1      ELSE             [ call electr(ircode); ]
               1
               1  ]
               0
               0  RETURN;
               0  "end of subroutine shower"  END;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               National Research Council of Canada"
               0  SUBROUTINE UPHI(IENTRY,LVL);
               0  "                                                                  "
               0  "******************************************************************"
               0  "   UPHI STANDS FOR 'UNIFORM PHI DISTRIBUTION'.                    "
               0  "   SET COORDINATES FOR NEW PARTICLE OR RESET DIRECTION COSINES OF "
               0  "   OLD ONE.  GENERATE RANDOM AZIMUTH SELECTION AND REPLACE THE    "
               0  "   DIRECTION COSINES WITH THEIR NEW VALUES.                       "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $COMIN-UPHI;     "DEFAULT REPLACEMENT PRODUCES THE FOLLOWING:
               0                   "COMIN/DEBUG,EPCONT,STACK,UPHIIN,UPHIOT,RANDOM/;
               0
               0  "Input variables"
               0  integer  IENTRY,LVL; "entry switches"
               0
               0  "Local variables"
               0  $REAL CTHET,  "5/2*pi-THETA, used to evaluate cos(THETA) using the sine table"
               0        RNNO38, "random number for azimuthal angle selection"
               0        PHI,    "azimuthal scattering angle"
               0        CPHI,   "5/2*pi-PHI"
               0        A,B,C,  "direction cosines before rotation"
               0        SINPS2, "SINPS2=A*A+B*B"
               0        SINPSI, "Sqrt(SINPS2)"
               0        US,VS,  "x- and y- component of scattering vector"
               0        SINDEL,COSDEL;
               0                "aux. variables for the rotation algorithm"
               0
               0  $INTEGER
               0        IARG,   "index for AUSGAB"
               0        LPHI,LTHETA,LCTHET,LCPHI;
               0                "indeces for sine table"
               0
               0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
               0  save CTHET,PHI,CPHI,A,B,C,SINPS2,SINPSI,US,VS,SINDEL,COSDEL;
               0
               0  $AUSCALL($UPHIAUSB);
               0  GO TO (:UPHI:,:UPHI2:,:NRK:),IENTRY;
               0  "   IENTRY OUT-OF-BOUNDS IF HERE"  GO TO :ERROR:;
               0
               0  :UPHI:; "NOTE: AFB 88/12/12 ADDED SEMI-COLON, ELSE BUG WHEN OVERRIDING SIN"
               0          "TABLE LOOK-UP"
               0  $SET INTERVAL THETA,SINC;
               0  $EVALUATE SINTHE USING SIN(THETA);
               0  CTHET=PI5D2-THETA;$SET INTERVAL CTHET,SINC;
               0  $EVALUATE COSTHE USING SIN(CTHET);
               0
               0  "   USE THE FOLLOWING ENTRY IF SINTHE AND COSTHE ARE ALREADY KNOWN."
               0  "   SELECT PHI UNIFORMLY OVER THE INTERVAL (0,TWO PI). THEN USE    "
               0  "   PWLF OF SIN FUNCTION TO GET SIN(PHI) AND COS(PHI).  THE COSINE "
               0  "   IS GOTTEN BY COS(PHI)=SIN(9*PI/4 - PHI).                       "
               0
               0  :UPHI2:;
               0
               0  " It is much faster to use the box method for azimuthal angle selection"
               0  " than the following                                                   "
               0  " $RANDOMSET RNNO38;
               0  " PHI=RNNO38*TWOPI;$SET INTERVAL PHI,SINC;
               0  " $EVALUATE SINPHI USING SIN(PHI);
               0  " CPHI=PI5D2-PHI;$SET INTERVAL CPHI,SINC;
               0  " $EVALUATE COSPHI USING SIN(CPHI);
               0  $SELECT-AZIMUTHAL-ANGLE(cosphi,sinphi);
               0
               0  "   USE THE FOLLOWING ENTRY FOR THE SECOND OF TWO PARTICLES WHEN WE"
               0  "   KNOW TWO PARTICLES HAVE A RELATIONSHIP IN THEIR CORRECTIONS.   "
               0  "   NOTE: SINTHE AND COSTHE CAN BE CHANGED OUTSIDE THROUGH COMMON. "
               0  "   LVL IS A PARAMETER TELLING WHICH PARTICLES TO WORK WITH.       "
               0  "   THETA (SINTHE AND COSTHE) ARE ALWAYS RELATIVE TO THE DIRECTION "
               0  "   OF THE INCIDENT PARTICLE BEFORE ITS DIRECTION WAS ADJUSTED.    "
               0  "   THUS WHEN TWO PARTICLES NEED TO HAVE THEIR DIRECTIONS COMPUTED,"
               0  "   THE ORIGINAL INCIDENT DIRECTION IS SAVED IN THE VARIABLE A,B,C "
               0  "   SO THAT IT CAN BE USED ON BOTH CALLS."
               0
               0  "   LVL=1 -- OLD PARTICLE, SAVE ITS DIRECTION AND ADJUST IT"
               0  "   LVL=2 -- NEW PARTICLE. ADJUST DIRECTION USING SAVED A,B,C"
               0  "   LVL=3 -- BREMSSTRAHLUNG GAMMA.  SAVE ELECTRON DIRECTION (NEXT  "
               0  "   TO TOP OF STACK), AND THEN ADJUST GAMMA DIRECTION."
               0
               0  :NRK:
               0  GO TO (:OLD-PARTICLE:,:NEW-PARTICLE:,:BREMS-GAMMA:),LVL;
               0  "   LVL OUT-OF-BOUNDS IF HERE"   GO TO :ERROR:;
               0
               0  :OLD-PARTICLE:
               0  A=U(NP);B=V(NP);C=W(NP);
               0  GO TO :ADJUST:;
               0
               0  :BREMS-GAMMA:
               0  A=U(NP-1);B=V(NP-1);C=W(NP-1);
               0
               0  :NEW-PARTICLE:
               0  $TRANSFER PROPERTIES TO (NP) FROM (NP-1);
               0
               0  "   SEE H.H. NAGEL DISSERTATION FOR COORDINATE SYSTEM DESCRIPTION. "
               0  "   A ROTATION IS PERFORMED TO TRANSFORM DIRECTION COSINES OF THE  "
               0  "   PARTICLE BACK TO THE PHYSICAL FRAME (FROM THE TRANSPORT FRAME) "
               0
               0  :ADJUST:
               0  SINPS2=A*A+B*B;
               0  "   If SINPS2 is small, no rotation is needed    "
               0  IF (SINPS2.LT.1.0E-20)["small polar angle case"
               1     U(NP)=SINTHE*COSPHI;
               1     V(NP)=SINTHE*SINPHI;
               1     W(NP)=C*COSTHE;    "fixed March 2001 from =COSTHE"
               1  ] "end small polar angle case"
               0  ELSE["large polar angle case"
               1     SINPSI=SQRT(SINPS2);
               1     US=SINTHE*COSPHI;
               1     VS=SINTHE*SINPHI;
               1     SINDEL=B/SINPSI;
               1     COSDEL=A/SINPSI;
               1     U(NP)=C*COSDEL*US-SINDEL*VS+A*COSTHE;
               1     V(NP)=C*SINDEL*US+COSDEL*VS+B*COSTHE;
               1     W(NP)=-SINPSI*US+C*COSTHE;
               1  ]"end large polar angle case"
               0
               0  $AUSCALL($UPHIAUSA);
               0
               0  RETURN;
               0
               0  :ERROR: "REACH THIS POINT IF EITHER IENTRY OR LVL NE 1,2, OR 3"
               0  $egs_fatal('(a,2i6)',' STOPPED IN UPHI WITH IENTRY,LVL=',IENTRY,LVL);
               0
               0  "END OF SUBROUTINE UPHI"    END;
               0
               0  ;
1              0  %E
               0  "*************************************************************************
               0  "
               0  " The following is a set of macros and subroutines that implement
               0  " bremsstrahlung sampling from the S. Seltzer (NIST) cross sections
               0  " (which are the basis for ICRU radiative stopping powers, into the
               0  " EGSnrc environment) or the NRC cross sections, which are essentially
               0  " the same as NIST, but with corrections to the electron-electron
               0  " contribution (corrections are only significant for low values of
               0  " atomic number Z and low values of the emitted photon energy k.
               0  "
               0  " In order to use it, you have to `turn on' this option by
               0  " setting ibr_nist (which is in COMON/BREMPR/) to ibr_nist=1 for the
               0  " original NIST data (nist_brems.data) or ibr_nist=2 for the NRC
               0  " data (nrc_brems.data).
               0  "
               0  " If this option is turned on, subroutine HATCH will call
               0  " subroutine init_nist_brems.
               0  " In init_nist_brems the NIST cross sections are read in,
               0  " total bremsstrahlung cross sections are calculated using
               0  " 64 point Gauss-Legendre quadrature, the interpolation arrays
               0  " that are used for total cross sections and brems fraction interpolations
               0  " (esig0, esig1, ebr10, ebr11               for electrons)
               0  " (psig0, psig1, pbr10, pbr11, pbr20, pbr21 for positrons)
               0  " are updated and alias sampling tables for rapid sampling of brems
               0  " energies are created. These alias sampling tables are then used
               0  " during the simulation in subroutine BREMS.
               0  " Be aware that there is a slight inconsistency when using this option
               0  " as resttricted radiative stopping powers used are the ones coming
               0  " from PEGS and so, they are calculated using Bethe-Heitler.
               0  " This will not matter at all if
               0  "   - AP is much smaller than the electron energy
               0  "       and/or
               0  "   - the restricted radiative stopping power is much smaller
               0  "     then the restricted collision stopping power
               0  " Both conditions are usually satisfied.
               0  "
               0  " I. Kawrakow, NRC, January 2000.
               0  "
               0  " Added NRC brems cross-sections
               0  " F. Tessier, NRC, August 2007.
               0  "
               0  "****************************************************************************
               0
               0  subroutine init_nist_brems;
               0  "**************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  $REAL    energy_array($MXBREN),x_array($MXBRXX),
               0           cs_array($MXBREN,$MXBRXX,$MXBREL);
               0  $REAL    xi_array($MXBRXX);
               0  real*8   x_gauss($MXGAUSS),w_gauss($MXGAUSS);
               0
               0  $INTEGER nmix,kmix,i,n,k,j,ii;
               0  $INTEGER ngauss,i_gauss;
               0  $INTEGER lnblnk1,egs_get_unit;
               0  $INTEGER ifirst,ilast,nener,neke,leil;
               0
               0  $REAL    cs($MXBREN,$MXBRXX),ee($MXBREN),ele($MXBREN);
               0  $REAL    csx($MXBRXX),afx($MXBRXX),bfx($MXBRXX),cfx($MXBRXX),dfx($MXBRXX);
               0  $REAL    cse($MXBREN),afe($MXBREN),bfe($MXBREN),cfe($MXBREN),dfe($MXBREN);
               0  $REAL    Z,sumA;
               0  $REAL    emin,xi,res,spline,eil,ei,beta2,aux,sigb,sigt,ebr1,ebr2;
               0  $REAL    sigee,sigep,sige,si_esig,si1_esig,si_ebr1,si1_ebr1,ededx,
               0           sig_bhabha,si_psig,si1_psig,si_pbr1,si1_pbr1,si_pbr2,si1_pbr2;
               0  $INTEGER iz;
               0  $REAL    ple,qle,x,f,error,max_error,x_max_error,f_max_error;
               0  $INTEGER ndat,k_max_error;
               0  character tmp_string*512, tmp1_string*512;
               0  integer  itmp;
               0
               0  $declare_write_buffer;
               0
               0  $REAL amu;
               0  parameter (amu = 1660.5655);  "converts the cross sections from mB/per atom"
               0                                "to cm^2/g"
               0  $LOGICAL ex,is_opened;
               0  $declare_max_medium;
               0  $COMIN-INIT-NIST-BREMS;
               0
               0  $set_string(tmp_string,' ');
               0  tmp_string = $cstring(hen_house) // 'data' // $file_sep;
               0
               0  IF( ibr_nist = 1 ) [
               1      $open_data_file(tmp_string,tmp1_string,'nist_brems.data',$NIST-DATA-UNIT);
               1  ]
               0  ELSE IF (ibr_nist = 2) [
               1      $open_data_file(tmp_string,tmp1_string,'nrc_brems.data',$NIST-DATA-UNIT);
               1  ]
               0  ELSE [
               1      $egs_fatal(*,' init_nist_brems: unknown value of ibr_nist!
            '  1      ibr_nist = ', ibr_nist);
               1  ]
               0
               0  "Get the S. Seltzer (ibr_nist=1) or NRC's (ibr_nist=2) brems cross sections"
               0  "
               0  rewind($NIST-DATA-UNIT);
               0  read($NIST-DATA-UNIT,*);
               0  read($NIST-DATA-UNIT,*) nmix,kmix;
               0  IF (kmix > $MXBRXX) [
               1      $egs_fatal(*,' init_nist_brems: to many k values in data file!');
               1  ]
               0  IF (nmix > $MXBREN) [
               1      $egs_fatal(*,' init_nist_brems: to many T values in data file!');
               1  ]
               0
               0  read($NIST-DATA-UNIT,*) (energy_array(n),n=1,nmix);
               0  DO n=1,nmix [ energy_array(n) = $NIST-ENERGY-SCALE*energy_array(n); ]
               0  read($NIST-DATA-UNIT,*) (x_array(k),k=1,kmix);
               0  read($NIST-DATA-UNIT,*);
               0  DO i=1,$MXBREL [
               1      read($NIST-DATA-UNIT,*) ((cs_array(n,k,i),n=1,nmix),k=1,kmix);
               1  ]
               0  close($NIST-DATA-UNIT);
               0
               0  DO k=1,kmix [
               1      xi_array(k)=Log(1-x_array(k)+1e-6);
               1      IF( fool_intel_optimizer ) [
               2          $egs_info(*,'xi_array(k): ',xi_array(k));
               2      ]
               1  ]
               0
               0  "Get abscissas and weights for Gauss-Legendre quadrature"
               0  "
               0  ngauss = $MXGAUSS;
               0  call gauss_legendre(0d0,1d0,x_gauss,w_gauss,ngauss);
               0
               0  "Calculate total brems cross sections and sampling tables"
               0  "for all media                                           "
               0
               0  $egs_info(*,' ');
               0  IF (ibr_nist = 1) [
               1  $egs_info(*,'Using NIST brems cross sections! ');
               1  ]
               0  ELSE IF (ibr_nist = 2) [
               1      $egs_info(*,'Using NRC brems cross sections! ');
               1  ]
               0  $egs_info(*,' ');
               0  DO medium=1,nmed [
               1
               1      log_ap(medium) = log(ap(medium));
               1      $egs_info(*,' Initializing brems data for medium ',medium,'...');
               1      emin = max(ae(medium) - rm, ap(medium));
               1      DO i=1,nmix [
               2          IF( energy_array(i) >= emin ) EXIT;
               2      ]
               1      ifirst = i;
               1      DO i=nmix,1,-1 [
               2          IF( energy_array(i) < ue(medium) - rm ) EXIT;
               2      ]
               1      ilast = i+1;
               1      IF( ifirst < 1 | ilast > nmix ) [
               2          $egs_info(*,' init_nist_brems: data available only for ');
               2          $egs_info(*,energy_array(1),' <= E <= ',energy_array(nmix));
               2          $egs_info(*,' will use spline interpolations to get cross ');
               2          $egs_info(*,' sections beyond the available data but this may');
               2          $egs_info(*,' produce nonsense!');
               2          IF( ifirst < 1 ) ifirst=1;
               2          IF( ilast > nmix ) ilast = nmix;
               2      ]
               1      DO i=ifirst,ilast [
               2          ii = i+1 - ifirst;
               2          ee(ii) = energy_array(i); ele(ii) = log(ee(ii));
               2          sumA = 0;
               2          DO j=1,NNE(medium) [ sumA = sumA + pz(medium,j)*wa(medium,j); ]
               2          sumA = sumA*amu;
               2          DO k=1,kmix [
               3              cs(ii,k) = 0;
               3              DO j=1,NNE(medium) [
               4                  Z = zelem(medium,j); iz = int(Z+0.1); Z = Z*Z/sumA;
               4                  cs(ii,k) = cs(ii,k) + pz(medium,j)*Z*cs_array(i,k,iz);
               4              ]
               3              csx(k) = Log(cs(ii,k));
               3          ]
               2          call set_spline(xi_array,csx,afx,bfx,cfx,dfx,kmix);
               2          "
               2          " Integrate
               2          "
               2          cse(ii) = 0; aux = Log(ee(ii)/ap(medium));
               2          DO i_gauss = 1,ngauss [
               3              xi = log(1 - ap(medium)/ee(ii)*exp(x_gauss(i_gauss)*aux)+1e-6);
               3              res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix);
               3              cse(ii) = cse(ii) + w_gauss(i_gauss)*exp(res);
               3          ]
               2      ]
               1      nener = ilast - ifirst + 1;
               1      call set_spline(ele,cse,afe,bfe,cfe,dfe,nener);
               1      "
               1      " Now replace the PEGS cross sections "
               1      "
               1      neke = meke(medium);
               1      sigee = 1E-15; sigep = 1E-15;
               1      DO i = 1,neke [
               2          eil = (float(i) - eke0(medium))/eke1(medium); ei = exp(eil);
               2          leil = i;
               2          beta2 = ei*(ei+2*rm)/(ei+rm)**2;
               2          IF( ei <= ap(medium) ) [ sigb = 1e-30; ]
               2          ELSE [
               3              sigb = spline(eil,ele,afe,bfe,cfe,dfe,nener);
               3              sigb = sigb*log(ei/ap(medium))/beta2*rho(medium);
               3          ]
               2          $EVALUATE sigt USING esig(eil);  " sigt is the total cross section "
               2          $EVALUATE ebr1 USING ebr1(eil);  " coming from PEGS, ebr1*sigt is "
               2                                           " then the brems cross section "
               2          IF( sigt < 0 ) sigt = 0;
               2          IF( ebr1 > 1 ) ebr1 = 1;
               2          IF( ebr1 < 0 ) ebr1 = 0;
               2          IF( i > 1 ) [
               3              si_esig = si1_esig;
               3              si_ebr1 = si1_ebr1;
               3              si1_esig = sigt*(1 - ebr1) + sigb;
               3              si1_ebr1 = sigb/si1_esig;
               3              esig1(i-1,medium) = (si1_esig - si_esig)*eke1(medium);
               3              esig0(i-1,medium) = si1_esig - esig1(i-1,medium)*eil;
               3              ebr11(i-1,medium) = (si1_ebr1 - si_ebr1)*eke1(medium);
               3              ebr10(i-1,medium) = si1_ebr1 - ebr11(i-1,medium)*eil;
               3          ]
               2          ELSE [
               3              si1_esig = sigt*(1 - ebr1) + sigb;
               3              si1_ebr1 = sigb/si1_esig;
               3          ]
               2
               2          "
               2          " Positrons "
               2          "
               2          $EVALUATE sigt USING psig(eil);
               2          $EVALUATE ebr1 USING pbr1(eil);
               2          $EVALUATE ebr2 USING pbr2(eil);
               2          IF( sigt < 0 ) sigt = 0;
               2          IF( ebr1 > 1 ) ebr1 = 1;
               2          IF( ebr1 < 0 ) ebr1 = 0;
               2          IF( ebr2 > 1 ) ebr2 = 1;
               2          IF( ebr2 < 0 ) ebr2 = 0;
               2          sig_bhabha = sigt*(ebr2 - ebr1);
               2          IF( sig_bhabha < 0 ) sig_bhabha = 0;
               2          IF( i > 1 ) [
               3              si_psig = si1_psig;
               3              si_pbr1 = si1_pbr1;
               3              si_pbr2 = si1_pbr2;
               3              si1_psig = sigt*(1 - ebr1) + sigb;
               3              si1_pbr1 = sigb/si1_psig;
               3              si1_pbr2 = (sigb + sig_bhabha)/si1_psig;
               3              psig1(i-1,medium) = (si1_psig - si_psig)*eke1(medium);
               3              psig0(i-1,medium) = si1_psig - psig1(i-1,medium)*eil;
               3              pbr11(i-1,medium) = (si1_pbr1 - si_pbr1)*eke1(medium);
               3              pbr10(i-1,medium) = si1_pbr1 - pbr11(i-1,medium)*eil;
               3              pbr21(i-1,medium) = (si1_pbr2 - si_pbr2)*eke1(medium);
               3              pbr20(i-1,medium) = si1_pbr2 - pbr21(i-1,medium)*eil;
               3          ]
               2          ELSE [
               3              si1_psig = sigt*(1 - ebr1) + sigb;
               3              si1_pbr1 = sigb/si1_psig;
               3              si1_pbr2 = (sigb + sig_bhabha)/si1_psig;
               3          ]
               2          $EVALUATE ededx USING ededx(eil);
               2          sige = si1_esig/ededx;
               2          IF( sige > sigee ) sigee = sige;
               2          $EVALUATE ededx USING pdedx(eil);
               2          sige = si1_psig/ededx;
               2          IF( sige > sigep ) sigep = sige;
               2      ]
               1      esig1(neke,medium) = esig1(neke-1,medium);
               1      esig0(neke,medium) = esig0(neke-1,medium);
               1      ebr11(neke,medium) = ebr11(neke-1,medium);
               1      ebr10(neke,medium) = ebr10(neke-1,medium);
               1      psig1(neke,medium) = psig1(neke-1,medium);
               1      psig0(neke,medium) = psig0(neke-1,medium);
               1      pbr11(neke,medium) = pbr11(neke-1,medium);
               1      pbr10(neke,medium) = pbr10(neke-1,medium);
               1      pbr21(neke,medium) = pbr21(neke-1,medium);
               1      pbr20(neke,medium) = pbr20(neke-1,medium);
               1      $egs_info(*,' Max. new cross sections per energy loss: ',sigee,sigep);
               1      esig_e(medium) = sigee; psig_e(medium) = sigep;
               1      IF( sigee > esige_max ) esige_max = sigee;
               1      IF( sigep > psige_max ) psige_max = sigep;
               1
               1      "
               1      " Now prepare the arrays for brems sampling
               1      "
               1      nb_emin(medium) = energy_array(ifirst);
               1      IF( nb_emin(medium) <= ap(medium) ) [
               2          nb_emin(medium) = energy_array(ifirst+1);
               2      ]
               1      nb_emax(medium) = energy_array(ilast);
               1      nb_lemin(medium) = log(nb_emin(medium));
               1      nb_lemax(medium) = log(nb_emax(medium));
               1      nb_dle(medium) = (nb_lemax(medium) - nb_lemin(medium))/($MXBRES-1);
               1      nb_dlei(medium) = 1/nb_dle(medium);
               1      "
               1      eil = nb_lemin(medium) - nb_dle(medium);
               1      DO i=1,$MXBRES [
               2          eil = eil + nb_dle(medium); ei = exp(eil);
               2          DO ii=1,nener [
               3              IF( ei < ee(ii) ) EXIT;
               3          ]
               2          ii = ii-1;
               2          IF( ii < 1) ii = 1;
               2          IF( ii > nener-1 ) ii = nener-1;
               2          "
               2          " ple and qle are energy interpolation coefficients
               2          "
               2          ple = (eil - ele(ii))/(ele(ii+1)-ele(ii)); qle = 1 - ple;
               2          DO k=1,kmix [
               3              csx(k) = log(qle*cs(ii,k) + ple*cs(ii+1,k));
               3          ]
               2          call set_spline(xi_array,csx,afx,bfx,cfx,dfx,kmix);
               2          "
               2          " fill the abscissas for this energy
               2          "
               2          x = ap(medium)/ei; aux = -log(x);
               2          xi = log(1 - x+1e-6);
               2          res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix);
               2          nb_xdata(0,i,medium) = 0;
               2          nb_fdata(0,i,medium) = exp(res);
               2
               2          DO k=1,kmix [
               3              IF( x_array(k) > x ) EXIT;
               3          ]
               2          IF( k > kmix ) k = kmix;
               2          ndat = 0;
               2          DO j=k+1,kmix-1 [
               3              ndat = ndat+1;
               3              nb_xdata(ndat,i,medium) = log(x_array(j)/x)/aux;
               3              nb_fdata(ndat,i,medium) = exp(csx(j));
               3              IF( fool_intel_optimizer ) [
               4                  $egs_info(*,'nb_xdata(ndat,i,medium): ',
               4                          nb_xdata(ndat,i,medium));
               4              ]
               3          ]
               2          ndat = ndat+1;
               2          nb_xdata(ndat,i,medium) = 1;
               2          nb_fdata(ndat,i,medium) = exp(csx(kmix));
               2          "
               2          " Now expand the arrays by filling intermediate points
               2          " at the positions that show the maxium relative error
               2          " when using linear interpolation in x.
               2          " If arrays were allocated dynamically one could use
               2          " a certain condition to stop the iteration but in our case
               2          " memory is allocated anyway and so we use the maximum
               2          " space provided
               2          "
               2          IF( ndat >= $MXBRXS ) goto :SKIP-LOOP:;
               2          LOOP [
               3              x_max_error = 0; f_max_error = 0; k_max_error = 0;
               3              max_error = 0;
               3              DO k=0,ndat-1 [
               4                  x = 0.5*(nb_xdata(k,i,medium) + nb_xdata(k+1,i,medium));
               4                  f = 0.5*(nb_fdata(k,i,medium) + nb_fdata(k+1,i,medium));
               4                  xi = log(1 - ap(medium)/ei*exp(x*aux)+1e-6);
               4                  res = spline(xi,xi_array,afx,bfx,cfx,dfx,kmix);
               4                  res = exp(res);
               4                  error = abs(1-f/res);
               4                  IF( error > max_error ) [
               5                      x_max_error = x;
               5                      f_max_error = res;
               5                      max_error = error;
               5                      k_max_error = k;
               5                  ]
               4              ]
               3              ndat = ndat+1;
               3              DO k=ndat,k_max_error+2,-1 [
               4                  nb_xdata(k,i,medium) = nb_xdata(k-1,i,medium);
               4                  nb_fdata(k,i,medium) = nb_fdata(k-1,i,medium);
               4              ]
               3              nb_xdata(k_max_error+1,i,medium) = x_max_error;
               3              nb_fdata(k_max_error+1,i,medium) = f_max_error;
               3          ] UNTIL (ndat = $MXBRXS);
               2
               2          :SKIP-LOOP:
               2          "
               2          " Now generate the alias tables for rapid brems sampling
               2          " during run time
               2          "
               2          call prepare_alias_table($MXBRXS,nb_xdata(0,i,medium),
               2                 nb_fdata(0,i,medium),nb_wdata(1,i,medium),nb_idata(1,i,medium));
               2
               2      ]
               1  ]
               0  $egs_info(*,' ');
               0  $egs_info(*,' ');
               0  return;
               0  " Errors "
               0  :data_file_error:
               0  $egs_fatal(*,'failed to open EGSnrc data file ',$cstring(tmp1_string));
               0  return;
               0  end;
               0
1              0  %E
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  subroutine init_nrc_pair;
               0  implicit none;
               0  $declare_max_medium;
               0  ;COMIN/MEDIA,BREMPR,ELECIN,NRC-PAIR-DATA,THRESH,USEFUL,EGS-IO/;
               0  $declare_write_buffer;
               0
               0  character     nrcp_file*256, endianess*4;
               0  integer       egs_get_unit;
               0  $INTEGER      nrcp_unit, want_nrcp_unit, rec_length;
               0  $INTEGER      i, lnblnk1;
               0  $REAL         tmp, ddx, xx, Z;
               0  real*4        emin, emax;
               0  integer*4     ne, nb, ix, ie, irec, i_ele, nbb, iz;
               0  REPLACE {$cdum_size} WITH {{COMPUTE 4*($NRC-PAIR-NXX-4)-1}};
               0  character     endian, cdum($cdum_size);
               0  $LOGICAL      swap;
               0  real*4        tmp_4, tarray($NRC-PAIR-NXX);
               0  integer*4     itmp_4;
               0  character     c_4(4), ic_4(4);
               0  equivalence   (tmp_4,c_4), (itmp_4, ic_4);
               0
               0  $set_string(nrcp_file,' ');
               0  nrcp_file = $cstring(hen_house) // 'data' // $file_sep // 'pair_nrc1.data';
               0  want_nrcp_unit = 62;
               0  nrcp_unit = egs_get_unit(want_nrcp_unit);
               0  IF( nrcp_unit < 1 ) [
               1      $egs_fatal(*,'init_nrc_pair: failed to get a free fortran unit');
               1  ]
               0
               0  rec_length = $NRC-PAIR-NXX*$RECL-FACTOR;
               0  open(nrcp_unit,file=nrcp_file,form='unformatted',access='direct',
               0          status='old',recl=rec_length,err=:nrcp-open-error:);
               0  read(nrcp_unit,rec=1,err=:nrcp-read-error:) emin, emax, ne, nb, endian, cdum;
               0  IF( ichar(endian) = 0 ) [ endianess = '1234'; ] ELSE [ endianess = '4321'; ]
               0  swap = endianess.ne.$BYTE_ORDER;
               0  IF( swap ) [
               1      tmp_4 = emin; call egs_swap_4(c_4); emin = tmp_4;
               1      tmp_4 = emax; call egs_swap_4(c_4); emax = tmp_4;
               1      itmp_4 = ne; call egs_swap_4(ic_4); ne = itmp_4;
               1      itmp_4 = nb; call egs_swap_4(ic_4); nb = itmp_4;
               1  ]
               0  $egs_info('(//a,a)','Reading NRC pair data base from ',$cstring(nrcp_file));
               0  $egs_info('(a,a,a)','Data generated on a machine with ',endianess,' endianess');
               0  $egs_info('(a,a)','The endianess of this CPU is ',$BYTE_ORDER);
               0  IF( swap ) [ $egs_info('(a)','=> will need to do byte swaping'); ]
               0  $egs_info('(a,2f9.3)','Energy range of the data: ',emin,emax);
               0  IF( nb ~= $NRC-PAIR-NXX ) [
               1      $egs_fatal(*,'Inconsistent x-grid size');
               1  ]
               0  IF( ne ~= $NRC-PAIR-NEE ) [
               1      $egs_fatal(*,'Inconsistent energy grid size');
               1  ]
               0  nrcp_emin = emin; nrcp_emax = emax;
               0  nrcp_dle = log((emax-2)/(emin-2))/(ne-1); nrcp_dlei = 1/nrcp_dle;
               0
               0  nbb = nb/2; ddx = sqrt(0.5)/nbb;
               0  DO ix=0,nbb [ xx = ddx*ix; nrcp_xdata(ix+1) = xx*xx; ]
               0  do ix=nbb-1,0,-1 [ xx = ddx*ix; nrcp_xdata(nb-ix) = 1 - xx*xx; ]
               0
               0  DO medium = 1,NMED [
               1      $egs_info('(a,i4,a,$)','  medium ',medium,' ..................... ');
               1      DO ie=1,$NRC-PAIR-NEE [
               2          DO ix=1,$NRC-PAIR-NXX [ nrcp_fdata(ix,ie,medium) = 0; ]
               2      ]
               1      DO i_ele=1,NNE(medium) [
               2          Z = ZELEM(medium,i_ele); iz = int(Z+0.5);
               2          tmp = PZ(medium,i_ele)*Z*Z;
               2          irec = (iz-1)*ne + 2;
               2          DO ie=1,$NRC-PAIR-NEE [
               3              read(nrcp_unit,rec=irec,err=:nrcp-read-error:) tarray;
               3              DO ix=1,$NRC-PAIR-NXX [
               4                  tmp_4 = tarray(ix);
               4                  IF( swap ) [ call egs_swap_4(c_4); ]
               4                  nrcp_fdata(ix,ie,medium)=nrcp_fdata(ix,ie,medium)+tmp*tmp_4;
               4              ]
               3              irec = irec + 1;
               3          ]
               2      ]
               1      DO ie=1,$NRC-PAIR-NEE [
               2          call prepare_alias_table(nb-1,nrcp_xdata,nrcp_fdata(1,ie,medium),
               2                  nrcp_wdata(1,ie,medium),nrcp_idata(1,ie,medium));
               2      ]
               1
               1      $egs_info('(a)',' done');
               1
               1  ]
               0  $egs_info(*,' ');
               0  close(nrcp_unit);
               0  return;
               0
               0  :nrcp-open-error:;
               0  $egs_fatal(*,'Failed to open NRC pair data file');
               0
               0  :nrcp-read-error:;
               0  $egs_fatal(*,'I/O error while reading NRC pair data file');
               0
               0  end;
               0
1              0  %E
               0  "******************************************************************"
               0  "                               NATIONAL RESEARCH COUNCIL OF CANADA"
               0  "                                                                  "
               0  subroutine vmc_electron(ircode);
               0  "                                                                  "
               0  "******************************************************************"
               0  "   This subroutine performs condensed history simulation of       "
               0  "   electron/positron transport according to VMC                   "
               0  "                                                                  "
               0  "   Version 1.0   Iwan Kawrakow       Initial coding               "
               0  "                                     coding is in EGSnrc style    "
               0  "                                     for maximum compatibility    "
               0  "                                     with EGSnrc user codes       "
               0  "******************************************************************"
               0
               0  $IMPLICIT-NONE;
               0
               0  ;COMIN/EGS-IO/;
               0
               0  $INTEGER ircode;
               0  $egs_fatal('(//a//)',
               0  ' ********* VMC Transport option not in this distribution ****** ');
               0  end;
               0
               0  " Subroutine versions of the random number generator "
               0  " Included here because it makes life easier for using the EGSnrc RNG"
               0  " from within the C-interface. "
               0  subroutine egs_init_default_rng;
               0  ;COMIN/RANDOM/;
               0  $RNG-DEFAULT-INITIALIZATION;
               0  return; end;
               0
               0  subroutine egs_init_rng(arg1,arg2);
               0  $INTEGER arg1,arg2;
               0  ;COMIN/RANDOM/;
               0  $declare_write_buffer;
               0  $INITIALIZE RNG USING arg1 AND arg2;
               0  return; end;
               0
               0  subroutine egs_get_rndm(ran);
               0  $REAL ran;
               0  ;COMIN/RANDOM/;
               0  $RANDOMSET ran;
               0  return; end;
               0
               0  subroutine egs_get_rndm_array(n,rarray);
               0  $INTEGER n;
               0  $REAL    rarray(*);
               0  ;COMIN/RANDOM/;
               0  $REAL    rtmp;
               0  $INTEGER i;
               0  IF( n < 1 ) return;
               0  DO i=1,n [
               1      $RANDOMSET rtmp; rarray(i) = rtmp;
               1  ]
               0  return; end;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  "**************************************************************************"
               0  "Init EII. This subroutine is called from HATCH after all media are known, "
               0  "threshold energies and interpolation data have been initialized.          "
               0  "**************************************************************************"
               0  subroutine eii_init;
               0  "**************************************************************************"
               0  implicit none;
               0  $COMIN-EII-INIT;
               0  $INTEGER imed,iele,ish,nsh,iZ,j,i,itmp,nskip,nbin,ii,nsh_tot,iii,k;
               0  $INTEGER jj,jjj;
               0  integer*4 lnblnk1;
               0  $INTEGER tmp_array($MXELEMENT);
               0  $INTEGER want_eii_unit,eii_unit,eii_out,egs_open_file;
               0  integer  egs_get_unit;
               0  $REAL    e_eii_min,emax,fmax,aux_array($N_EII_BINS);
               0  $REAL    sigo,loge,tau,beta2,p2,uwm,Wmax;
               0  $REAL    ss_0, ss_1, sh_0, sh_1, aux, av_e, con_med, dedx_old, sigm_old;
               0  $REAL    dedx,e,sig,sigm,wbrem,sum_a,sum_z,sum_pz,sum_wa,Ec,Ecc;
               0  $REAL    sum_sh,sum_occn,U,sum_sigma,sum_dedx;
               0  $REAL    sigma,sigma_old,wbrem_old,sig_j,de;
               0  $INTEGER lloge;
               0  $LOGICAL check_it,is_monotone,getd;
               0  $REAL    sigma_max;
               0  character eii_file*128;
               0  character*512 toUpper;
               0  $INTEGER occn_numbers(4);
               0  $declare_write_buffer;
               0  $REAL    cons;
               0  parameter (cons = 0.153536); " 2*Pi*Re^2*rm/u "
               0  data     occn_numbers/2,2,2,4/;
               0
               0  DO j=1,$MXELEMENT [ eii_nshells(j) = 0; ]
               0  DO j=1,$MXMED [ eii_nsh(j) = 0; ]
               0  IF( eii_flag = 0 ) [ return; ]
               0
               0  $need_relaxation_data(getd);
               0  IF( ~getd )[
               1    $egs_fatal('(/a,/a,/a,/a)',
               1            ' In subroutine eii_init: ',
               1            '   Scattering off bound electrons creates atomic vacancies,',
               1            '   potentially starting an atomic relaxation cascade. ',
               1            '   Please turn ON atomic relaxations.');
               1  ]
               0
               0
               0
               0
               0  e_eii_min = 1e30;
               0  DO imed = 1,nmed [
               1      IF( ae(imed)-rm < e_eii_min ) e_eii_min = ae(imed) - rm;
               1      IF( ap(imed) < e_eii_min ) e_eii_min = ap(imed);
               1  ]
               0  $egs_info(*,' ');
               0  $egs_info(*,'eii_init: minimum threshold energy found: ',e_eii_min);
               0
               0
               0
               0
               0  DO imed = 1,nmed [
               1      DO iele = 1,nne(imed) [
               2          iZ = int(zelem(imed,iele)+0.5);
               2          IF( eii_nshells(iZ) = 0 ) [
               3              nsh = 0;
               3              DO ish=1,4 [
               4                  IF( binding_energies(ish,iZ) > e_eii_min ) nsh = nsh+1;
               4              ]
               3              eii_nshells(iZ) = nsh;
               3          ]
               2      ]
               1  ]
               0
               0
               0  nsh = 0;
               0  DO iZ=1,$MXELEMENT [
               1      nsh = nsh + eii_nshells(iZ);
               1  ]
               0  IF( nsh = 0 ) [
               1      $egs_info(*,'*** EII requested but no shells with binding energies ');
               1      $egs_info(*,'    above the specified threshold found');
               1      $egs_info(*,'    => turning off EII');
               1      eii_flag = 0;
               1  ]
               0  IF( nsh > $MAX_EII_SHELLS ) [
               1      $egs_info(*,'*** Number of shells with binding energies greater than ');
               1      $egs_info(*,'    the specified thresholds is ',nsh);
               1      $egs_info(*,'    This is more than the allocated arrays can hold');
               1      $egs_fatal(*,'    Increase the macro $MAX_EII_SHELLS and retry');
               1  ]
               0  $egs_info(*,'eii_init: number of shells to simulate EII: ',nsh);
               0  nsh_tot = nsh;
               0  tmp_array(1) = 0;
               0  DO j=2,$MXELEMENT [ tmp_array(j) = tmp_array(j-1) + eii_nshells(j-1); ]
               0
               0
               0  DO imed=1,nmed [
               1      nsh = 0;
               1      DO iele=1,nne(imed) [
               2          iZ = int(zelem(imed,iele)+0.5);
               2          eii_no(imed,iele) = eii_nshells(iZ);
               2          nsh = nsh + eii_nshells(iZ);
               2          IF( eii_nshells(iZ) > 0 ) [ eii_first(imed,iele) = tmp_array(iZ) + 1; ]
               2          ELSE [ eii_first(imed,iele) = 0; ]
               2      ]
               1      eii_nsh(imed) = nsh;
               1  ]
               0
               0
               0  $set_string(eii_file,' ');
               0  eii_file = $cstring(hen_house) // 'data' // $file_sep // 'eii_'//
               0             $cstring(eii_xfile) //'.data';
               0  want_eii_unit = 62;
               0  eii_unit = egs_get_unit(want_eii_unit);
               0  IF( eii_unit < 1 ) [
               1      $egs_fatal(*,'eii_init: failed to get a free Fortran I/O unit');
               1  ]
               0  open(eii_unit,file=$cstring(eii_file),status='old',err=:no-eii-file:);
               0  $egs_info('(//a,a)','Opened EII data file ',$cstring(eii_file));
               0  $egs_info('(a,$)',' eii_init: reading EII data ... ');
               0  read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) nskip;
               0  DO j=1,nskip [
               1      read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:);
               1  ]
               0  read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) emax,nbin;
               0  IF( nbin ~= $N_EII_BINS ) [
               1      $egs_fatal(*,'Inconsistent EII data file');
               1  ]
               0  IF (xsec_out = 1)[
               1     eii_out = egs_open_file(93,0,1,'.eiixsec');
               1  ]
               0  ii = 0;
               0  DO j=1,$MXELEMENT [
               1      read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) iZ,nsh;
               1      IF (xsec_out = 1 & eii_nshells(iZ) > 0)[
               2       write(eii_out,*) '=================================';
               2       write(eii_out,'(a,i3)') 'EII xsections for element Z = ',iZ;
               2       write(eii_out,*) '=================================';
               2      ]
               1      IF( nsh < eii_nshells(iZ) ) [
               2          $egs_info(*,'EII data file has data for ',nsh,' shells for element ');
               2          $egs_info(*,iZ,' but according');
               2          $egs_info(*,'to binding energies and thresholds ',eii_nshells(iZ));
               2          $egs_info(*,'shells are required');
               2          $egs_fatal(*,'This is a fatal error.');
               2      ]
               1      DO ish=1,nsh [
               2          read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:) fmax;
               2          read(eii_unit,*,err=:eii-reading-error:,end=:eii-reading-error:)
               2             aux_array;
               2          "Scale L-shell EII xsections by eii_L_factor. Defaults to 1."
               2          IF (ish>1 & ish < 5) [fmax = fmax*eii_L_factor;]
               2          IF( ish <= eii_nshells(iZ) ) [
               3              IF (xsec_out = 1)[
               4                IF(ish = 1)[
               5                 write(eii_out,'(a,f10.2,a)')
               5                 'K-shell sigma_max = ',fmax,' b/atom';
               5                ]
               4                ELSEIF (ish = 2)[
               5                 write(eii_out,'(a,f9.2,a)')
               5                 '=> LI-shell sigma_max = ',fmax,' b/atom';
               5                ]
               4                ELSEIF (ish = 3)[
               5                 write(eii_out,'(a,f8.2,a)')
               5                 '=> LII-shell sigma_max = ',fmax,' b/atom';
               5                ]
               4                ELSEIF (ish = 4)[
               5                 write(eii_out,'(a,f8.2,a)')
               5                 '=> LIII-shell sigma_max = ',fmax,' b/atom';
               5                ]
               4                ELSE[ write(eii_out,*) '=> Wrong number of shells!';]
               4                write(eii_out,*) '   E/keV     sigma/(b/atom)';
               4                write(eii_out,*) '---------------------------';
               4              ]
               3              ii = ii+1; eii_z(ii) = iZ; eii_sh(ii) = ish;
               3              eii_a(ii) = nbin;
               3              eii_a(ii) = eii_a(ii)/log(emax/binding_energies(ish,iZ));
               3              eii_b(ii) = 1 - eii_a(ii)*log(binding_energies(ish,iZ));
               3              DO k=1,nbin [
               4                  IF( k > 1 ) [ sigo = fmax*aux_array(k-1); ]
               4                  ELSE [ sigo = 0; ]
               4                  loge = (k - eii_b(ii))/eii_a(ii); iii = nbin*(ii-1)+k;
               4                  eii_xsection_a(iii) = (fmax*aux_array(k)-sigo)*eii_a(ii);
               4                  eii_xsection_b(iii) = sigo - eii_xsection_a(iii)*loge;
               4                  IF (xsec_out = 1)[
               5                     write(eii_out,'(f12.2,2X,10f9.2)')
               5                     Exp((k+1-eii_b(ii))/eii_a(ii))*1000.0,fmax*aux_array(k);
               5                  ]
               4              ]
               3          ]
               2      ]
               1      IF( ii = nsh_tot ) [ EXIT; ]
               1  ]
               0  close(eii_unit);
               0  IF (xsec_out = 1)[ close(eii_out); ]
               0  $egs_info(*,' OK '); $egs_info(*,' ');
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  DO imed = 1,nmed [
               1      Ec = ae(imed) - rm; Ecc = min(Ec,ap(imed));
               1      /sum_z,sum_pz,sum_a,sum_wa/=0;
               1      DO iele=1,nne(imed) [
               2          sum_z = sum_z + pz(imed,iele)*zelem(imed,iele);
               2          sum_pz = sum_pz + pz(imed,iele);
               2          sum_wa = sum_wa + rhoz(imed,iele);
               2          sum_a = sum_a + pz(imed,iele)*wa(imed,iele);
               2      ]
               1      con_med = rho(imed)/1.6605655/sum_a;
               1      eii_cons(imed) = con_med;
               1      IF( eii_nsh(imed) > 0 ) [
               2          is_monotone = .true.;
               2          sigma_max = 0;
               2          DO j=1,meke(imed) [
               3              loge = (j - eke0(imed))/eke1(imed); e = Exp(loge);
               3              tau = e/rm; beta2 = tau*(tau+2)/(tau+1)**2;
               3              p2 = 2*rm*tau*(tau+2);
               3              lloge = j;
               3              medium = imed;
               3              $EVALUATE dedx USING ededx(loge);
               3              IF( e > ap(medium) | e > 2*Ec ) [
               4                  $EVALUATE sig USING esig(loge);
               4              ] ELSE [ sig = 0; ]
               3              IF( e > 2*Ec ) [
               4                  $EVALUATE wbrem USING ebr1(loge);
               4                  sigm = sig*(1-wbrem);
               4              ] ELSE [ sigm = 0; wbrem = 1; ]
               3              /sum_occn,sum_sigma,sum_dedx/=0;
               3              DO iele=1,nne(imed) [
               4                  iZ = int(zelem(imed,iele)+0.5);
               4                  sum_sh = 0;
               4                  DO ish = 1,eii_no(imed,iele) [
               5                      "jj is the shell index in the list of EII shells "
               5                      jj = eii_first(imed,iele) + ish - 1;
               5                      "jjj is shell type (1 = K, 2 = LI, 3 = LII, etc.)
               5                      jjj = eii_sh(jj); U = binding_energies(jjj,iZ);
               5                      Wmax = (e+U)/2; uwm = U/Wmax;
               5                      "IF( Uj >= Ecc ) sum_sh = sum_sh + occn_numbers(jjj);
               5                      IF( U < e & U > Ecc ) [
               6                          " At this energy interactions with this shell will "
               6                          " be done using the EII differential x-section "
               6                          sum_sh = sum_sh + occn_numbers(jjj);
               6                          ss_0 = 2*(log(p2/U)-uwm**3*log(p2/Wmax)-
               6                            (beta2+0.833333)*(1-uwm**3))/3/U;
               6                          sh_0 = ((1-uwm)*(1+uwm/(2-uwm))+U*(Wmax-U)/(e+rm)**2
               6                            - (2*tau+1)/(tau+1)**2*uwm/2*log((2-uwm)/uwm))/U;
               6                          ss_1 = log(p2/U)-uwm**2*log(p2/Wmax)-
               6                            (beta2+1)*(1-uwm**2);
               6                          sh_1 = log(Wmax/U/(2-uwm))+2*(Wmax-U)/(2*Wmax-U)
               6                            +(Wmax**2-U**2)/(e+rm)**2/2
               6                            -(2*tau+1)/(tau+1)**2*log((2*Wmax-U)/Wmax);
               6                          av_E = (ss_1 + sh_1)/(ss_0 + sh_0);
               6                            "av_E is the average energy lost in a collision"
               6                            "with this shell"
               6                          i = eii_a(jjj)*loge + eii_b(jjj);
               6                          i = (jj-1)*$N_EII_BINS + i;
               6                          sig_j = eii_xsection_a(i)*loge + eii_xsection_b(i);
               6                          sig_j = sig_j*pz(imed,iele)*con_med;
               6                          sum_sigma = sum_sigma + sig_j;
               6                          sum_dedx = sum_dedx + sig_j*av_E;
               6                      ]
               5                  ]
               4                  sum_occn = sum_occn + sum_sh*pz(imed,iele);
               4              ]
               3              sigm = sigm + sum_sigma;
               3              dedx = dedx - sum_dedx;
               3              aux = Ec/e;
               3              IF( e > 2*Ec ) [
               4                  sigo = cons*sum_occn*rho(imed)/(beta2*Ec)*(
               4                          (1-2*aux)*(1+aux/(1-aux)+(tau/(tau+1))**2*aux/2)-
               4                          (2*tau+1)/(tau+1)**2*aux*log((1-aux)/aux))/sum_a;
               4                  de = cons*sum_occn*rho(imed)/beta2*(
               4                    log(0.25/aux/(1-aux))+(1-2*aux)/(1-aux)+
               4                    (tau/(tau+1))**2*(1-4*aux*aux)/8-
               4                    (2*tau+1)/(tau+1)**2*log(2*(1-aux)))/sum_a;
               4                  sigm = sigm - sigo;
               4                  "sigm = sig*(1-wbrem)*(1-sum_occn/sum_z);
               4                  dedx = dedx + de;
               4              ]
               3              sigma = sigm + wbrem*sig;
               3              IF( sigma/dedx > sigma_max ) sigma_max = sigma/dedx;
               3              IF( sigma > 0 ) [ wbrem = wbrem*sig/sigma; ]
               3              ELSE [ wbrem = 1; ]
               3              IF( j > 1 ) [
               4                  ededx1(j-1,imed) = (dedx - dedx_old)*eke1(imed);
               4                  ededx0(j-1,imed) = dedx - ededx1(j-1,imed)*loge;
               4                  esig1(j-1,imed) = (sigma - sigma_old)*eke1(imed);
               4                  esig0(j-1,imed) = sigma - esig1(j-1,imed)*loge;
               4                  ebr11(j-1,imed) = (wbrem - wbrem_old)*eke1(imed);
               4                  ebr10(j-1,imed) = wbrem - ebr11(j-1,imed)*loge;
               4                  IF( sigma/dedx < sigma_old/dedx_old ) is_monotone = .false.;
               4              ]
               3              dedx_old = dedx; sigm_old = sigm;
               3              sigma_old = sigma; wbrem_old = wbrem;
               3          ]
               2          ededx1(meke(imed),imed) = ededx1(meke(imed)-1,imed);
               2          ededx0(meke(imed),imed) = ededx0(meke(imed)-1,imed);
               2          esig1(meke(imed),imed) = esig1(meke(imed)-1,imed);
               2          esig0(meke(imed),imed) = esig0(meke(imed)-1,imed);
               2          ebr11(meke(imed),imed) = ebr11(meke(imed)-1,imed);
               2          ebr10(meke(imed),imed) = ebr10(meke(imed)-1,imed);
               2          $egs_info(*,'eii_init: for medium ',imed,' adjusted sige = ',
               2                  sigma_max,' monotone = ',is_monotone);
               2          sig_ismonotone(0,imed) = is_monotone;
               2          esig_e(imed) = sigma_max;
               2      ]
               1  ]
               0  return;
               0
               0  :eii-reading-error:
               0  $egs_fatal(*,'I/O error while reading EII data');
               0
               0  :no-eii-file:
               0  $egs_fatal('(//a,a,/a,/a/)','Failed to open EII data file ',$cstring(eii_file),
               0            'Make sure file exists in your $HEN_HOUSE/data directory!',
               0            '****BEWARE of case sensitive file names!!!');
               0
               0  return; end;
               0
               0  "*****************************************************************************"
               0
               0  subroutine eii_sample(ish,iZ,Uj);
               0  implicit none;
               0  $INTEGER ish,iZ;
               0  $REAL    Uj;
               0
               0  $COMIN-EII-SAMPLE;
               0
               0  $REAL T,tau,tau1,tau12,tau2,p2,beta2,c1,c2,Wmax,xmax,fm_s,fm_h,prob_s,prob;
               0  $REAL r1,r2,r3,wx,wxx,aux,frej;
               0  real*8 peie,pese1,pese2,dcosth,h1;
               0  $INTEGER iarg;
               0  $REAL    eta,cphi,sphi;
               0  $INTEGER np_save,ip,j;
               0  $DEFINE-VARIABLES-FOR-SELECT-AZIMUTHAL-ANGLE;
               0
               0
               0  peie = e(np);
               0  T = peie - rm; tau = T/rm; tau1 = tau+1;
               0  tau12 = tau1*tau1; tau2 = tau*tau; p2 = tau2 + 2*tau;
               0  beta2 = p2/tau12;
               0  "c1 = tau2/tau12; "
               0  Wmax = 0.5*(T+Uj); xmax = Uj/Wmax;
               0  c1 = (Wmax/peie)**2;
               0  c2 = (2*tau+1)/tau12;
               0  fm_s = log(rmt2*p2/Uj) - beta2 - 0.5;
               0  prob_s = 0.66666667*fm_s*(1+xmax+xmax*xmax);
               0  "fm_h = 1 + c1 - c2;"
               0  fm_h = 2 + c1 - c2;
               0  IF( fm_h < 1 ) fm_h = 1;
               0  prob = fm_h + prob_s;
               0
               0  LOOP [
               1      $RANDOMSET r1; $RANDOMSET r2; $RANDOMSET r3;
               1      IF( r1*prob < fm_h ) [ "Use the hard collision cross section "
               2          wx = 1/(r2*xmax+1-r2); wxx = wx*xmax; aux = wxx/(2-wxx);
               2          frej = (1 + aux*(aux-c2)+c1*wxx*wxx)/fm_h;
               2      ] ELSE [               "Use the soft collision cross section "
               2          wx = 1/(r2*xmax**3+1-r2)**0.333333333;
               2          frej = 1 - log(wx)/fm_s;
               2      ]
               1  ] UNTIL ( r3 < frej );
               0
               0  wx = wx*Uj;
               0
               0
               0  h1 = (peie + prm)/T; pese1 = peie - wx;
               0  e(np) = pese1;
               0  dcosth = h1*(pese1-prm)/(pese1+prm);
               0  sinthe = dsqrt(1-dcosth); costhe = dsqrt(dcosth);
               0  call uphi(2,1);
               0
               0  pese2 = wx - Uj + prm;
               0  edep_local = 0;
               0  IF( pese2 > ae(medium) ) [
               1      $CHECK-STACK(np+1,'eii_sample');
               1      np = np+1; e(np) = pese2;
               1      dcosth = h1*(pese2-prm)/(pese2+prm);
               1      sinthe = -dsqrt(1-dcosth); costhe = dsqrt(dcosth);
               1      iq(np) = -1; call uphi(3,2);
               1      edep = 0;
               1  ] ELSE [
               1      edep = wx - Uj;
               1      edep_local = edep;
               1      $AUSCALL($SELECTRONA);
               1  ]
               0  "ish ranges from 1 to 4 for K,L1,L2,L3 shells"
               0  call relax(Uj,ish,iZ);
               0
               0  IF( edep > 0 ) [ $AUSCALL($PHOTXAUS); ]
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  return; end;
               0
               0  "============================================================================"
               0  subroutine egs_scale_photon_xsection(imed,fac,which);
               0  "============================================================================"
               0  "
               0  "  Scale the photon cross section 'which' by factor fac for medium imed.
               0  "  which = 0 for all cross sections
               0  "        = 1 for Rayleigh scattering
               0  "        = 2 for Compton scattering
               0  "        = 3 for Pair production
               0  "        = 4 for photo-absorption
               0  "  If imed = 0, scaling is done for all media.
               0  "============================================================================"
               0  implicit none;
               0  $INTEGER imed,which;
               0  $REAL    fac;
               0  $declare_max_medium;
               0  ;COMIN/MEDIA,PHOTIN,EGS-IO/;
               0  $INTEGER ifirst,ilast,medium,j;
               0  $LOGICAL has_r;
               0  $REAL    gle,gmfp,gbr1,gbr2,cohfac,aux,gmfp_old,gbr1_old,gbr2_old,cohfac_old;
               0  character*8 strings(5);
               0  data       strings/'photon','Rayleigh','Compton','pair','photo'/;
               0
               0  IF( which < 0 | which > 4 ) [ return; ]
               0  IF( imed > 0 & imed <= nmed ) [ ifirst = imed; ilast = imed; ]
               0  ELSE [ ifirst = 1; ilast = nmed; ]
               0  IF( which = 1 ) [
               1      has_r = .false.;
               1      DO medium = ifirst, ilast [
               2          IF( iraylm(medium) = 1 ) [ has_r = .true.; ]
               2      ]
               1      IF( ~has_r ) return;
               1  ]
               0  $egs_info(*,' ');
               0  DO medium = ifirst,ilast [
               1
               1      $egs_info('(a,a,a,i3,a,f9.5)',
               1              'Scaling ',strings(which+1),' x-section data for medium',
               1              medium,' with ',fac);
               1
               1      DO j = 1,mge(medium) [
               2
               2          gle = (j - ge0(medium))/ge1(medium);
               2          gmfp = gmfp0(j,medium) + gmfp1(j,medium)*gle;
               2          gbr1 = gbr10(j,medium) + gbr11(j,medium)*gle;
               2          gbr2 = gbr20(j,medium) + gbr21(j,medium)*gle;
               2          IF( iraylm(medium) = 1 ) [
               3              cohfac = cohe0(j,medium) + cohe1(j,medium)*gle;
               3          ] ELSE [ cohfac = 1; ]
               2          IF( which = 0 ) [ gmfp = gmfp/fac; ]
               2          ELSE IF( which = 1 ) [ cohfac = cohfac/(fac*(1-cohfac)+cohfac); ]
               2          ELSE [
               3              IF( which = 2 ) [
               4                  aux = fac*(gbr2-gbr1) + gbr1 + 1 - gbr2;
               4                  gbr2 = (gbr1 + fac*(gbr2-gbr1))/aux; gbr1 = gbr1/aux;
               4              ]
               3              ELSE IF( which = 3 ) [
               4                  aux = fac*gbr1 + 1 - gbr1;
               4                  gbr2 = (fac*gbr1 + gbr2-gbr1)/aux; gbr1 = fac*gbr1/aux;
               4              ]
               3              ELSE [
               4                  aux = gbr2 + fac*(1-gbr2);
               4                  gbr1 = gbr1/aux; gbr2 = gbr2/aux;
               4              ]
               3              gmfp = gmfp/aux;
               3              cohfac = cohfac*aux/(aux*cohfac + 1 - cohfac);
               3          ]
               2          IF( j > 1 ) [
               3              gmfp1(j-1,medium) = (gmfp - gmfp_old)*ge1(medium);
               3              gmfp0(j-1,medium) = gmfp - gmfp1(j-1,medium)*gle;
               3              gbr11(j-1,medium) = (gbr1 - gbr1_old)*ge1(medium);
               3              gbr10(j-1,medium) = gbr1 - gbr11(j-1,medium)*gle;
               3              gbr21(j-1,medium) = (gbr2 - gbr2_old)*ge1(medium);
               3              gbr20(j-1,medium) = gbr2 - gbr21(j-1,medium)*gle;
               3              cohe1(j-1,medium) = (cohfac - cohfac_old)*ge1(medium);
               3              cohe0(j-1,medium) = cohfac - cohe1(j-1,medium)*gle;
               3          ]
               2          gmfp_old = gmfp; gbr1_old = gbr1; gbr2_old = gbr2; cohfac_old = cohfac;
               2
               2      ]
               1      gmfp1(mge(medium),medium) = gmfp1(mge(medium)-1,medium);
               1      gmfp0(mge(medium),medium) = gmfp0(mge(medium)-1,medium);
               1      gbr11(mge(medium),medium) = gbr11(mge(medium)-1,medium);
               1      gbr10(mge(medium),medium) = gbr10(mge(medium)-1,medium);
               1      gbr21(mge(medium),medium) = gbr21(mge(medium)-1,medium);
               1      gbr20(mge(medium),medium) = gbr20(mge(medium)-1,medium);
               1      cohe1(mge(medium),medium) = cohe1(mge(medium)-1,medium);
               1      cohe0(mge(medium),medium) = cohe0(mge(medium)-1,medium);
               1  ]
               0
               0  return; end;
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  REPLACE {$OPEN-UNIT(#,#,#);} WITH {
            {  0      {P1} = {P2};
            {  0      {P1} = egs_get_unit({P1});
            {  0      IF( {P1} < 1 ) [
            {  0          $egs_fatal(*,
            {  0           'egs_init_user_photon: failed to get a free Fortran I/O unit');
            {  0      ]
            {  0      tmp_string = {P3};
            {  0      open({P1},file={P3},status='old',err=:no-user-data-file:);
            {  0  };
               0
               0  REPLACE {$MXINPUT} WITH {2000};
               0  REPLACE {$MXBCINP} WITH {183};
               0
               0  "============================================================================="
               0  "Ali:photonuc, 1 line"
               0   subroutine egs_init_user_photon(prefix,comp_prefix,photonuc_prefix,out);
               0  "subroutine egs_init_user_photon(prefix,comp_prefix,out);"
               0  "============================================================================="
               0  implicit none;
               0  $declare_max_medium;
               0  character*(*) prefix, comp_prefix,
               0  "Ali:photonuc, 1 line"
               0                photonuc_prefix;
               0  $INTEGER      out;
               0  ;COMIN/BREMPR,EDGE,EGS-IO,MEDIA,PHOTIN,THRESH,COMPTON-DATA,X-OPTIONS/;
               0  $INTEGER   lnblnk1,egs_get_unit,medium,
               0             photo_unit,pair_unit,rayleigh_unit,triplet_unit,
               0             ounit,egs_open_file,compton_unit,
               0  "Ali:photonuc, 1 line"
               0             photonuc_unit;
               0  $INTEGER   nge,sorted($MXEL),i,j,k,iz,iz_old,ndat;
               0  $REAL      z_sorted($MXEL),pz_sorted($MXEL);
               0  $REAL      sig_photo($MXGE),sig_pair($MXGE),sig_triplet($MXGE),
               0             sig_rayleigh($MXGE),sig_compton($MXGE);
               0  $REAL      sigma,cohe,gmfp,gbr1,gbr2,sig_KN,gle,e,sig_p;
               0  $REAL      cohe_old,gmfp_old,gbr1_old,gbr2_old,
               0  "Ali:photonuc, 3 lines"
               0             sig_photonuc($MXGE),
               0             photonuc,
               0             photonuc_old;
               0
               0  $REAL      etmp($MXINPUT),ftmp($MXINPUT);
               0  $REAL      sumZ,sumA,con1,con2,egs_KN_sigma0;
               0  $REAL      bc_emin,bc_emax,bc_dle,bc_data($MXBCINP),bc_tmp($MXBCINP),bcf,aj;
               0  $INTEGER   bc_ne;
               0  $LOGICAL   input_compton_data,
               0  "Ali:photonuc, 1 line"
               0             input_photonuc_data;
               0  character  data_dir*128,photo_file*140,pair_file*140,rayleigh_file*144,
               0             triplet_file*142,tmp_string*144,compton_file*144,
               0  "Ali:photonuc, 1 line"
               0             photonuc_file*144;
               0
               0  $egs_info('(/a$)','(Re)-initializing photon cross sections');
               0  $egs_info('(a,a/)',' with files from the series: ',
               0        prefix(:lnblnk1(prefix)));
               0
               0  $egs_info('(a,a)',' Compton cross sections: ',$cstring(comp_prefix));
               0
               0  "Ali:photonuc, 1 block"
               0  IF(iphotonuc = 1) [
               1   $egs_info('(a,a)',' Photonuclear cross sections: ',
               1   $cstring(photonuc_prefix));
               1   input_photonuc_data = .false.;
               1   IF(lnblnk1(photonuc_prefix) > 0 & photonuc_prefix(1:7) ~= 'default') [
               2     input_photonuc_data = .true.;
               2   ]
               1  ]
               0
               0  input_compton_data = .false.;
               0  IF( ibcmp(1) > 1 & lnblnk1(comp_prefix) > 0 ) [
               1      IF( comp_prefix(1:7) ~= 'default' ) input_compton_data = .true.;
               1  ]
               0  data_dir = $cstring(hen_house) // 'data' // $file_sep;
               0  photo_file = $cstring(data_dir) // $cstring(prefix) // '_photo.data';
               0  pair_file = $cstring(data_dir) // $cstring(prefix) // '_pair.data';
               0  triplet_file = $cstring(data_dir) // $cstring(prefix) // '_triplet.data';
               0  rayleigh_file = $cstring(data_dir) // $cstring(prefix) // '_rayleigh.data';
               0  IF( input_compton_data ) [
               1      compton_file = $cstring(data_dir) // $cstring(comp_prefix) //
               1                     '_compton.data';
               1  ]
               0  ELSE [
               1      compton_file = $cstring(data_dir) // 'compton_sigma.data';
               1  ]
               0  "Ali: I moved this info line from inside the IF statement
               0  " because it's useful to print the cross section file either way
               0  $egs_info('(a,a)',' Using Compton cross sections from ',
               0            $cstring(compton_file));
               0
               0  "Ali:photonuc, 1 block"
               0  IF(iphotonuc = 1) [
               1   IF( input_photonuc_data ) [
               2      photonuc_file = $cstring(data_dir) // $cstring(photonuc_prefix) //
               2                      '_photonuc.data';
               2   ]
               1   ELSE [
               2      photonuc_file = $cstring(data_dir) // 'iaea_photonuc.data';
               2   ]
               1   $egs_info('(a,a)',' Using photonuclear cross sections from ',
               1    $cstring(photonuc_file));
               1  ]
               0
               0  $OPEN-UNIT(photo_unit,83,photo_file);
               0  $OPEN-UNIT(pair_unit,84,pair_file);
               0  $OPEN-UNIT(triplet_unit,85,triplet_file);
               0  $OPEN-UNIT(rayleigh_unit,86,rayleigh_file);
               0  IF( ibcmp(1) > 1 ) [ $OPEN-UNIT(compton_unit,88,compton_file); ]
               0  " Note: ibcmp > 1 means the user wants to use Bound Compton scattering "
               0  "       without rejections. For this we have to use the actual bound   "
               0  "       Compton scattering cross section, which is now available in a  "
               0  "       file called bound_compton.data (the file actually contains the "
               0  "       ratio of the Bound Compton to the KN cross section).           "
               0  "       Because this option is not available on a region by region     "
               0  "       basis, we just need to check ibcmp(1)                          "
               0  "Ali:photonuc, 1 line"
               0  IF( iphotonuc = 1 ) [ $OPEN-UNIT(photonuc_unit,89,photonuc_file); ]
               0
               0  IF( out = 1 ) [
               1      ounit = egs_open_file(87,0,1,'.xsections');
               1      write(ounit,'(/a,a,a)') 'Photon cross sections initialized from ',
               1         $cstring(prefix),' data files';
               1      write(ounit,'(a,/)')
               1  '============================================================================';
               1      write(ounit,'(a,/)') 'Grid energies and cross sections are output';
               1  "Ali:photonuc, 1 block"
               1      IF(iphotonuc = 1) [
               2         write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a,t79,a)')
               2           'Energy',' GMFP(cm) ',' Pair ','Compton',' GMFP(cm) ',
               2           ' GMFP(cm) ';
               2         write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a,t79,a/)')
               2           '(MeV)','no Rayleigh','(fraction)','(fraction)','with Rayleigh',
               2           'w/ Ray + photnuc';
               2      ]
               1      ELSE[
               2         write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a)')
               2              'Energy',' GMFP(cm) ',' Pair ','Compton',' GMFP(cm) ';
               2         write(ounit,'(5x,a,t19,a,t34,a,t49,a,t64,a/)')
               2              '(MeV)','no Rayleigh','(fraction)','(fraction)','with Rayleigh';
               2     ]
               1  ]
               0
               0  DO iz=1,100 [
               1      read(photo_unit,*) ndat;
               1      read(photo_unit,*) (etmp(k),ftmp(k),k=1,ndat);
               1      k = 0;
               1      DO j=ndat,2,-1 [
               2          IF( etmp(j)-etmp(j-1) < 1e-5 ) [
               3              k = k+1;
               3              IF ( k <= $MXSHXSEC )[
               4                 binding_energies(k,iz) = exp(etmp(j));
               4              ]
               3              ELSE[
               4                $egs_fatal('(i3,a,i3,//a)',
               4                           k,' binding energies read exceeding array size of',
               4                           $MXSHXSEC,'Increase $MXSHXSEC in egsnrc.macros!');
               4              ]
               3              IF( ~eadl_relax & k >= 4 ) EXIT;
               3          ]
               2      ]
               1  ]
               0
               0  IF (mcdf_pe_xsections)[call egs_read_shellwise_pe();]
               0
               0  DO medium = 1,nmed [
               1
               1      mge(medium) = $MXGE; nge = $MXGE;
               1      ge1(medium) = nge-1; ge1(medium) = ge1(medium)/log(up(medium)/ap(medium));
               1      ge0(medium) = 1 - ge1(medium)*log(ap(medium));
               1
               1      $egs_info('(a,i3,a,$)',' Working on medium ',medium,' ... ');
               1      IF( out = 1 ) [
               2          write(ounit,'(/,2x,a,i3,a,24a1/)') 'Medium ',medium,': ',
               2            (media(k,medium),k=1,24);
               2      ]
               1      /sumZ,sumA/ = 0;
               1      DO i=1,nne(medium) [
               2          z_sorted(i) = zelem(medium,i);
               2          sumZ = sumZ + pz(medium,i)*zelem(medium,i);
               2          sumA = sumA + pz(medium,i)*wa(medium,i);
               2      ]
               1      con1 = sumZ*rho(medium)/(sumA*1.6605655);
               1      con2 = rho(medium)/(sumA*1.6605655);
               1      call egs_heap_sort(nne(medium),z_sorted,sorted);
               1      DO i=1,nne(medium) [ pz_sorted(i) = pz(medium,sorted(i)); ]
               1
               1      IF (mcdf_pe_xsections)[
               2         call egsi_get_shell_data(medium,nge,nne(medium),z_sorted,pz_sorted,
               2                                  ge1(medium),ge0(medium),sig_photo);
               2      ]
               1      ELSE[
               2         call egsi_get_data(0,photo_unit,nge,nne(medium),z_sorted,pz_sorted,
               2                         ge1(medium),ge0(medium),sig_photo);
               2      ]
               1      call egsi_get_data(0,rayleigh_unit,nge,nne(medium),z_sorted,pz_sorted,
               1                         ge1(medium),ge0(medium),sig_rayleigh);
               1      call egsi_get_data(1,pair_unit,nge,nne(medium),z_sorted,pz_sorted,
               1                         ge1(medium),ge0(medium),sig_pair);
               1      call egsi_get_data(2,triplet_unit,nge,nne(medium),z_sorted,pz_sorted,
               1                         ge1(medium),ge0(medium),sig_triplet);
               1  "Ali:photonuc, 1 block"
               1      IF( iphotonuc = 1 ) [
               2        call egsi_get_data(3,photonuc_unit,nge,nne(medium),z_sorted,pz_sorted,
               2                          ge1(medium),ge0(medium),sig_photonuc);
               2      ]
               1
               1      IF( ibcmp(1) > 1 ) [
               2          "Get the bound compton cross section data"
               2          IF( input_compton_data ) [
               3              call egsi_get_data(0,compton_unit,nge,nne(medium),
               3                      z_sorted,pz_sorted,ge1(medium),ge0(medium),
               3                      sig_compton);
               3          ]
               2          ELSE [
               3              rewind(compton_unit);
               3              read(compton_unit,*) bc_emin,bc_emax,bc_ne;
               3              IF( bc_ne > $MXBCINP ) [
               4                $egs_fatal(*,'Number of input Compton data exceeds array size');
               4              ]
               3              "write(6,*) 'bc emin,emax,ne = ',bc_emin,bc_emax,bc_ne;
               3              bc_dle = log(bc_emax/bc_emin)/(bc_ne-1);
               3              DO j=1,bc_ne [ bc_data(j) = 0; ]
               3              iz_old = 1;
               3              DO i=1,nne(medium) [
               4                  iz = int(z_sorted(i)+0.5);
               4                  "write(6,*) ' reading bc data for ',iz;
               4                  DO j=iz_old,iz [ read(compton_unit,*) (bc_tmp(k),k=1,bc_ne); ]
               4                  DO j=1,bc_ne [
               5                      bc_data(j)=bc_data(j)+pz_sorted(i)*z_sorted(i)*bc_tmp(j);
               5                  ]
               4                  iz_old = iz+1;
               4              ]
               3              DO j=1,bc_ne [ bc_data(j)=log(bc_data(j)/sumZ); ]
               3          ]
               2      ]
               1
               1
               1      call egs_init_rayleigh(medium,sig_rayleigh);
               1
               1      DO i=1,nge [
               2
               2          gle = (i - ge0(medium))/ge1(medium); e = exp(gle);
               2          sig_KN = sumZ*egs_KN_sigma0(e);
               2          IF( ibcmp(1) > 1 ) [
               3              IF( input_compton_data ) [
               4                  sig_KN = sig_compton(i);
               4              ]
               3              ELSE [
               4                  "Apply the bound Compton correction to sig_KN"
               4                  IF( e <= bc_emin ) [ bcf = exp(bc_data(1)); ]
               4                  ELSE IF( e < bc_emax ) [
               5                      aj = 1 + log(e/bc_emin)/bc_dle;
               5                      j = int(aj); aj = aj - j;
               5                      bcf = exp(bc_data(j)*(1-aj) + bc_data(j+1)*aj);
               5                  ]
               4                  ELSE [ bcf = 1; ]
               4                  sig_KN = sig_KN*bcf;
               4                  "write(6,*) 'e = ',e,' bcf = ',bcf;
               4              ]
               3          ]
               2          sig_p  = sig_pair(i) + sig_triplet(i);
               2          sigma  = sig_KN + sig_p + sig_photo(i);
               2          gmfp   = 1/(sigma*con2);
               2          gbr1   = sig_p/sigma;
               2          gbr2   = gbr1 + sig_KN/sigma;
               2          cohe   = sigma/(sig_rayleigh(i) + sigma);
               2  "Ali:photonuc, 1 line"
               2          photonuc = sigma/(sig_photonuc(i) + sigma);
               2
               2          IF( out = 1 ) [
               3  "Ali:photonuc, 1 block"
               3             IF(iphotonucm(medium) = 1) [
               4                write(ounit,'(6(1pe15.6))') e,gmfp,gbr1,gbr2-gbr1,
               4                gmfp*cohe,gmfp*cohe*photonuc;
               4             ]
               3             ELSE[
               4                write(ounit,'(5(1pe15.6))') e,gmfp,gbr1,gbr2-gbr1,gmfp*cohe;
               4             ]
               3          ]
               2          IF( i > 1 ) [
               3              gmfp1(i-1,medium) = (gmfp - gmfp_old)*ge1(medium);
               3              gmfp0(i-1,medium) =  gmfp - gmfp1(i-1,medium)*gle;
               3              gbr11(i-1,medium) = (gbr1 - gbr1_old)*ge1(medium);
               3              gbr10(i-1,medium) =  gbr1 - gbr11(i-1,medium)*gle;
               3              gbr21(i-1,medium) = (gbr2 - gbr2_old)*ge1(medium);
               3              gbr20(i-1,medium) =  gbr2 - gbr21(i-1,medium)*gle;
               3              cohe1(i-1,medium) = (cohe - cohe_old)*ge1(medium);
               3              cohe0(i-1,medium) =  cohe - cohe1(i-1,medium)*gle;
               3  "Ali:photonuc, 2 lines"
               3              photonuc1(i-1,medium) = (photonuc - photonuc_old)*ge1(medium);
               3              photonuc0(i-1,medium) =  photonuc - photonuc1(i-1,medium)*gle;
               3          ]
               2          gmfp_old = gmfp; gbr1_old = gbr1; gbr2_old = gbr2; cohe_old = cohe;
               2  "Ali:photonuc, 1 line"
               2          photonuc_old = photonuc;
               2      ]
               1
               1      gmfp1(nge,medium) = gmfp1(nge-1,medium);
               1      gmfp0(nge,medium) = gmfp - gmfp1(nge,medium)*gle;
               1      gbr11(nge,medium) = gbr11(nge-1,medium);
               1      gbr10(nge,medium) = gbr1 - gbr11(nge,medium)*gle;
               1      gbr21(nge,medium) = gbr21(nge-1,medium);
               1      gbr20(nge,medium) = gbr2 - gbr21(nge,medium)*gle;
               1      cohe1(nge,medium) = cohe1(nge-1,medium);
               1      cohe0(nge,medium) = cohe - cohe1(nge,medium)*gle;
               1  "Ali:photonuc, 2 lines"
               1      photonuc1(nge,medium) = photonuc1(nge-1,medium);
               1      photonuc0(nge,medium) = photonuc - photonuc1(nge,medium)*gle;
               1
               1      $egs_info('(a)','OK');
               1  ]
               0
               0  close(photo_unit); close(pair_unit);
               0  close(triplet_unit); close(rayleigh_unit);
               0  "Ali:photonuc, 1 line"
               0  IF( iphotonuc = 1 ) [ close(photonuc_unit);]
               0  IF( ibcmp(1) > 1 ) [ close(compton_unit);]
               0  IF( out = 1 )      [ close(ounit); ]
               0  return;
               0
               0  :no-user-data-file:;
               0  $egs_fatal('(//a,a)','Failed to open data file ',$cstring(tmp_string));
               0
               0  return; end;
               0
               0
               0  subroutine egs_init_rayleigh(medium,sig_rayleigh);
               0
               0
               0
               0
               0
               0
               0
               0
               0  $IMPLICIT-NONE;
               0  $declare_max_medium;
               0  ;COMIN/THRESH,          "for threshold energies"
               0         EGS-IO, MEDIA, MISC,PHOTIN,BREMPR,
               0         rayleigh_inputs,rayleigh_sampling/;
               0
               0  $REAL xval($MXRAYFF),aff($MXRAYFF,$MXELEMENT),ff($MXRAYFF,$MXMED);
               0  $REAL xsc, fsc;
               0  $REAL sig_rayleigh($MXGE), pe_array($MXGE,$MXMED);
               0  $REAL e,egs_rayleigh_sigma,gmfp,gle,conv,dle,dlei,sumA;
               0  $REAL totRayleigh2,pzmin;
               0  $REAL emin, emax;
               0  $INTEGER i,j,k,ff_unit, egs_get_unit, ne;
               0  $INTEGER lnblnk1, EOF, nff, medium, ncustom;
               0  character dummy*24, afac_file*128, ff_file*128;
               0
               0  IF (iraylm(medium)=0)[return;]"Rayleigh option not requested"
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  ncustom=0;write(dummy,'(24a1)')(media(j,medium),j=1,24);ff_file=' ';
               0  DO i=1,$MXMED[IF(lnblnk1(iray_ff_file(i))~=0)[ncustom = ncustom + 1;]]
               0  DO i=1,ncustom[IF (dummy(:lnblnk1(dummy)) = iray_ff_media(i))[
               2     ff_file = iray_ff_file(i);
               2  ];]
               0
               0
               0  ff_unit = egs_get_unit(0);
               0  IF( ff_unit < 1 ) [
               1     $egs_fatal(*,
               1     'egs_init_rayleigh: failed to get a free Fortran I/O unit');
               1  ]
               0
               0
               0
               0
               0
               0
               0  IF ( lnblnk1(ff_file) > 0) ["custom FF requested"
               1       open(ff_unit,file=$cstring(ff_file),
               1            status='old',err=:no-ff-file:);
               1       GOTO :read-ff:;
               1       :no-ff-file:
               1       $egs_fatal('(2a)','egs_init_rayleigh: failed to open custom ff file ',
               1               $cstring(ff_file));
               1       :read-ff:
               1       $egs_info('(/2a)','Opened custom ff file ',$cstring(ff_file));
               1       " read Rayleigh molecular form factor data from a file"
               1       " which is given as Fmol/sqrt(MW) hence no need to compute"
               1       " MW to get the xsections in cm-1. See conv variable below"
               1       j = 0;
               1       LOOP [
               2         j = j + 1;
               2         read(ff_unit,*,IOSTAT = EOF) xsc, fsc;
               2         IF (EOF < 0) EXIT;
               2         IF (j <= $MXRAYFF)[xgrid(j,medium)=xsc;ff(j,medium)=fsc;]
               2       ] REPEAT
               1       nff = j-1;
               1       IF (nff > $MXRAYFF)[
               2          $egs_fatal('(a,/,a,i5,a,i5,/,a)',
               2          'subroutine egs_init_rayleigh: form factors size too small!!',
               2          '$XRAYFF =  ', $MXRAYFF,', and need to be ',nff,
               2          ' and try again!!!');
               2       ]
               1       "To avoid log(0) = -INF, x=1E-4 corresponds ~ 0.014 deg for 10 keV"
               1       "and much less for higher energies"
               1       IF( xgrid(1,medium) < 1e-6 ) xgrid(1,medium) = 1e-4;
               1       write(*,*) '\n  -> ', nff, ' values of mol. ff read!';
               1
               1       "Since MW already included in the molecular FF,"
               1       "must multiply by sumA which is MW for compound"
               1       "or unity for mixtures."
               1       sumA = 0.0;
               1       DO j=1,nne(medium)[sumA=sumA+PZ(medium,j)*WA(medium,j);]
               1       DO j=1,MGE(medium) [
               2         gle=(j-GE0(medium))/GE1(medium);e=exp(gle);
               2         sig_rayleigh(j)=egs_rayleigh_sigma(medium,e,nff,
               2                         xgrid(1,medium),ff(1,medium))*sumA;
               2       ]
               1  ]
               0  ELSE[
               1       $set_string(afac_file,' ');
               1       afac_file = $cstring(hen_house)//'pegs4'//$file_sep//'pgs4form.dat';
               1       open(ff_unit,file=$cstring(afac_file),
               1         status='old',err=:no-afac-file:);
               1       GOTO :read-afac:;
               1       :no-afac-file:
               1       $egs_fatal('(2a)','egs_init_rayleigh: failed to open atomic ff file',
               1               $cstring(afac_file));
               1       :read-afac:
               1       " read Rayleigh atomic form factor data from a file"
               1       read(ff_unit,*) xval, aff;
               1       "calculate form factor using independent atom model"
               1       DO i=1,$MXRAYFF[
               2         ff(i,medium) = 0.0; xgrid(i,medium)=xval(i);
               2         DO j=1,nne(medium)[
               3          ff(i,medium)=ff(i,medium)+PZ(medium,j)*aff(i,int(zelem(medium,j)))**2;
               3         ]
               2         ff(i,medium) = sqrt(ff(i,medium));
               2       ]
               1       nff = $MXRAYFF;
               1       "To avoid log(0) = -INF, x=1E-4 corresponds ~ 0.014 deg for 10 keV"
               1       "and much less for higher energies"
               1       IF( xgrid(1,medium) < 1e-6 ) xgrid(1,medium) = 1e-4;
               1       $egs_info('(/a,i4,a)','  -> ', nff, ' atomic ff values computed!');
               1  ]
               0  close(ff_unit);
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0
               0  emin = exp((1 - ge0(medium))/ge1(medium));
               0  emax = exp((mge(medium) - ge0(medium))/ge1(medium));
               0  call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium),
               0                               mge(medium),emin,emax,
               0                               pe_array(1,medium),$RAYCDFSIZE,
               0                               fcum(1,medium),i_array(1,medium),
               0                               b_array(1,medium),c_array(1,medium));
               0
               0
               0  ne=MGE(medium);dle=log(up(medium)/ap(medium))/(ne-1);
               0  dlei=1/dle;
               0  DO i=1,ne-1 [
               1
               1
               1
               1
               1
               1
               1     gle = (i - ge0(medium))/ge1(medium);
               1     pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*ge1(medium);
               1     pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle;
               1  ]
               0  pmax0(ne,medium)=pmax0(ne-1,medium);pmax1(ne,medium)=pmax1(ne-1,medium);
               0
               0  return; end;
               0
               0
               0  subroutine egs_init_rayleigh_sampling(medium);
               0
               0
               0
               0
               0
               0  $IMPLICIT-NONE;
               0  $declare_max_medium;
               0  ;COMIN/THRESH,          "for threshold energies"
               0         EGS-IO, MEDIA, MISC,PHOTIN,BREMPR,
               0         rayleigh_inputs,rayleigh_sampling/;
               0
               0  $REAL xval($MXRAYFF),aff($MXRAYFF,$MXELEMENT),ff($MXRAYFF,$MXMED);
               0  $REAL xsc, fsc;
               0  $REAL sig_rayleigh($MXGE), pe_array($MXGE,$MXMED);
               0  $REAL e,egs_rayleigh_sigma,gmfp,gle,conv,dle,dlei,sumA;
               0  $REAL totRayleigh2,pzmin;
               0  $REAL emin, emax;
               0  $INTEGER i,j,k,ff_unit, egs_get_unit, ne;
               0  $INTEGER lnblnk1, EOF, nff, medium, ncustom;
               0  character dummy*24, afac_file*128, ff_file*128;
               0
               0  IF (iraylm(medium)=0)[return;]"Rayleigh option not requested"
               0
               0
               0  ff_unit = egs_get_unit(0);
               0  IF( ff_unit < 1 ) [
               1     $egs_fatal(*,
               1     'egs_init_rayleigh: failed to get a free Fortran I/O unit');
               1  ]
               0
               0  $set_string(afac_file,' ');
               0  afac_file = $cstring(hen_house)//'pegs4'//$file_sep//'pgs4form.dat';
               0  open(ff_unit,file=$cstring(afac_file),status='old',err=:no-afac-file:);
               0  GOTO :read-afac:;
               0  :no-afac-file:
               0  $egs_fatal('(2a)',
               0          'egs_init_rayleigh_sampling: failed to open atomic ff file ',
               0          $cstring(afac_file));
               0  :read-afac:
               0  " read Rayleigh atomic form factor data from a file"
               0  read(ff_unit,*) xval, aff;
               0  "calculate form factor using independent atom model"
               0  DO i=1,$MXRAYFF[
               1    ff(i,medium) = 0.0; xgrid(i,medium)=xval(i);
               1    DO j=1,nne(medium)[
               2     ff(i,medium)=ff(i,medium)+PZ(medium,j)*aff(i,int(zelem(medium,j)))**2;
               2    ]
               1    ff(i,medium) = sqrt(ff(i,medium));
               1  ]
               0  nff = $MXRAYFF;
               0  "To avoid log(0) = -INF, x=1E-4 corresponds ~ 0.014 deg for 10 keV"
               0  "and much less for higher energies"
               0  IF( xgrid(1,medium) < 1e-6 ) xgrid(1,medium) = 1e-4;
               0  "write(*,*) '\n  -> ', nff, ' atomic ff values computed!';
               0  $egs_info('(/a,i4,a)','  -> ', nff, ' atomic ff values computed!');
               0
               0  close(ff_unit);
               0
               0  emin = exp((1 - ge0(medium))/ge1(medium));
               0  emax = exp((mge(medium) - ge0(medium))/ge1(medium));
               0  call prepare_rayleigh_data(nff,xgrid(1,medium),ff(1,medium),
               0                               mge(medium),emin,emax,
               0                               pe_array(1,medium),$RAYCDFSIZE,
               0                               fcum(1,medium),i_array(1,medium),
               0                               b_array(1,medium),c_array(1,medium));
               0
               0
               0  ne=MGE(medium);
               0  DO i=1,ne-1 [
               1     gle = (i - ge0(medium))/ge1(medium);
               1     pmax1(i,medium)=(pe_array(i+1,medium)-pe_array(i,medium))*ge1(medium);
               1     pmax0(i,medium)=pe_array(i,medium)-pmax1(i,medium)*gle;
               1  ]
               0  pmax0(ne,medium)=pmax0(ne-1,medium);pmax1(ne,medium)=pmax1(ne-1,medium);
               0
               0  return; end;
               0
               0
               0
               0
               0  $REAL function egs_rayleigh_sigma(imed,E,ndat,x,f);
               0  $IMPLICIT-NONE;
               0  $INTEGER i, j, k,imed, ndat;
               0  $REAL hc2,conv,b,hc;
               0  parameter (hc  = 0.0123984768438,  "[Armstrong]*[MeV]"
               0             hc2 = 0.0001537222280); "h*c squared"
               0  $REAL x($MXRAYFF), f($MXRAYFF), zero, E, xmax;
               0  real*8 x1,x2,pow_x1,pow_x2,raysig,C,C2,f1,f2;
               0  C=2.*hc2/(E*E);C2=C*C;xmax=E/hc;
               0  egs_rayleigh_sigma = 0.0;
               0  DO i=1,ndat-1[
               1     IF (x(i) = 0.0) x(i) = zero();IF (x(i+1) = 0.0) x(i+1) = zero();
               1     IF (f(i) = 0.0) f(i) = zero(); IF (f(i+1) = 0.0) f(i+1) = zero();
               1     b = log(f(i+1)/f(i))/log(x(i+1)/x(i));
               1     x1=x(i);x2=x(i+1);IF(x2 > xmax) [x2=xmax;]
               1     pow_x1=x1**(2*b);pow_x2=x2**(2*b);
               1     raysig = pow_x2*(x2**2/(b+1)-(C*x2**4)/(b+2)+(C2*x2**6)/(2*b+6));
               1     raysig = raysig - pow_x1*(x1**2/(b+1)-(C*x1**4)/(b+2)+(C2*x1**6)/(2*b+6));
               1     raysig = raysig*f(i)*f(i)/pow_x1;
               1     egs_rayleigh_sigma = egs_rayleigh_sigma + raysig;
               1     IF(x(i+1)>xmax)[EXIT;]"exit loop"
               1  ]
               0
               0
               0
               0  egs_rayleigh_sigma = 0.49893439187842413747*C*egs_rayleigh_sigma;"in barns"
               0  return;
               0  end;
               0
               0
               0
               0  subroutine egs_rayleigh_sampling(medium,e,gle,lgle,costhe,sinthe);
               0  $IMPLICIT-NONE;
               0  $declare_max_medium;
               0  real*8 e;
               0  $REAL gle,costhe,sinthe,pmax,xv,xmax,csqthe;
               0  $REAL rnnray1,rnnray0,hc_i,twice_hc2,dwi;
               0  parameter(hc_i=80.65506856998,      "h*c inverse"
               0            twice_hc2=0.000307444456);"2*(hc)^2"
               0            "h*c=0.0123984768438 [Armstrong]*[MeV]"
               0  $INTEGER lgle,ib,ibin,medium, trials;
               0  ;COMIN/RANDOM,rayleigh_sampling/;
               0  dwi = $RAYCDFSIZE-1;
               0  $EVALUATE pmax USING pmax(gle);xmax = hc_i*e;
               0  LOOP [
               1      $RANDOMSET rnnray1;
               1      LOOP [
               2          $RANDOMSET rnnray0; rnnray0 = rnnray0*pmax;
               2          ibin = 1 + rnnray0*dwi;
               2          ib = i_array(ibin,medium);
               2          IF( i_array(ibin+1,medium) > ib ) [
               3            LOOP [IF(rnnray0<fcum(ib+1,medium)) EXIT; ib=ib+1;]
               3          ]
               2          rnnray0 = (rnnray0 - fcum(ib,medium))*c_array(ib,medium);
               2          xv = xgrid(ib,medium)*exp(log(1+rnnray0)*b_array(ib,medium));
               2      ] UNTIL (xv < xmax);
               1      xv = xv/e;
               1      costhe = 1 - twice_hc2*xv*xv;csqthe=costhe*costhe;
               1  ] UNTIL ( 2*rnnray1 < 1 + csqthe );
               0  sinthe=sqrt(1.0-csqthe);
               0  return;
               0  end;
               0
               0
               0
               0  subroutine prepare_rayleigh_data(ndat,x,f,
               0                                   ne,emin,emax,pe_array,
               0                                   ncbin,fcum,i_array,
               0                                   b_array,c_array);
               0  $IMPLICIT-NONE;
               0
               0
               0  $INTEGER    ndat;         " number of F data points "
               0  $REAL       x(ndat),      " x values of F data "
               0              f(ndat);      " F data "
               0
               0
               0  $INTEGER    ne;           " number of energy bins "
               0  $REAL       emin,         " minimum photon energy (i.e. AP(medium))"
               0              emax,         " maximum photon energy (i.e. UP(medium))"
               0              pe_array(ne); " integral over F^2 from 0 to xmax(E)    "
               0                            " i.e., pe_array(E) = fcum(xmax(E))      "
               0
               0
               0
               0  $INTEGER    ncbin;          " number of cumulative bins (input)"
               0  $REAL       fcum(ndat);     " cumulative distribution (output)"
               0  $INTEGER    i_array(ncbin); " original data bin in which the i'th "
               0                              " cumulative bin edge falls.          "
               0
               0
               0  $REAL       b_array(ndat),  " F interpolation coefficient "
               0              c_array(ndat);  " needed for sampling at run time "
               0
               0  $REAL zero;
               0
               0  real*8 sum0,a,b,x1,x2,pow_x1,pow_x2,dle,e,xmax,
               0         anorm,anorm1,anorm2,w,dw,xold,t,aux;
               0  $INTEGER i,j,k,ibin;
               0
               0  ;COMIN/USEFUL/;
               0
               0  write(*,'(a$)') '      preparing data for Rayleigh sampling ... ';
               0
               0
               0  DO i=1,ndat [IF (f(i) = 0.0) f(i) = zero();]
               0
               0
               0
               0
               0
               0
               0  sum0=0; fcum(1)=0;
               0  DO i=1,ndat-1 [
               1      b = log(f(i+1)/f(i))/log(x(i+1)/x(i)); b_array(i) = b;
               1      x1 = x(i); x2 = x(i+1);
               1      pow_x1 = x1**(2*b); pow_x2 = x2**(2*b);
               1      sum0=sum0+f(i)*f(i)*(x2*x2*pow_x2-x1*x1*pow_x1)/((1+b)*pow_x1);
               1      fcum(i+1) = sum0;
               1  ]
               0
               0
               0
               0
               0
               0
               0
               0
               0  dle = log(emax/emin)/(ne-1); i = 1;
               0  DO j=1,ne [
               1      e = emin*exp(dle*(j-1)); xmax = 20.607544d0*2*e/prm;
               1      DO k=i,ndat-1 [
               2          IF( xmax >= x(k) & xmax < x(k+1) ) EXIT;
               2      ]
               1      i = k; b = b_array(i);
               1      x1 = x(i); x2 = xmax;
               1      pow_x1 = x1**(2*b); pow_x2 = x2**(2*b);
               1      pe_array(j) = fcum(i) +
               1        f(i)*f(i)*(x2*x2*pow_x2-x1*x1*pow_x1)/((1+b)*pow_x1);
               1  ]
               0  i_array(ncbin) = i;
               0
               0
               0
               0
               0
               0
               0
               0
               0  anorm = 1d0/sqrt(pe_array(ne));
               0  anorm1 = 1.005d0/pe_array(ne);
               0  anorm2 = 1d0/pe_array(ne);
               0  DO j=1,ne [
               1      pe_array(j) = pe_array(j)*anorm1;
               1      IF( pe_array(j) > 1 ) pe_array(j) = 1;
               1  ]
               0  DO j=1,ndat [
               1      f(j) = f(j)*anorm; fcum(j) = fcum(j)*anorm2;
               1      c_array(j) = (1+b_array(j))/(x(j)*f(j))**2;
               1  ]
               0
               0
               0
               0
               0
               0
               0  dw = 1d0/(ncbin-1);
               0  xold = x(1); ibin = 1;
               0  b = b_array(1);
               0  pow_x1 = x(1)**(2*b);
               0  i_array(1) = 1;
               0  DO i=2,ncbin-1 [
               1      w = dw;
               1      LOOP [
               2          x1 = xold; x2 = x(ibin+1);
               2          t = x1*x1*x1**(2*b);
               2          pow_x2 = x2**(2*b);
               2          aux=f(ibin)*f(ibin)*(x2*x2*pow_x2-t)/((1+b)*pow_x1);
               2          IF( aux > w ) [
               3              xold = exp(log(t+w*(1+b)*pow_x1/f(ibin)/f(ibin))/(2+2*b));
               3              i_array(i) = ibin;
               3              EXIT;
               3          ]
               2          w = w - aux; xold = x2; ibin = ibin+1;
               2          b = b_array(ibin); pow_x1 = xold**(2*b);
               2      ]
               1  ]
               0
               0
               0
               0
               0
               0
               0  DO j=1,ndat [ b_array(j) = 0.5/(1 + b_array(j)); ]
               0
               0
               0  write(*,'(a /)') 'done';
               0
               0  return; end;
               0
               0  "============================================================================="
               0  $REAL function egs_KN_sigma0(e);
               0  "=========================================================================="
               0  implicit none;
               0  $REAL    e;
               0  $REAL    con,ko,c1,c2,c3,eps1,eps2;
               0  data     con/0.1274783851/;
               0  ;COMIN/USEFUL/;
               0  ko = e/prm;
               0  IF( ko < 0.01 ) [
               1      egs_KN_sigma0 = 8.*con/3.*(1-ko*(2-ko*(5.2-13.3*ko)))/prm;
               1      return;
               1  ]
               0  c1 = 1./(ko*ko); c2 = 1. - 2*(1+ko)*c1; c3 = (1+2*ko)*c1;
               0  eps2 = 1; eps1 = 1./(1+2*ko);
               0  egs_KN_sigma0 = (c1*(1./eps1-1./eps2)+c2*log(eps2/eps1)+eps2*(c3+0.5*eps2)-
               0                  eps1*(c3+0.5*eps1))/e*con;
               0  return; end;
               0
               0  "============================================================================="
               0  $REAL function egs_KN_sigma1(e);
               0  "=========================================================================="
               0  implicit none;
               0  $REAL    e;
               0  $REAL    con,ko,c1,c2,c3,eps1,eps2;
               0  data     con/0.1274783851/;
               0  ;COMIN/USEFUL/;
               0  ko = e/prm; c1 = 1./(ko*ko); c2 = 1. - 2*(1+ko)*c1; c3 = (1+2*ko)*c1;
               0  eps2 = 1; eps1 = 1./(1+2*ko);
               0  egs_KN_sigma1 = c1*(1./eps1-1./eps2);
               0  egs_KN_sigma1 = egs_KN_sigma1 + log(eps2/eps1)*(c2 - c1) - c2*(eps2-eps1);
               0  egs_KN_sigma1 = egs_KN_sigma1 + c3*(eps2-eps1)*(1-0.5*(eps1+eps2));
               0  egs_KN_sigma1 = egs_KN_sigma1 +
               0           (eps2-eps1)*(0.5*(eps1+eps2)-(eps1*eps1+eps2*eps2+eps1*eps2)/3);
               0  egs_KN_sigma1 = egs_KN_sigma1*con;
               0  return; end;
               0
               0  "============================================================================="
               0  subroutine egsi_get_data(flag,iunit,n,ne,zsorted,pz_sorted,ge1,ge0,data);
               0  "=========================================================================="
               0  implicit none;
               0  COMIN/EGS-IO/;
               0  $REAL    eth;
               0  $INTEGER flag,iunit,n,ne;
               0  $REAL    ge1,ge0,zsorted(*),pz_sorted(*),data(*);
               0  $REAL    etmp($MXINPUT),ftmp($MXINPUT);
               0  $REAL    gle,sig,p,e;
               0  $INTEGER i,j,k,kk,iz,iz_old,ndat,iiz;
               0
               0  ;COMIN/USEFUL/;
               0
               0  "Ali:photonuc. The whole routine is commented out and re-written
               0  "to accommodate reading photonuclear cross sections. A copy of the
               0  "commented original routine is at the bottom.
               0  " flag = 0: photoelectric, Rayleigh, Compton
               0  " flag = 1: pair
               0  " flag = 2: triplet
               0  " flag = 3: photonuclear
               0
               0  rewind(iunit);
               0  iz_old = 0;
               0  DO k=1,n [ data(k) = 0; ]
               0  DO i=1,ne [
               1      iiz = int(zsorted(i)+0.5);
               1      DO iz=iz_old+1,iiz [
               2          read(iunit,*,err=:user-data-failure:) ndat;
               2          IF( ndat > $MXINPUT ) [
               3              $egs_fatal(*,'Too many input data points. Max. is ',$MXINPUT);
               3          ]
               2          IF( flag = 0 | flag = 3) [
               3              read(iunit,*,err=:user-data-failure:) (etmp(k),ftmp(k),k=1,ndat);
               3          ]
               2          ELSE [
               3              read(iunit,*,err=:user-data-failure:) (etmp(k+1),ftmp(k+1),
               3                  k=1,ndat);
               3              IF( flag = 1 ) [ eth = 2*rm; ] ELSE [ eth = 4*rm; ]
               3              ndat = ndat + 1;
               3              DO k=2,ndat [
               4                  ftmp(k) = ftmp(k) - 3*log(1-eth/exp(etmp(k)));
               4              ]
               3              ftmp(1) = ftmp(2); etmp(1) = log(eth);
               3          ]
               2      ]
               1      iz_old = iiz;
               1      DO k=1,n [
               2          gle = (k - ge0)/ge1; e = exp(gle);
               2          IF( gle < etmp(1) | gle >= etmp(ndat) ) [
               3              IF( flag = 0 ) [
               4                  $egs_fatal(*,'Energy ',exp(gle),
               4                     ' is outside the available data range of ',
               4                     exp(etmp(1)),exp(etmp(ndat)));
               4              ]
               3              ELSEIF (flag = 1 | flag = 2) [
               4                  IF( gle < etmp(1) ) [ sig = 0; ]
               4                  ELSE [ sig = exp(ftmp(ndat)); ]
               4              ]
               3              ELSE [ "photonuclear, zero it before and after
               4               sig = 0;
               4              ]
               3          ] ELSE [
               3              DO kk=1,ndat-1 [
               4                  IF( gle >= etmp(kk) & gle < etmp(kk+1) ) EXIT;
               4              ]
               3              IF( flag ~= 3) ["log/log interpolation"
               4                 p = (gle - etmp(kk))/(etmp(kk+1) - etmp(kk));
               4                 sig = exp(p*ftmp(kk+1) + (1-p)*ftmp(kk));
               4              ]
               3              ELSE["lin/lin interpolation for photonuc"
               4                 p = (e - exp(etmp(kk)))/(exp(etmp(kk+1)) - exp(etmp(kk)));
               4                 sig = p*exp(ftmp(kk+1)) + (1-p)*exp(ftmp(kk));
               4              ]
               3          ]
               2          IF( (flag = 1 | flag = 2) & e > eth ) sig = sig*(1-eth/e)**3;
               2          data(k) = data(k) + pz_sorted(i)*sig;
               2      ]
               1  ]
               0
               0  return;
               0
               0  :user-data-failure:;
               0  $egs_fatal(*,'Error while reading user photon cross sections from unit ',
               0       iunit);
               0
               0  return; end;
               0
               0
               0
               0
               0
               0
               0
               0  "============================================================================="
               0  subroutine egsi_get_shell_data(imed,n,ne,zsorted,pz_sorted,ge1,ge0,data);
               0  "=========================================================================="
               0  implicit none;
               0  $declare_max_medium;
               0  ;COMIN/EGS-IO,BREMPR,USEFUL,MEDIA,PE-SHELL-DATA/;
               0  $INTEGER n,   "number of data points requested"
               0           ne,  "number of elements in medium"
               0           ndat;"number of data points from original grid"
               0  $REAL    ge1,ge0,zsorted(*),pz_sorted(*),data(*);
               0  $REAL    sigma($MXNE),sigmaMedium;
               0  "$INTEGER sorted(*);
               0  real*4    etmp($MXINPUT),ftmp($MXINPUT);
               0  real*4    gle,sig,p;
               0  $INTEGER i,j,k,kk,iz,zpos,imed;
               0
               0  DO k=1,n  [ data(k)  = 0;]
               0  DO k=1,ne [ sigma(k) = 0;]
               0  DO i=1,ne [
               1      iz = int(zsorted(i)+0.5);
               1      zpos = pe_zpos(iz); ndat = pe_nge(zpos);
               1      "Total cross sections for a given element"
               1      "on initial energy grid"
               1      DO k=1,ndat[
               2         pe_elem_prob(k,i,imed) = pz_sorted(i)*pe_xsection(k,zpos,0);
               2         "etmp(k) = log(pe_energy(k,zpos)); Done in egs_read_shellwise_pe
               2         etmp(k) = pe_energy(k,zpos);
               2         ftmp(k) = log(pe_xsection(k,zpos,0));
               2      ]
               1      "Total cross sections for a given element"
               1      "on requested energy grid"
               1      DO k=1,n [
               2          gle = (k - ge0)/ge1;
               2          IF( gle < etmp(1) | gle >= etmp(ndat) ) [
               3              $egs_fatal(*,'egsi_get_shell_data: Energy ',exp(gle),
               3                           ' is outside the available data range of ',
               3                           exp(etmp(1)),exp(etmp(ndat)));
               3          ] ELSE [
               3              "Find energy interval gle falls in"
               3              DO kk=1,ndat-1 [
               4                  IF( gle >= etmp(kk) & gle < etmp(kk+1) ) EXIT;
               4              ]
               3              "log/log interpolation"
               3              p = (gle - etmp(kk))/(etmp(kk+1) - etmp(kk));
               3              sig = exp(p*ftmp(kk+1) + (1-p)*ftmp(kk));
               3          ]
               2          data(k) = data(k) + pz_sorted(i)*sig;
               2          "data(k) = data(k) + pz(imed,sorted(i))*sig;
               2      ]
               1  ]
               0  "Normalize elemental cross section to medium cross section"
               0  "Prepare for log/log interpolation"
               0  DO i=1,ne [
               1     iz = int(zsorted(i)+0.5);
               1     zpos = pe_zpos(iz); ndat = pe_nge(zpos);
               1     DO k=1,ndat[
               2        sig = sigmaMedium(imed,pe_energy(k,zpos));
               2        pe_elem_prob(k,i,imed) = log(pe_elem_prob(k,i,imed)/sig);
               2     ]
               1  ]
               0
               0  return; end;
               0
               0
               0
               0
               0
               0
               0  $REAL function sigmaMedium(imed, logE);
               0
               0  implicit none;
               0  $declare_max_medium;
               0  ;COMIN/BREMPR,PE-SHELL-DATA/;
               0  $REAL logE, slope, sigma;
               0  $INTEGER k,imed,Z,zpos,m,ibsearch;
               0
               0  sigmaMedium = 0;
               0  DO k=1,nne(imed) [
               1     Z = int( zelem(imed,k) + 0.5 );zpos = pe_zpos(Z);
               1     m = ibsearch(logE,pe_nge(zpos),pe_energy(1,zpos));
               1     slope = log(pe_xsection(m+1,zpos,0)/pe_xsection(m,zpos,0));
               1     slope = slope/(pe_energy(m+1,zpos)-pe_energy(m,zpos));
               1     sigma = log(pe_xsection(m,zpos,0));
               1     sigma += slope*(logE - pe_energy(m,zpos));
               1     sigma = exp(sigma);
               1     sigmaMedium += pz(imed,k)*sigma;
               1  ]
               0  return; end;
               0
               0  "============================================================================="
               0  subroutine egs_heap_sort(n,rarray,jarray);
               0  "************************************************************************
               0  "  egs_heap_sort will sort the real array rarray of dimension n in
               0  "  ascending order and at the same time put into the integer array
               0  "  jarray the original position of the elements, e.g.
               0  "  if rarray was on input (5,14,8,2), it will be after completion
               0  "  of heap_sort (2,5,8,14) and jarray will be (4,1,3,2).
               0  "  heap_sort uses the heap sort algorithm, the implementation is
               0  "  based  on hpsort from Numerical Recipies with a couple of
               0  "  modifications.
               0  "
               0  "  Iwan Kawrakow, NRC, July 2001
               0  "*************************************************************************
               0
               0  implicit none;
               0
               0  $INTEGER n,jarray(*);
               0  $REAL    rarray(*);
               0  $INTEGER i,ir,j,l,ira;
               0  $REAL    rra;
               0
               0  DO i=1,n [ jarray(i)=i; ]
               0  IF (n < 2) return;
               0  l=n/2+1; ir=n;
               0
               0  LOOP [
               1     IF (l > 1)  [
               2         l=l-1; rra=rarray(l); ira=l;
               2     ]
               1     ELSE [
               2         rra=rarray(ir); ira=jarray(ir);
               2         rarray(ir)=rarray(1); jarray(ir)=jarray(1);
               2         ir=ir-1;
               2         IF (ir = 1) [
               3             rarray(1)=rra; jarray(1)=ira; return;
               3         ]
               2     ]
               1     i=l; j=l+l;
               1     LOOP [
               2         IF( j > ir ) EXIT;
               2         IF (j < ir) [ IF (rarray(j) < rarray(j+1) ) j=j+1; ]
               2         IF (rra < rarray(j)) [
               3             rarray(i)=rarray(j); jarray(i)=jarray(j);
               3             i=j; j=j+j;
               3         ] ELSE [ j=ir+1; ]
               2     ]
               1     rarray(i)=rra; jarray(i)=ira;
               1  ]
               0  return; end;
               0
1              0  %E
               0  "Ali:photonuc, 1 subroutine"
               0  "******************************************************************"
               0  SUBROUTINE PHOTONUC;
               0  "******************************************************************"
               0  " Placeholder for photonuclear modelling. Currently the photon is
               0  " discarded and its energy is thrown away (i.e. not deposited).
               0  "******************************************************************"
               0  $IMPLICIT-NONE;
               0  $COMIN-PHOTONUC; "current default replacement is:
               0                   "COMIN/STACK,EPCONT,USEFUL/"
               0  $DEFINE-LOCAL-VARIABLES-PHOTONUC; "currently empty"
               0
               0  npold = np; "set the old stack counter"
               0  edep = pzero; e(np) = pzero; wt(np) = 0;
               0
               0  return;
               0  end;
               0  "******************************************************************"
               0
          END OF MORTRAN INPUT
  71      PERCENT RULE CAPACITY REMAINING
          NO MORTRAN ERRORS DETECTED
